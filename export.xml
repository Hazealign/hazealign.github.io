<?xml version="1.0" encoding="UTF-8"?>
<!--
 This is a WordPress eXtended RSS file generated by WordPress as an export of your site.
 It contains information about your site's posts, pages, comments, categories, and other content.
 You may use this file to transfer that content from one site to another.
 This file is not intended to serve as a complete backup of your site.
 To import this information into a WordPress site follow these steps:
 1. Log in to that site as an administrator.
 2. Go to Tools: Import in the WordPress admin panel.
 3. Install the "WordPress" importer from the list.
 4. Activate & Run Importer.
 5. Upload this file using the form provided on that page.
 6. You will first be asked to map the authors in this export file to users
    on the site. For each author, you may choose to map to an
    existing user on the site or to create a new user.
 7. WordPress will then import each of the posts, pages, comments, categories, etc.
    contained in this file into your site.
-->
<!-- generator="WordPress.com" created="Thu, 19 Oct 2017 19:39:55 +0900"-->
<rss
    version="2.0"
    xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
    xmlns:content="http://purl.org/rss/1.0/modules/content/"
    xmlns:wfw="http://wellformedweb.org/CommentAPI/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:wp="http://wordpress.org/export/1.2/">
    <channel>
        <title>Realignist's Lifelog</title>
        <link>http://realignist.me/</link>
        <description>책, 음악, 코딩, 피카츄와 함께하는 곳.</description>
        <pubDate>Thu, 19 Oct 2017 19:39:55 +0900</pubDate>
        <language>en</language>
        <wp:wxr_version>1.2</wp:wxr_version>
        <wp:base_site_url>http://realignist.me/</wp:base_site_url>
        <wp:base_blog_url>http://realignist.me/</wp:base_blog_url>
        <wp:wp_author>
            <wp:author_login>haze-lee</wp:author_login>
            <wp:author_email>hazelee@realignist.me</wp:author_email>
            <wp:author_display_name>Haze Lee</wp:author_display_name>
        </wp:wp_author>
        <generator>http://wordpress.com/</generator>
        
        <item>
            <title>내가 Docker를 시작했던 방법</title>
            <link>http://realignist.me/code/2017/06/14/docker-my-usecase.html</link>
            <pubDate>Wed, 14 Jun 2017 09:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2017/06/14/docker-my-usecase.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>요즘 세상에 Docker를 들어보지 않은 소프트웨어 개발자는 꽤나 드물 것이다. Docker가 컨테이너를 이용한 격리 환경을 만들어주고, 배포나 관리 등에 이점이 있다는걸 알고 있는 사람도 많지만 그럼에도 불구하고 Docker를 쓰기엔 주저하는 일이 많다. 필자 또한 최근까지 Docker가 어려운 존재라고 생각했었고 지금까지 도입하는걸 주저하고 있었다. 필자는 “이번엔 무슨 일이 있어도 내가 Docker를 써봐야겠다!”라는 일념으로 새로 시작하는 프로젝트에 Docker를 도입하게 되었는데 이게 생각보다 너무 간단한 일이었기 때문에 이번 글에서는 필자가 어떻게 Docker를 시작하게 되었는지를 공유하려고 한다.</p>

<p>이 글은 Docker가 무엇인지는 알고 있다는 전제 하에 써진 글이므로, Docker가 무엇인지 잘 모른다면 이재홍님의 <a href="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter01">가장 빨리 만나는 도커 1장</a>을 읽는걸 추천한다. 이 글만 잘 따라해도 아래 사진처럼 커밋이 올라가면 CI가 Docker 이미지를 만들어서 업로드하고 서버에 배포까지 하는 플로우를 구성할 수 있다.</p>

<p><img src="http://realignist.me/assets/images/20170614/dockerhub_example.png" alt="" /></p>

<p><img src="http://realignist.me/assets/images/20170614/travis_example.png" alt="" /></p>

<h2 id="section">설치가 반이다.</h2>

<p>시작이 반이라는 말처럼, Docker도 설치가 반이다. Docker가 리눅스 컨테이너 기술에서 시작된 물건이다보니, 리눅스에서는 옛날부터 설치가 그렇게 어렵지 않았지만 Windows와 macOS 환경에서는 제대로 Docker를 사용하려면 최신 운영체제를 써야하는 번거로움이 있다. 예전에는 리눅스가 아닌 운영체제에서는 Boot2Docker나 Docker Toolbox라는걸 통해 작은 리눅스 가상머신을 올려놓고 그 위에서 Docker가 돌아갔었다.</p>

<ul>
  <li>macOS에서 Docker는 <a href="https://github.com/mist64/xhyve">xhyve</a>를 이용한다. xhyve는 macOS를 위한 경량 가상화 환경으로 <code class="highlighter-rouge">Hypervisor.framework</code>라는 10.10 Yosemite부터 추가된 애플의 API를 사용한다.</li>
  <li>Windows에서 Docker는 윈도우 컨테이너와 Hyper-V 컨테이너 기술을 이용한다. Windows 10 Anniversary Edition부터 이를 지원하며, 윈도우10(Pro, Enterprise 에디션) 혹은 윈도우 서버 2016에서만 지원한다.</li>
</ul>

<p>애석하게도 필자가 일하는 곳의 개발 서버 환경은 아직 윈도우 서버 2008 ~ 2012이다. 이럴 때는 VirtualBox나 Hyper-V를 이용하는 Docker Toolbox를 설치해야한다. 인스톨러가 잘 되어있는 편이라, 윈도우나 맥에서는 인스톨러대로 설치하면 별 문제 없이 설치할 수 있을 것이다.</p>

<h2 id="docker-">기존 서버 프로젝트를 Docker로 감싸다.</h2>

<p>필자가 Docker를 도입한 프로젝트는 Kotlin으로 된 Vert.x 서버였다. 프로젝트가 좀 활발한 프레임워크라면 대부분 Docker 이미지를 빌드하는 방법들을 문서로 제공한다. Vert.x도 <a href="http://vertx.io/docs/vertx-docker/">이 글</a>을 통해 기본적인 Docker를 쓰기 위한 가이드를 제공한다. 하지만 필자의 프로젝트는 Maven이 아니고 Gradle로 빌드를 관리하기도 하고, 그대로 쓰기엔 무리가 있었다.</p>

<p>다행히 Gradle에도 Docker를 지원하는 플러그인이 있다. 두개가 있고, 둘 다 비슷한 Star 수를 가지고 있다.</p>

<ul>
  <li><a href="https://github.com/Transmode/gradle-docker">Transmode/gradle-docker</a></li>
  <li><a href="https://github.com/bmuschko/gradle-docker-plugin">bmuschko/gradle-docker-plugin</a></li>
</ul>

<p>필자는 <a href="https://github.com/advantageous/vertx-node-ec2-eventbus-example/wiki/Step-7-Adding-docker-support-to-gradle-and-deploying-our-image-to-Mesos-Marathon#add-docker-support-to-gradle">이 글</a>을 참조했고, <code class="highlighter-rouge">buildscript.dependencies</code>에 <code class="highlighter-rouge">gradle-docker</code> 플러그인을 추가한 것 이외에는 다음 코드만으로 Docker 이미지를 생성할 수 있게 되었다.</p>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">docker</span> <span class="o">{</span>
    <span class="n">baseImage</span> <span class="s2">"vertx/vertx3-exec"</span>
    <span class="n">maintainer</span> <span class="s1">'Haze Lee "hazelee@realignist.me"'</span>
    <span class="n">registry</span>
<span class="o">}</span>

<span class="n">task</span> <span class="nf">buildDocker</span><span class="o">(</span><span class="nl">type:</span> <span class="n">Docker</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tagVersion</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s2">"COMMIT"</span><span class="o">)</span> <span class="o">?:</span> <span class="n">project</span><span class="o">.</span><span class="na">version</span>
    <span class="n">push</span> <span class="o">=</span> <span class="n">Boolean</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="s2">"docker.push"</span><span class="o">)</span>
    <span class="n">applicationName</span> <span class="o">=</span> <span class="s2">"realignist/..."</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="s2">"${applicationName}"</span>

    <span class="n">addFile</span> <span class="o">{</span>
        <span class="n">from</span> <span class="s2">"${project.shadowJar.outputs.files.singleFile}"</span>
        <span class="n">into</span> <span class="s2">"/opt/hello/"</span>
    <span class="o">}</span>

    <span class="n">exposePort</span> <span class="mi">8080</span>
    <span class="n">entryPoint</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"sh"</span><span class="o">,</span>  <span class="s2">"-c"</span><span class="o">]</span>
    <span class="n">defaultCommand</span> <span class="o">=</span> <span class="o">[</span><span class="s2">"java -jar /opt/hello/${project.name}-${project.version}-fat.jar"</span><span class="o">]</span>
<span class="o">}</span></code></pre></figure>

<p>똑같이 jar 파일로 뽑아내서 실행할 수 있는 환경이라면 설정은 이와 크게 다르지 않을 것이다. 미리 Docker Hub에 로그인을 하고 프로젝트를 미리 만들어뒀다면, 다음 커맨드만으로 이미지 빌드부터 Docker Hub로의 업로드까지 한번에 할 수 있다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell">gradle -Ddocker.push<span class="o">=</span><span class="nb">true </span>build shadowJar buildDocker</code></pre></figure>

<h2 id="section-1">자동으로 이미지를 만들자.</h2>

<p>놀랍게도 DockerHub는 GitHub 연동을 통해 자동으로 이미지 빌드를 뽑아낼 수 있다. <a href="https://docs.docker.com/docker-hub/builds/">이 문서</a>에 자세히 나와있는데, Dockerfile이 프로젝트 안에 있어야하고 또 많은 프로젝트들이 의존성 관계도 있기 때문에 이 기능을 그대로 쓰기는 어렵다. 하지만 우리에겐 Travis나 CircleCI같은 CI 서비스가 있고 우리는 이걸 활용하면 커밋에 따라 자동으로 이미지를 만들고 업로드할 수 있다.</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">sudo</span><span class="pi">:</span> <span class="s">false</span>
<span class="s">language</span><span class="pi">:</span> <span class="s">java</span>
<span class="s">jdk</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">oraclejdk8</span>

<span class="s">services</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">docker</span>

<span class="s">before_script</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">chmod +x gradlew</span>

<span class="s">before_install</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">docker login -e="$DOCKER_EMAIL" -u="$DOCKER_USERNAME" -p="$DOCKER_PASSWORD"</span>

<span class="s">script</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">gradle -Ddocker.push=true build shadowJar buildDocker</span>

<span class="s">env</span><span class="pi">:</span>
  <span class="s">global</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">COMMIT=${TRAVIS_COMMIT::7}</span>

<span class="s">branches</span><span class="pi">:</span>
  <span class="s">only</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">master</span></code></pre></figure>

<p>위 yaml 파일은 필자가 실제로 쓰고 있는 Travis 셋팅 파일이다. Travis의 프로젝트 셋팅에서 DockerHub의 계정 정보(<code class="highlighter-rouge">$DOCER_EMAIL</code>, <code class="highlighter-rouge">DOCKER_USERNAME</code>, <code class="highlighter-rouge">DOCKER_PASSWORD</code>)를 미리 지정해두면 <code class="highlighter-rouge">master</code> 브랜치에 새 커밋이 올라올 때마다 이미지를 빌드하고 업로드한다. gradle 코드 부분을 보면 알겠지만 <code class="highlighter-rouge">COMMIT</code>이라는 이름의 환경변수가 있으면 생성되는 도커 이미지의 버전을 이 환경변수로 올리도록 해놨기 때문에, <code class="highlighter-rouge">env.global</code>에 <code class="highlighter-rouge">COMMIT</code>이라는 환경변수를 추가해뒀다. 저렇게 <code class="highlighter-rouge">${TRAVIS_COMMIT::7}</code>이라 표현해두면 빌드가 실행되는 프로젝트 마지막 커밋의 해쉬값에서 7자만 따오는게 된다.</p>

<p>또 <code class="highlighter-rouge">before_script</code>의 chmod는 CI 환경에서 gradle로 빌드하기 위해서 프로젝트에 있는 <code class="highlighter-rouge">gradlew</code> 파일에 권한을 주는 것이다. Travis는 gradle 프로젝트에서는 자동으로 <code class="highlighter-rouge">gradlew assemble</code>를 실행하기 때문에, chmod로 권한을 주지 않으면 빌드 오류가 발생한다.</p>

<h2 id="section-2">자동으로 업데이트되는 환경을 만들자.</h2>

<p><img src="http://realignist.me/assets/images/20170614/google_docker_deploy.png" alt="" /></p>

<p>구글에 Docker를 쳐보면 수많은 배포 자동화 사례들을 볼 수 있다. 대부분 DockerHub로 이미지를 배포하는 부분에서 글이 끝나는데 나는 정말로 실제 쓰고 있는 스테이징 혹은 릴리즈 서버에 새 이미지가 자동으로 올라가게 하는 것까지 이야기해보고 싶다.</p>

<p>실제 서비스 환경에서는 확장성을 위해 컨테이너를 여러 개 쓰는 경우도 있다. 인스턴스가 하나라면 그냥 들어가서 수동으로 이미지를 받고 다시 올리는 방법도 있겠지만, 여러 대의 서버가 있다면 이걸 자동화해야한다. 선택지가 꽤 많고 정답이 없기 때문에 도구는 자신이 선택하면 될 것 같다.</p>

<ul>
  <li><a href="https://github.com/v2tec/watchtower">v2tec/watchtower</a>는 DockerHub 등에서 베이스 이미지가 업데이트되면 그걸 감지해서 새 이미지를 받아서 재시작해주는 툴이다. 처음 시작할 때만 셋팅해주면 되기 때문에 서버 노드가 적을 때 고려해볼 수 있다.</li>
  <li>만약 노드 수가 늘어난다면… 이제 정말로 여러 컨테이너를 관리해주는 Container Orchestration 도구가 필요할 것이다.
    <ul>
      <li>Docker에서 클러스터를 위해 <a href="https://docs.docker.com/engine/swarm/">Swarm</a>이라는 도구를 자체적으로 제공하지만 아직은 3rd 파티 도구가 더 많이 쓰이는 것 같다. Swarm에 관심이 있다면 <a href="https://subicura.com/2017/02/25/container-orchestration-with-docker-swarm.html">subicura님의 글</a>을 강력 추천한다.</li>
      <li><a href="https://kubernetes.io/">Kubernetes</a>는 구글 클라우드에서 도커 컨테이너를 관리해주기 위해 만든 오픈소스 도구이다. 로컬 머신이나 싱글 노드에서는 Minikube를 통해 로컬에서도 실행할 수 있다.
        <ul>
          <li>https://www.slideshare.net/seungyongoh3/ndc17-kubernetes</li>
          <li>https://www.slideshare.net/naver-labs/docker-kubernetes</li>
          <li>https://1ambda.github.io/infrastructure/container/kubernetes-intro/</li>
        </ul>
      </li>
      <li>트위터나 Airbnb, 애플<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, 우버 등이 쓰고 있는 분산 시스템 커널인 아파치의 <a href="http://mesos.apache.org/">Mesos</a>도 있다. <a href="https://mesosphere.com/solutions/container-orchestration/">Mesosphere</a>라는 회사에서 만든 <a href="https://github.com/mesosphere/marathon">Marathon</a>을 통해 컨테이너를 관리할 수 있다.
        <ul>
          <li>Mesos는 <a href="https://zookeeper.apache.org/">Zookeeper</a>를 이용해서 여러 대의 서버를 하나의 클러스터로 관리한다.</li>
          <li><a href="https://github.com/mesos/chronos">mesos/chronos</a>를 통해 스케쥴링을 돌릴 수 있다.</li>
          <li>설치와 관리가 비교적 어려운 편이다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>필자의 프로젝트는 아직 릴리즈되지 않았기 때문에 아직은 개발 환경에서 watchtower만 쓰고 있다. 다음과 같은 커맨드로 watchover를 구성할 수 있다.</p>

<figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="c"># watchover를 실행하기 전에 먼저 프로젝트의 docker container를 실행해야한다.</span>
<span class="c"># 이 커맨드를 실행하면 watchover 컨테이너에서 실행 중인 다른 모든 컨테이너들을 모니터링할 것이다.</span>
docker run -d <span class="se">\</span>
  --name watchtower <span class="se">\</span>
  -v /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
  v2tec/watchtower</code></pre></figure>

<h2 id="section-3">후기</h2>

<p>뭔가 한게 없는 것 같지만, 아니 실제로도 Docker의 설치를 제외하곤 <code class="highlighter-rouge">build.gradle</code>와 <code class="highlighter-rouge">.travis.yml</code>  몇 줄 추가했을 뿐이다. 이제 열심히 개발해서 master 브랜치로 커밋을 머지하면, CI가 Docker 이미지를 만들어서 업로드하고 이 이미지는 자동으로 서버로 올라가게 된다. 물론 나중에 프로젝트가 커지면 여러 실행 환경들을 Dockerfile에 담아야하니 설정이 더욱 복잡해지긴 하겠지만, 마치 하스켈의 <a href="https://e.xtendo.org/haskell/ko/monad_fear/slide#1">모나드 괴담</a>처럼 Docker는 어쩌면 사람들이 아니 내가 너무 어렵게 생각해온 것 같다. 이 글을 통해 독자도 자신의 프로젝트에 도커를 적용할 수 있었으면 좋겠다.</p>

<p>이렇게 짧은 삽질을 하기까지 구글신과 기존 플러그인들의 도움을 많이 받았고, 이재홍님의 <a href="http://pyrasis.com/private/2014/11/30/publish-docker-for-the-really-impatient-book">Docker 책</a>과 <a href="https://www.slideshare.net/pyrasis/docker-fordummies-44424016">슬라이드</a>가 큰 도움이 되었다. 이미 책을 가지고 있지만, 책의 원고를 또 인터넷에 공개해주셔서 또 편하게 읽을 수 있었다.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>애플은 전 세계에서 쓰이는 시리를 위해 Mesos와 애플 내부의 커스텀 스케쥴러인 JARVIS를 쓰고 있다. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>내가-docker를-시작했던-방법</wp:post_id>
            <wp:post_date>2017-06-14 09:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>RxJava 2.x, 무엇이 달라졌을까?</title>
            <link>http://realignist.me/code/2017/01/25/rxjava2-changelog.html</link>
            <pubDate>Wed, 25 Jan 2017 12:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2017/01/25/rxjava2-changelog.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h2 id="section">글에 앞서,</h2>

<p>RxJava 2.x은 <a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive-Streams 표준</a>에 맞게 많은 부분이 바뀌었습니다. 오늘은 RxJava Wiki에 있는 <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">What’s Different in 2.0</a> 문서를 번역하면서 어떤 점들이 바뀌었나 알아보는 시간을 갖도록 하겠습니다.</p>

<hr />

<p>RxJava 2.0은 Reactive-Streams의 표준 사양에 따라 처음부터 다시 작성되었습니다. 사양에 대해서는 RxJava 1.x에서 발전했으며, 리액티브 시스템과 라이브러리에 대한 공통된 기준을 제시합니다.</p>

<p>왜냐하면 Reactive-Streams는 기존의 RxJava와는 아키텍처가 다르므로, 기존 RxJava의 많은 타입을 변경해야만 했습니다. 이 페이지에서는 변경된 내용을 요약하고, RxJava 1.x로 된 코드를 RxJava 2.x 코드로 다시 작성하는 법을 설명합니다.</p>

<p>RxJava 2.x를 위한 오퍼레이터를 작성하는 방법은 <a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0">오퍼레이터를 작성하는 법</a>이라는 Wiki 페이지를 방문해주세요.</p>

<h2 id="section-1">메이븐 주소와 베이스 패키지</h2>

<p>RxJava 1.x와 RxJava 2.x를 나란히 둘 수 있도록 RxJava 2.x는 Maven 좌표 <code class="highlighter-rouge">io.reactivex.rxjava2:rxjava:2.x.y</code>로 받아올 수 있으며 클래스는 <code class="highlighter-rouge">io.reactivex</code>에서 접근할 수 있습니다.</p>

<p>1.x에서 2.x로 전환하는 사용자들은 import를 처음부터 다시 구성해야하므로, 조심해야 합니다.</p>

<h2 id="javadoc">Javadoc</h2>

<p>RxJava 2.x를 위한 공식 Javadoc은 <a href="http://reactivex.io/RxJava/2.x/javadoc/">여기</a>에서 보실 수 있습니다.</p>

<h2 id="null-">Null 값</h2>

<p>RxJava 2.x는 더는 <code class="highlighter-rouge">null</code> 값을 허용하지 않으며, 다음과 같은 코드들은 즉시, 또는 다운스트림으로 NullPointerException을 발생할 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="n">Single</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">.</span><span class="na">fromCallable</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<p>이 말은 즉, <code class="highlighter-rouge">Observable&lt;Void&gt;</code>는 더는 값을 발생시킬 수 없으며 정상적으로 종료되거나 Exception을 발생시킵니다. API 디자이너들은 대신 <code class="highlighter-rouge">Object</code>가 어떤 값이 될지 보장할 수 없을 때 <code class="highlighter-rouge">Observable&lt;Object&gt;</code>를 사용할 수 있습니다. (어쨌든 관련이 없어야 합니다.) 예를 들어 신호기와 같은 소스가 필요할 때, 공유 enum을 정의하고 해당 인스턴스를 <code class="highlighter-rouge">onNext</code>에 담아 보낼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">Irrelevant</span> <span class="o">{</span> <span class="n">INSTANCE</span><span class="o">;</span> <span class="o">}</span>

<span class="n">Observable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">((</span><span class="n">ObservableEmitter</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">emitter</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 1"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 2"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 3"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
<span class="o">});</span>

<span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="cm">/* Ignored. */</span> <span class="o">},</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<h2 id="observable-flowable">Observable과 Flowable</h2>

<p>RxJava 0.x에서 배압 개념을 도입하면서 별도의 베이스가 되는 리액티브 클래스를 두지 않고, <code class="highlighter-rouge">Observable</code>을 필요에 맞게 개조해서 사용했던거에 대한 약간의 후회가 있습니다. Backpressure의 주된 문제점은 UI 이벤트와 같은 많은 핫 소스들이 합리적으로 배압되지 않고, 예기치 않은 <code class="highlighter-rouge">MissingBackpressureException</code>이 발생할 수 있는 것이었습니다. (즉, 초보자들은 이런 문제를 예상하지 못합니다.)</p>

<p>우리는 2.x에서 이러한 문제를 해결하기 위해  <code class="highlighter-rouge">io.reactivex.Observable</code>에는 Backpressure를 없애고, Backpressure가 적용된 새로운 기본 리액티브 클래스인 <code class="highlighter-rouge">io.reactivex.Flowable</code>를 만들었습니다.</p>

<p>좋은 소식은 오퍼레이터의 이름이 대부분 같다는 것입니다. 나쁜 소식은 import를 관리할 때 의도치 않게 Backpressure가 적용되지 않은 <code class="highlighter-rouge">io.reactivex.Observable</code>을 선택할 수 있으므로 조심해야 합니다.</p>

<h3 id="section-2">어떤 타입을 써야할까?</h3>

<p>RxJava의 최종 소비자로서 데이터 플로우를 설계하거나, 2.x에 호환되는 라이브러리를 사용할 때 <code class="highlighter-rouge">MissingBackpressureException</code> 또는 <code class="highlighter-rouge">OutOfMemoryError</code>와 같은 문제를 피하는데 도움이 되는 몇 가지 요소를 고려할 수 있습니다.</p>

<h4 id="observable--">Observable을 써야할 때,</h4>

<ul>
  <li>만약 플로우에 1000개 이하의 항목이 있다면, 시간이 지나면서 항목이 대부분 없어지기 때문에 애플리케이션에서 <code class="highlighter-rouge">OutOfMemoryError</code>가 발생할 일이 없습니다.</li>
  <li>마우스 움직임이나 터치 이벤트와 같은 GUI 이벤트를 처리할 때는 합리적으로 Backpressure를 줄 수 없으며, 빈번하지도 않습니다. <code class="highlighter-rouge">Observable</code>을 사용하면 초당 1000개 혹은 그 이하의 항목을 처리할 수 있지만 샘플링이나 디바운싱을 사용하는 것이 좋습니다.</li>
  <li>플로우가 본질적으로는 동기식이지만 플랫폼이 Java 스트림을 지원하지 않거나 그런 기능이 있다는걸 놓쳤을 때, <code class="highlighter-rouge">Observable</code>을 쓰는 것이 <code class="highlighter-rouge">Flowable</code>을 쓰는 것보다 대부분 오버헤드가 적습니다. <em>(Java 6+를 지원하는 Iterable 플로우에 최적화된 IxJava도 고려할 수 있습니다.)</em></li>
</ul>

<h4 id="flowable--">Flowable을 써야할 때,</h4>

<ul>
  <li>어딘가에서 생성되는 10000개 이상의 요소를 처리할 때, 체인은 소스가 생성되는 양을 제한할 수 있습니다.</li>
  <li>파일을 디스크에서 읽거나 파싱하는 일은 본질적으로 블로킹이고, 풀에 기반(Pull-based)합니다. 이럴 때는 Backpressure를 통해 사용자가 제어할 수 있습니다.</li>
  <li>JDBC를 통해 데이터베이스를 읽는 것 또한 블로킹이고 풀에 기반을 두며, 각 다운스트림 요청에 대해 <code class="highlighter-rouge">ResultSet.next()</code>를 호출해서 사용자가 제어할 수 있습니다.</li>
  <li>네트워크를 거치거나, 논리적 리소스를 요청하는 프로토콜을 사용하는 네트워크 (스트리밍) 입출력</li>
  <li>추후에 논블로킹 리액티브 API 혹은 드라이버를 지원하게 될 수 있는, 블로킹이거나 풀에 기반을 둔 데이터 소스</li>
</ul>

<h2 id="single">Single</h2>

<p>하나의 <code class="highlighter-rouge">onSuccess</code>나 <code class="highlighter-rouge">onError</code>를 방출할 수 있는 기본 리액티브 타입인 <code class="highlighter-rouge">Single</code>은 2.x에서 처음부터 다시 디자인되었습니다. 이 아키텍처는 Reactive-Streams의 디자인에서 파생되었습니다. 해당 소비자 타입인 <code class="highlighter-rouge">rx.Single.SingleSubscriber</code>는 <code class="highlighter-rouge">rx.Subscription</code>을 받을 수 있도록 인터페이스 <code class="highlighter-rouge">io.reactivex.SingleObserver&lt;T&gt;</code>는 딱 3개의 메소드만을 가지도록 다음과 같이 바뀌었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SingleObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Disposable</span> <span class="n">d</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">error</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이를 통해 <code class="highlighter-rouge">onSubscribe(onSuccess | onError)?</code> 규격을 따를 수 있게끔 되었습니다.</p>

<h2 id="completable">Completable</h2>

<p><code class="highlighter-rouge">Completable</code> 타입은 대체로 비슷합니다. 1.x 때 Reactive-Streams의 스타일에 따라 설계되었기 때문에 사용자 레벨의 변경사항은 없습니다.</p>

<p>명칭이 바뀐 것과 비슷하게, <code class="highlighter-rouge">rx.Completable.CompletableSubscriber</code>는 <code class="highlighter-rouge">onSubscribe(Disposable)</code>와 함께 <code class="highlighter-rouge">io.reactivex.CompleteObserver</code>가 되었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">CompletableObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Disposable</span> <span class="n">d</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">error</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이를 통해 <code class="highlighter-rouge">onSubscribe(onSuccess | onError)?</code> 규격을 계속 따르고 있습니다.</p>

<h2 id="maybe">Maybe</h2>

<p>RxJava 2.0.0-RC2에선 새로운 기본 리액티브 타입인 <code class="highlighter-rouge">Maybe</code>가 도입되었습니다. 개념적으로 <code class="highlighter-rouge">Single</code>과 <code class="highlighter-rouge">Completable</code>의 리액티브 소스에 의해 0개 혹은 1개의 항목, 혹은 에러를 발생할 수 있는 패턴을 포착할 수 있도록 제공합니다.</p>

<p><code class="highlighter-rouge">Maybe</code> 클래스는 <code class="highlighter-rouge">MaybeSource</code>를 기본 인터페이스 타입으로, <code class="highlighter-rouge">onSubscribe (onSuccess | onError | onComplete)?</code> 규격을 따르는 <code class="highlighter-rouge">MaybeObserver</code>를 데이터를 수신하는 인터페이스로 이용합니다. 왜냐면 많아도 1개의 항목이 발생할 수 있기 때문에, <code class="highlighter-rouge">Maybe</code> 타입에는 Backpressure 개념이 없습니다. (왜냐하면 알 수 없는 길이의 <code class="highlighter-rouge">Flowable</code>이나 <code class="highlighter-rouge">Observable</code>과 같이 Buffer가 팽창할 가능성이 없기 때문입니다.)</p>

<p>이는 <code class="highlighter-rouge">onSubscribe(Disposable)</code>의 호출에는 잠재적으로 다른 <code class="highlighter-rouge">onXXX</code> 메소드 중 하나가 따라옵니다. <code class="highlighter-rouge">Flowable</code>과는 달리 단일 값만이 있는 경우 <code class="highlighter-rouge">onSuccess</code>만이 호출되며, <code class="highlighter-rouge">onComplete</code>는 호출되지 않습니다.</p>

<p>이 새로운 기본 리액티브 타입은 0개 또는 1개의 항목에 동작하는 <code class="highlighter-rouge">Flowable</code> 오퍼레이터의 적당한 서브셋을 제공하므로 다른 타입과 실질적으로 같습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Maybe</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">defaultIfEmpty</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="na">test</span><span class="o">()</span>
    <span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></code></pre></figure>

<h2 id="section-3">기본 리액티브 인터페이스</h2>

<p>Reactive-Streams <code class="highlighter-rouge">Publisher</code>를 <code class="highlighter-rouge">Flowable</code>로 확장하는 스타일에 따라서, 다른 기본 리액티브 클래스들은 이제 <code class="highlighter-rouge">io.reactivex</code> 패키지 안에 있는 비슷한 베이스 인터페이스를 상속받게 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">ObservableSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">Observer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">SingleSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">SingleObserver</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">CompletableSource</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">CompletableObserver</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">MaybeSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">MaybeObserver</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>따라서 사용자의 일부 기본 리액티브 타입을 인자로 받는 많은 오퍼레이터가 이제 <code class="highlighter-rouge">Publisher</code>와 <code class="highlighter-rouge">XSource</code>를 지원합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">Publisher</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">ObservableSource</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">);</span></code></pre></figure>

<p><code class="highlighter-rouge">Publisher</code>를 이런 방식으로 입력하면 다른 Reactive-Streams에 호환되는 라이브러리를 랩핑하거나, Flowable로 변환할 필요 없이 작성할 수 있습니다.</p>

<p>그러나 오퍼레이터가 기본 리액티브 타입을 제공해야하는 경우, 사용자는 전체 리액티브 클래스를 받게 됩니다. (<code class="highlighter-rouge">XSource</code>를 제공하는 것은 오퍼레이터가 없으므로 실질적으로 쓸모가 없습니다.)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">windows</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

<span class="n">source</span><span class="o">.</span><span class="na">compose</span><span class="o">((</span><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">flowable</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="n">flowable</span>
        <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">io</span><span class="o">())</span>
        <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">()));</span></code></pre></figure>

<h2 id="subject-processor">Subject와 Processor</h2>

<p>Reactive-Streams 사양에서 이벤트의 소비자이면서 동시에 공급자이기도 한 <code class="highlighter-rouge">Subject</code>와 비슷한 동작들은 <code class="highlighter-rouge">org.reactivestream.Processor</code> 인터페이스에 의해 수행됩니다. <code class="highlighter-rouge">Observable</code>과 <code class="highlighter-rouge">Flowable</code>의 분리와 마찬가지로, Backpressure와 Reactive-Streams 사양을 준수한 구현은 <code class="highlighter-rouge">FlowableProcessor</code> 클래스를 기반으로 합니다. (<code class="highlighter-rouge">Flowable</code>을 확장하여 풍부한 인스턴스 내 오퍼레이터를 제공합니다.) <code class="highlighter-rouge">Subject</code>에서 중요한 변화는 더는 <code class="highlighter-rouge">T -&gt; R</code>과 같은 변환을 지원하지 않은 것입니다. (입력 타입이 T이고 출력 타입이 R 유형임을 뜻합니다.) (우리는 1.x에서 이 클래스를 사용하지 못했고, 원래 <code class="highlighter-rouge">Subject</code>는 .NET에서 왔는데 .NET에서는 같은 클래스 이름에 다른 수의 타입 인자를 둘 수 있어 오버로드가 있었습니다.)</p>

<p>다음 클래스들 <code class="highlighter-rouge">io.reactivex.subjects.AsyncSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.BehaviorSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.PublishSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.ReplaySubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.UnicastSubject</code>은 RxJava 2.x에서 Backpressure를 지원하지 않습니다. (2.x의 <code class="highlighter-rouge">Observable</code> 계열의 일부로서)</p>

<p>다음 클래스들 <code class="highlighter-rouge">io.reactivex.processors.AsyncProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.BehaviorProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.PublishProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.ReplayProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.UnicastProcessor</code>는 Backpressure를 쓸 수 있습니다. <code class="highlighter-rouge">BehaviorProcessor</code>와 <code class="highlighter-rouge">PublishProcessor</code>는 다운스트림 Subscriber의 요청을 조정하지 않으며(<code class="highlighter-rouge">Flowable.publish()</code>를 씁니다.), 다운스트림이 계속 유지될 수 없을 때 <code class="highlighter-rouge">MissingBackpressureException</code>으로 알려줍니다. 다른 <code class="highlighter-rouge">XProcessor</code> 타입들은 다운스트림 Subscriber의 Backpressure를 존중하지만, 소스를 subscribe할 때(선택 사항) 무제한적으로 소비하게 됩니다. (<code class="highlighter-rouge">Long.MAX_VALUE</code>를 요청합니다.)</p>

<h2 id="testsubject">TestSubject</h2>

<p>1.x에 있었던 <code class="highlighter-rouge">TestSubject</code>가 삭제되었습니다. 이 기능은 <code class="highlighter-rouge">TestScheduler</code>, <code class="highlighter-rouge">PublishProcessor</code>/<code class="highlighter-rouge">PublishSubject</code>와 <code class="highlighter-rouge">observeOn(testScheduler)</code>/scheduler 파라미터를 통해 수행할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TestScheduler</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestScheduler</span><span class="o">();</span>
<span class="n">PublishSubject</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">delay</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="n">scheduler</span><span class="o">)</span>
    <span class="o">.</span><span class="na">test</span><span class="o">();</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertEmpty</span><span class="o">();</span>

<span class="n">ps</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="n">scheduler</span><span class="o">.</span><span class="na">advanceTimeBy</span><span class="o">(</span><span class="mi">999</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertEmpty</span><span class="o">();</span>

<span class="n">scheduler</span><span class="o">.</span><span class="na">advanceTimeBy</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertValue</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h2 id="section-4">다른 클래스들</h2>

<p><code class="highlighter-rouge">rx.observables.ConnectableObservable</code> 는 이제 <code class="highlighter-rouge">io.reactivex.observables.ConnectableObservable</code>와 <code class="highlighter-rouge">io.reactivex.flowables.ConnectableFlowable</code>로 바뀌었습니다.</p>

<h3 id="groupedobservable">GroupedObservable</h3>

<p>기존 <code class="highlighter-rouge">rx.observables.GroupedObservable</code>는 <code class="highlighter-rouge">io.reactivex.observables.GroupedObservable</code>와 <code class="highlighter-rouge">io.reactivex.flowables.GroupedFlowable</code>로 바뀌었습니다.</p>

<p>1.x에서는 <code class="highlighter-rouge">GroupedObservable.from()</code>을 통해 인스턴스를 생성할 수 있었습니다. 2.x에서는 팩토리 메소드가 더는 제공되지 않기 때문에 <code class="highlighter-rouge">GroupedObservable</code>을 직접 확장해서 써야합니다. 전체 클래스는 추상화되었습니다.</p>

<p>다음과 같이 클래스를 확장하고 사용자가 정의한 <code class="highlighter-rouge">subscribeActural</code> 동작을 추가하여 1.x와 유사한 기능을 구현할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MyGroup</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">GroupedObservable</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>

    <span class="kd">final</span> <span class="n">Subject</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">subject</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyGroup</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subject</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">subscribeActual</span><span class="o">(</span><span class="n">Observer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">subject</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>(<code class="highlighter-rouge">GroupedFlowable</code>도 비슷한 방법으로 이용할 수 있습니다.)</p>

<h2 id="section-5">함수형 인터페이스</h2>

<p>1.x와 2.x 모두 Java 6+를 대상으로 하므로 우리는 <code class="highlighter-rouge">java.util.function.Function</code>과 같은 Java 8의 함수형 인터페이스를 사용할 수 없습니다. 하지만 우리는 자체적인 함수형 인터페이스를 1.x에서 구현했으며, 2.x에서도 그 전통을 따랐습니다.</p>

<p>주목할만한 차이점은 이제 우리의 모든 함수형 인터페이스에 <code class="highlighter-rouge">throws Exception</code>가 붙었습니다. 더는 <code class="highlighter-rouge">try-catch</code> 문으로 감싸거나, 검사 예외를 바꿀 필요가 없으므로 소비자와 매퍼에 큰 편의를 제공합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"file.txt"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">Files</span><span class="o">.</span><span class="na">readLines</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">lines</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="na">size</span><span class="o">()),</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<p>파일이 없거나 제대로 읽을 수 없을 때, 최종 사용자는 <code class="highlighter-rouge">IOException</code>을 직접 출력합니다. try-catch 없이 호출된 <code class="highlighter-rouge">Files.readLines(name)</code>에 주목해주세요.</p>

<h2 id="action">Action</h2>

<p>컴포넌트 수를 줄일 수 있는 좋은 기회이기 때문에, 2.x에서는 <code class="highlighter-rouge">Action3</code>-<code class="highlighter-rouge">Action9</code>와  <code class="highlighter-rouge">ActionN</code>(RxJava 자체에서는 사용되지 않음)이 빠지게 되었습니다.</p>

<p>나머지 액션 인터페이스들은 Java 8의 함수형 타입에 따라 이름이 바뀌었습니다. 매개변수가 없는 <code class="highlighter-rouge">Action0</code>은 <code class="highlighter-rouge">io.reactivex.functions.Action</code>으로 바뀌었으며, <code class="highlighter-rouge">Scheduler</code> 메소드에 대한 <code class="highlighter-rouge">java.lang.Runnable</code>로 대체됩니다. <code class="highlighter-rouge">Action1</code>은 <code class="highlighter-rouge">Consumer</code>로, <code class="highlighter-rouge">Action2</code>는 <code class="highlighter-rouge">BiConsumer</code>로 이름이 바뀌었습니다. <code class="highlighter-rouge">ActionN</code>은 <code class="highlighter-rouge">Consumer&lt;Object[]&gt;</code> 타입 선언으로 대체됩니다.</p>

<h3 id="function">Function</h3>

<p>우리는 Java 8의 네이밍 컨벤션에 맞춰 <code class="highlighter-rouge">io.reactivex.functions.Function</code>과 <code class="highlighter-rouge">io.reactivex.functions.BiFunction</code>을 정의했으며, <code class="highlighter-rouge">Func3</code> - <code class="highlighter-rouge">Func9</code>를 각각  <code class="highlighter-rouge">Function3</code> - <code class="highlighter-rouge">Function9</code>로 바꿨습니다. <code class="highlighter-rouge">FuncN</code>은 <code class="highlighter-rouge">Function</code>  타입 선언으로 대체됩니다.</p>

<p>또한 서술을 필요로 하는 오퍼레이터는 더는 <code class="highlighter-rouge">Func1&lt;T, Boolean&gt;</code>를 사용하지 않고 별도의 기본 반환 타입인 <code class="highlighter-rouge">Predicate&lt;T&gt;</code>를 가집니다. (오토박싱이 없으므로 더 좋은 인라인이 가능합니다.)</p>

<p><code class="highlighter-rouge">io.reactivex.functions.Functions</code> 유틸리티 클래스는 일반적인 함수 소스와 <code class="highlighter-rouge">Function&lt;Object[], R&gt;</code>으로의 변환을 제공합니다.</p>

<h2 id="subscriber">Subscriber</h2>

<p>Reactive-Streams 사양에는 Subscriber가 자체 인터페이스로 있습니다. 이 인터페이스는 가볍고 요청 관리와 취소를<code class="highlighter-rouge">rx.Producer</code>와 <code class="highlighter-rouge">rx.Subscription</code>을 별도로 갖는 대신 하나의 인터페이스인 <code class="highlighter-rouge">org.reactivestreams.Subscription</code>로 합쳐서 사용합니다. 이렇게 하면 1.x의 무거운 <code class="highlighter-rouge">rx.Subscriber</code>보다 내부 상태가 적은 스트림 소비자를 생성할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>이름이 충돌하므로 패키지를 <code class="highlighter-rouge">rx</code>에서 <code class="highlighter-rouge">org.reactivestreams</code>로 바꾸는 것만으로는 충분하지 않습니다. 또한 <code class="highlighter-rouge">org.reactivestreams.Subscriber</code>는 리소스를 추가하거나 취소하거나 외부에서 요청하는 개념을 가지고 있지 않습니다.</p>

<p>이 격차을 메우기 위해 <code class="highlighter-rouge">rx.Subscriber</code>와 마찬가지로 <code class="highlighter-rouge">Disposable</code>들의 리소스 추적 지원을 제공하고, <code class="highlighter-rouge">dispose()</code>를 통해 외부에서 취소하거나 정리할 수 있는 <code class="highlighter-rouge">Flowable</code>(과 <code class="highlighter-rouge">Observable</code>)을 위한 추상 클래스 <code class="highlighter-rouge">DefaultSubscriber</code>, <code class="highlighter-rouge">ResourceSubscriber</code>, <code class="highlighter-rouge">DisposableSubscriber</code>(<code class="highlighter-rouge">XObserver</code> 변형 포함)를 정의했습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ResourceSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ResourceSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">).</span><span class="na">delay</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span>

<span class="n">subscriber</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span></code></pre></figure>

<p>또한 Reactive-Streams와의 호환을 위해 <code class="highlighter-rouge">onCompleted</code> 메소드는 뒤에 <code class="highlighter-rouge">d</code>가 빠진 <code class="highlighter-rouge">onComplete</code>로 이름이 바뀌었습니다.</p>

<p>1.x에서 <code class="highlighter-rouge">Observable.subscribe(Subscriber)</code>는 <code class="highlighter-rouge">Subscription</code>을 반환했는데, 사용자들은 <code class="highlighter-rouge">Subscription</code>을 다음과 같이 <code class="highlighter-rouge">CompositeSubscription</code>에 추가했었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">CompositeSubscription</span> <span class="n">composite</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompositeSubscription</span><span class="o">();</span>

<span class="n">composite</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()));</span></code></pre></figure>

<p>Reactive-Streams 사양에 따라 <code class="highlighter-rouge">Publisher.subscribe</code>는 void를 반환하므로 이런 패턴은 2.0에서는 더는 작동하지 않습니다. 이를 해결하기 위해 <code class="highlighter-rouge">E subscribeWith(E subscriber)</code> 메소드가 입력받은 구독자와 관찰자를 그대로 반환하는 각 기본 리액티브 클래스에 추가되었습니다. <code class="highlighter-rouge">ResourceSubscriber</code>가 <code class="highlighter-rouge">Disposable</code>을 직접 구현하므로 이전의 두 예제를 사용하면 2.x 코드는 다음과 같이 보입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">CompositeDisposable</span> <span class="n">composite2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompositeDisposable</span><span class="o">();</span>

<span class="n">composite2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">subscribeWith</span><span class="o">(</span><span class="n">subscriber</span><span class="o">));</span></code></pre></figure>

<h3 id="onsubscribeonstart-request-">onSubscribe/onStart에서 request 호출하기</h3>

<p>요청 관리가 어떻게 작동하는지에 따라 <code class="highlighter-rouge">Subscriber.onSubscribe</code>나 <code class="highlighter-rouge">ResourceSubscriber.onStart</code>에서 <code class="highlighter-rouge">request(n)</code>을 호출하면 <code class="highlighter-rouge">request()</code> 호출 자체가 자신의 <code class="highlighter-rouge">onSubscribe</code>/<code class="highlighter-rouge">onStart</code> 메소드로 돌아가기 전에 <code class="highlighter-rouge">onNext</code>를 즉시 호출하도록 유도할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OnSubscribe start"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OnSubscribe end"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>이는 다음과 같이 출력될 것입니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>OnSubscribe start
1
2
3
Done
OnSubscribe end
</code></pre>
</div>

<p>문제는 <code class="highlighter-rouge">request</code>를 호출한 뒤  <code class="highlighter-rouge">onSubscribe/onStart</code>에서 초기화를 수행할 때 문제가 발생하고, <code class="highlighter-rouge">onNext</code>는 초기화의 결과를 볼 수도 있고 보지 않을 수도 있습니다. 이 상황을 피하려면 onSubscribe / onStart에서 <strong>모든 초기화가 완료된 후</strong>에 request를 호출해야 합니다.</p>

<p>2.x에서 이 동작은 <code class="highlighter-rouge">request</code> 호출이 업스트림 <code class="highlighter-rouge">Producer</code>가 도착할 때까지 지연 로직을 거쳐 요청을 축적한 1.x와는 다릅니다. (이 특성은 1.x의 모든 오퍼레이터와 소비자에 오버헤드를 더합니다.) 2.x에서는 항상 <code class="highlighter-rouge">Subscription</code>은 첫 번째로 내려가고, 90%는 요청을 연기할 필요가 없습니다.</p>

<h2 id="subscription">Subscription</h2>

<p>RxJava 1.x에서 <code class="highlighter-rouge">rx.Subscription</code> 인터페이스는 스트림 및 리소스의 라이프사이클 관리, 즉 시퀀스의 구독을 취소하고 예약된 작업과 같은 일반적인 리소스를 해제합니다. Reactive-Streams 사양은 소스와 소비자 간의 상호작용 지점을 지정하기 위해 이 이름을 사용했습니다. <code class="highlighter-rouge">org.reactivestreams.Subscription</code>을 사용하면 업스트림에서 요청할 수 있으며 시퀀스를 취소할 수 있습니다.</p>

<p>이름 충돌을 피하기 위해 1.x의 <code class="highlighter-rouge">rx.Subscription</code>은 <code class="highlighter-rouge">io.reactivex.Disposable</code>(.NET의 IDisposable과 비슷함)으로 이름이 바뀌었습니다.</p>

<p>왜냐하면, Reactive-Streams의 기본 인터페이스 <code class="highlighter-rouge">org.reactivestreams.Publisher</code>는 <code class="highlighter-rouge">subscribe()</code> 메소드를 void로 정의했기 때문입니다. <code class="highlighter-rouge">Flowable.subscribe(Subscriber)</code>는 더는 어떠한 <code class="highlighter-rouge">Subscription</code>이나 <code class="highlighter-rouge">Disposable</code>을 반환하지 않습니다. 다른 기본 리액티브 타입들도 각각의 구독자 타입에 따라 이 규칙을 따릅니다.</p>

<p><code class="highlighter-rouge">subscribe</code>의 다른 오버로드는 2.x에서 <code class="highlighter-rouge">Disposable</code>을 반환합니다.</p>

<p>원래의 <code class="highlighter-rouge">Subscription</code> 컨테이너 타입들은 이름이 바뀌고 새로워졌습니다.</p>

<ul>
  <li><code class="highlighter-rouge">CompositeSubscription</code>은 <code class="highlighter-rouge">CompositeDisposable</code>로 바뀌었습니다.</li>
  <li><code class="highlighter-rouge">SerialSubscription</code>와 <code class="highlighter-rouge">MultipleAssignmentSubscription</code>는 <code class="highlighter-rouge">SerialDisposable</code>로 합쳐졌습니다. <code class="highlighter-rouge">set()</code> 메소드는 오래된 값을 정리하며 <code class="highlighter-rouge">replace()</code> 메소드는 정리하지 않습니다.</li>
  <li><code class="highlighter-rouge">RefCountSubscription</code>는 삭제되었습니다.</li>
</ul>

<h2 id="backpressure">Backpressure</h2>

<p>Reactive-Streams의 사양은 Backpressure를 지원하는 연산자를 요구합니다. 특히 Backpressure를 요구하지 않을 때 소비자가 넘치지 않도록 보장해줍니다. 새로운 <code class="highlighter-rouge">Flowable</code> 기본 리액티브 타입의 오퍼레이터는 이제 다운스트림 요청량을 적절하게 고려하지만 <code class="highlighter-rouge">MissingBackpressureException</code>이 완전히 사라진 것은 아닙니다. 이런 익셉션은 여전히 존재하지만 이번에는 더 많은 신호를 보낼 수 없는 오퍼레이터가 대신 익셉션을 알립니다. (이를 통해 제대로 Backpressure 되지 않은 부분을 더 잘 식별할 수 있습니다.)</p>

<p>대안으로 2.x의 <code class="highlighter-rouge">Observable</code>은 전혀 Backpressure를 하지 않으며, 선택의 여지가 있습니다.</p>

<h2 id="reactive-streams-">Reactive-Streams 호환</h2>

<p>Flowable에 기반을 둔 소스와 오퍼레이터는 규칙 §3.9와 규칙 §1.3의 한 해석을 제외하고 Reactive-Streams 1.0.0 규격을 준수합니다.</p>

<blockquote>
  <p>§3.9: Subscription이 취소되지 않은 동안 Subscription.request(long n)은 인수가 &lt;= 0인 경우 무조건 java.lang.IllegalArgumentException으로 onError를 호출합니다. 에러 메시지에는 이 규칙에 대한 참조가 무조건 포함되어야만 합니다. 그리고 선택적으로 전체 규칙에 대한 인용이 포함될 수 있습니다.</p>
</blockquote>

<p>규칙 §3.9는 버그 케이스에 대처하기 위해 과도한 오버헤드(<code class="highlighter-rouge">request()</code>를 처리하는 <strong>모든</strong> 오퍼레이터에 대한 half-serializer)가 필요합니다. RxJava 2(와 Reactor 3)는 <code class="highlighter-rouge">RxJavaPlugins.onError</code>에 <code class="highlighter-rouge">IllegalArgumentException</code>을 보고하고, 그렇지 않으면 무시합니다. RxJava 2는 <code class="highlighter-rouge">IllegalArgumentException</code>을 비동기식으로 <code class="highlighter-rouge">Subscriber.onError</code>에 라우팅하는 <a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/test/java/io/reactivex/tck/FlowableTck.java">사용자 지정 오퍼레이터</a>를 적용하여 TCK(Test Compatibility Kit)를 전달합니다. 모든 주요 Reactive-Streams 라이브러리에는 이러한 제로 요청이 없습니다. Reactor 3은 이를 무시하고, Akka-Stream은 TCK 오퍼레이터와 비슷한 라우팅 동작을 가진 변환기(다른 RS 소스 및 소비자와 상호작용하기 위해)를 사용합니다.</p>

<blockquote>
  <p>§1.3: onSubscribe, onNext, onError, onComplete는 구독자에게 순차적으로 신호를 보내야 합니다. (동시에 알림을 보낼 수 없습니다.)</p>
</blockquote>

<p>TCK는 <code class="highlighter-rouge">onSubscribe</code>와 <code class="highlighter-rouge">onNext</code>간에 동기식이지만 제한된 재진입을 허용합니다. 즉, <code class="highlighter-rouge">onSubscribe</code>에 있는동안 <code class="highlighter-rouge">request(1)</code> 호출은 <code class="highlighter-rouge">onSubscribe</code>가 제어를 반환하지 않고도 <code class="highlighter-rouge">onNext</code>를 호출할 수 있습니다. 거의 모든 오퍼레이터가 이러한 방식으로 동작하지만 오퍼레이터 <code class="highlighter-rouge">observeOn</code>은 <code class="highlighter-rouge">request(1)</code>에 대한 응답으로 <code class="highlighter-rouge">onNext</code>를 비동기적으로 호출할 수 있으므로 <code class="highlighter-rouge">onSubscribe</code>가 <code class="highlighter-rouge">onNext</code>와 동시에 실행됩니다. 이것은 TCK에 의해 확률적으로 탐지되며 <code class="highlighter-rouge">onSubscribe</code>가 반환될 때까지 다운스트림 요청을 연기하는 <a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/test/java/io/reactivex/tck/FlowableAwaitOnSubscribeTck.java">다른 오퍼레이터</a>를 사용합니다. 이 비동기 동작은 RxJava 2 및 Reactor 3에서 문제가 되지 않습니다. 연산자는 <code class="highlighter-rouge">onSubscribe</code> 안에서 스레드에 안전한 방식으로 작업을 수행하고, Akka-Stream의 변환기는 비슷한 지연된 요청 관리를 수행하기 때문입니다.</p>

<p>이 두 동작은 라이브러리 간의 동작에 영향을 주기 때문에 버전 2.0.5에서는 <code class="highlighter-rouge">strict()</code> 오퍼레이터가 도입되고 항목 당 오버헤드를 희생시키면서 이러한 규칙과 몇가지 추가 규칙이 적용됩니다.</p>

<h2 id="section-6">런타임 훅</h2>

<p>2.x에서는 런타임 시 훅을 변경할 수 있는 <code class="highlighter-rouge">RxJavaPlugins</code>를 다시 디자인했습니다. 스케줄러와 기본 리액티브 타입의 라이프사이클을 오버라이드하려는 테스트는 콜백 함수를 통해 사례별로 수행할 수 있습니다.</p>

<p>클래스에 기반을 둔 <code class="highlighter-rouge">RxJavaObservableHook</code> 및 친구들은 이제 없어졌으며 <code class="highlighter-rouge">RxJavaHooks</code>의 기능들은 <code class="highlighter-rouge">RxJavaPlugins</code> 에 흡수되었습니다.</p>

<h2 id="section-7">에러 처리</h2>

<p>2.x에서의 중요한 설계 요구사항 중 하나는 <code class="highlighter-rouge">Throwable</code> 에러를 무시해서는 안된다는 것입니다. 이것은 다운스트림의 라이프사이클이 이미 터미널 상태에 도달했거나 다운스트림이 에러를 방출하려고 했던 시퀀스를 취소했기 때문에 방출할 수 없는 에러를 의미합니다.</p>

<p>이러한 에러들은 <code class="highlighter-rouge">RxJavaPlugins.onError</code> 핸들러로 전달됩니다. 이 핸들러는 <code class="highlighter-rouge">RxJavaPlugins.setErrorHandler(Consumer)</code> 메소드로 오버라이드할 수 있습니다. 특정 핸들러가 없으면 RxJava는 기본적으로 Throwable의 스택 추적을 콘솔에 출력하고 현재 스레드의 포착되지 않은 예외 핸들러를 호출합니다.</p>

<p>데스크톱 자바에서 이 후처리기는 Executer-Service 기반 Scheduler에서 아무런 작업도 수행하지 않고 애플리케이션을 계속 실행합니다. 그러나 Android는 더 엄격하고 예기치 못한 예외 상황에서 애플리케이션을 종료합니다.</p>

<p>이 동작이 바람직할 경우 논쟁의 여지가 있지만, 어쨌든 잡히지 않은 에러 핸들러의 호출을 피하려면 RxJava 2를 사용하는 <strong>최종 응용 프로그램</strong>(직접 혹은 간접적으로)에 no-op 핸들러를 설정해야 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 자바 8의 람다식을 쓸 수 있을 때</span>
<span class="n">RxJavaPlugins</span><span class="o">.</span><span class="na">setErrorHandler</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">});</span>

<span class="c1">// Retrolambda나 Jack을 쓸 수 없을 때</span>
<span class="n">RxJavaPlugins</span><span class="o">.</span><span class="na">setErrorHandler</span><span class="o">(</span><span class="n">Functions</span><span class="o">.&lt;</span><span class="n">Throwable</span><span class="o">&gt;</span><span class="n">emptyConsumer</span><span class="o">());</span></code></pre></figure>

<p>중간 라이브러리가 자체 테스트 환경 밖에서 에러 핸들러를 변경하는 것은 권장되지 않습니다.</p>

<h2 id="scheduler">Scheduler</h2>

<p>2.x API에서도 <code class="highlighter-rouge">io.reactivex.schedulers.Schedulers</code> 유틸리티 클래스를 통해 계속 <code class="highlighter-rouge">computation</code>, <code class="highlighter-rouge">io</code>, <code class="highlighter-rouge">newThread</code>, <code class="highlighter-rouge">trampoline</code> 등의 기본 스케줄러 타입을 지원합니다.</p>

<p><code class="highlighter-rouge">immediate</code> 스케줄러는 2.x에서 없어졌습니다. 그것은 종종 잘못 사용되었고 <code class="highlighter-rouge">Scheduler</code>의 스펙을 올바르게 구현하지 못했습니다. 그것은 지연된 행동에 대한 sleep을 차단하는 것을 포함하며 재귀적 스케줄링을 전혀 지원하지 않았습니다. 대신 <code class="highlighter-rouge">Schedulers.trampoline()</code>을 사용하십시오.</p>

<p><code class="highlighter-rouge">Schedulers.test()</code>는 나머지 기본 스케줄러와의 개념 상의 차이를 피하기 위해 없어졌습니다. 그것들은 “글로벌” 스케줄러 인스턴스를 리턴하지만 <code class="highlighter-rouge">test()</code>는 항상 <code class="highlighter-rouge">TestScheduler</code>의 새로운 인스턴스를 리턴합니다. 테스트가 필요한 개발자는 이제 코드에서 단순히 <code class="highlighter-rouge">new TestScheduler()</code>를 사용하면 됩니다.</p>

<p><code class="highlighter-rouge">io.reactivex.Scheduler</code> 추상 기본 클래스는 이제 <code class="highlighter-rouge">Worker</code>(자주 잊어버릴 수 있습니다.)를 생성하고 제거할 필요 없이 직접 태스크를 스케쥴링합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scheduler</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirect</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirect</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirectPeriodically</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="kt">long</span> <span class="n">initialDelay</span><span class="o">,</span> 
        <span class="kt">long</span> <span class="n">period</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">now</span><span class="o">(</span><span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="c1">// ... 나머지는 비슷합니다: 라이프사이클 메소드나, Worker의 생성이나...</span>
<span class="o">}</span></code></pre></figure>

<p>주된 목적은 일반적으로 한번에 끝날 수 있는 작업에 대한 <code class="highlighter-rouge">Worker</code>의 추적 오버헤드를 피하는 것입니다. 이 메소드는 <code class="highlighter-rouge">createWorker</code>를 적절하게 재사용하는 기본 구현을 가지고 있지만 필요하다면 더욱 효율적인 구현으로 오버라이드할 수 있습니다.</p>

<p>스케줄러 자신의 현재 시각을 반환하는 메소드 <code class="highlighter-rouge">now()</code> 는 이제 시간의 측정 단위를 나타내기 위해 <code class="highlighter-rouge">TimeUnit</code>을 받을 수 있게끔 바뀌었습니다.</p>

<h2 id="section-8">리액티브 세계로 들어가기</h2>

<p>RxJava 1.x의 설계 결함 중 하나는 <code class="highlighter-rouge">rx.Observable.create()</code> 메소드가 노출된 것입니다. 이는 리액티브 세계에 들어가기 위해 사용하는 일반적인 연산자가 아닙니다. 불행히도 많은 사람들이 그것을 제거하거나 이름을 바꿀 수 없다는 사실에 의존하고 있습니다.</p>

<p>2.x부터는 새로운 출발이므로, 우리는 그런 실수를 반복하지 않을 것입니다. 각 리액티브 기본 타입인 <code class="highlighter-rouge">Flowable</code>, <code class="highlighter-rouge">Observable</code>, <code class="highlighter-rouge">Single</code>, <code class="highlighter-rouge">Maybe</code>, <code class="highlighter-rouge">Completable</code>은 Backpressure(<code class="highlighter-rouge">Flowable</code>만 해당)와 취소에 대한 올바른 작업을 수행하는 안전한 <code class="highlighter-rouge">create</code> 오퍼레이터를 특징으로 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">create</span><span class="o">((</span><span class="n">FlowableEmitter</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">emitter</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onComplete</span><span class="o">();</span>
<span class="o">},</span> <span class="n">BackpressureStrategy</span><span class="o">.</span><span class="na">BUFFER</span><span class="o">);</span></code></pre></figure>

<p>실제로는 1.x의 <code class="highlighter-rouge">fromEmitter</code>(이전의 <code class="highlighter-rouge">fromAsync</code>)는 <code class="highlighter-rouge">Flowable.create</code>로 이름이 바뀌었습니다. 다른 기본 리액티브 타입들도 유사한 <code class="highlighter-rouge">create</code> 메소드를 가지고 있습니다. (Backpressure 전략을 제외한)</p>

<h2 id="section-9">리액티브 세계에서 떠나기</h2>

<p>각각의 소비자(<code class="highlighter-rouge">Subscriber</code>, <code class="highlighter-rouge">Observer</code>, <code class="highlighter-rouge">SingleObserver</code>, <code class="highlighter-rouge">MaybeObserver</code>, <code class="highlighter-rouge">CompletableObserver</code>)와 함수형 인터페이스에 기반을 둔 소비자(<code class="highlighter-rouge">subscribe(Consumer, Consumer, Action)</code>와 같은 것들)를 통해 기본 유형들을 구독하는 것과는 달리, 이전에는 1.x에선 별개로 있었던 <code class="highlighter-rouge">BlockingObservable</code>(와 비슷한 다른 클래스들)이 주요 리액티브 타입과 통합되었습니다. 이제 <code class="highlighter-rouge">blockingX</code> 연산을 직접 호출하여 몇가지 결과들을 직접 블로킹할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">).</span><span class="na">toList</span><span class="o">().</span><span class="na">blockingGet</span><span class="o">();</span> <span class="c1">// toList() returns Single</span>

<span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">100</span><span class="o">).</span><span class="na">blockingLast</span><span class="o">();</span></code></pre></figure>

<p>(그 이유는 성능과 동기식 Java 8 Streams와 비슷한 프로세서 라이브러리를 쓰는 것에 대한 용이함 때문입니다.)</p>

<p>또 다른 2.x에서 <code class="highlighter-rouge">rx.Subscriber</code>와 <code class="highlighter-rouge">org.reactivestreams.Subscriber</code>의 차이점은 여러분의 <code class="highlighter-rouge">Subscriber</code>와 <code class="highlighter-rouge">Observer</code>는 치명적인 예외를 발생하는 것을 허용하지 않는다는 점입니다.(<code class="highlighter-rouge">Exceptions.throwIfFatal()</code>을 보세요.) (Reactive-Streams 사양은 <code class="highlighter-rouge">onSubscribe</code>, <code class="highlighter-rouge">onNext</code>, <code class="highlighter-rouge">onError</code>가 null 값을 받으면 <code class="highlighter-rouge">NullPointerException</code>을 날릴 수 있지만 RxJava는 <code class="highlighter-rouge">null</code>을 허용하지 않습니다.) 이는 다음 코드는 더는 유효하지 않다는 것을 뜻합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">IllegalArgumentException</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span></code></pre></figure>

<p>같은 것들이 <code class="highlighter-rouge">Observer</code>, <code class="highlighter-rouge">SingleObserver</code>, <code class="highlighter-rouge">MaybeObserver</code>, <code class="highlighter-rouge">CompletableObserver</code>에도 적용되었습니다.</p>

<p>1.x를 타겟으로하는 많은 기존 코드가 그런 일을 하므로, 이러한 기준에 적합하지 않은 소비자를 처리하는 <code class="highlighter-rouge">safeSubscribe</code> 메소드가 도입되었습니다.</p>

<p>또는, <code class="highlighter-rouge">subscribe (Consumer, Consumer, Action)</code>(와 유사한) 메소드를 사용하여 다음을 던질 수 있는 콜백 혹은 람다식을 제공할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onNext</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onError</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onComplete</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onSubscribe</span>
<span class="o">);</span></code></pre></figure>

<h2 id="section-10">테스팅</h2>

<p>RxJava 2.x 테스트는 1.x에서와 같은 방식으로 작동합니다. <code class="highlighter-rouge">Flowable</code>은<code class="highlighter-rouge">io.reactivex.subscribers.TestSubscriber</code>로 테스트 할 수 있습니다. 반면에<code class="highlighter-rouge">Observable</code>, <code class="highlighter-rouge">Single</code>, <code class="highlighter-rouge">Maybe</code>, <code class="highlighter-rouge">Completable</code>은<code class="highlighter-rouge">io.reactivex.observers.TestObserver</code>로 테스트 할 수 있습니다.</p>

<h3 id="test-">test() “오퍼레이터”</h3>

<p>우리의 내부 테스트를 지원하기 위해, 모든 기본 리액티브 타입은 이제 <code class="highlighter-rouge">TestSubscriber</code> 또는<code class="highlighter-rouge">TestObserver</code>를 반환하는 <code class="highlighter-rouge">test()</code>메소드를 제공합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tso</span> <span class="o">=</span> <span class="n">Single</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tmo</span> <span class="o">=</span> <span class="n">Maybe</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tco</span> <span class="o">=</span> <span class="n">Completable</span><span class="o">.</span><span class="na">complete</span><span class="o">().</span><span class="na">test</span><span class="o">();</span></code></pre></figure>

<p>두 번째 편리함은 대부분의 <code class="highlighter-rouge">TestSubscriber</code>/<code class="highlighter-rouge">TestObserver</code> 메소드가 인스턴스 자체를 반환하여 다양한 <code class="highlighter-rouge">assertX</code> 메소드와 연결될 수 있다는 것입니다. 세 번째 편리함은 코드에서 <code class="highlighter-rouge">TestSubscriber</code> / <code class="highlighter-rouge">TestObserver</code> 인스턴스를 생성하거나 삽입하지 않고 소스를 자유롭게 테스트할 수 있다는 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
	<span class="o">.</span><span class="na">test</span><span class="o">()</span>
	<span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span></code></pre></figure>

<h4 id="section-11">주목할만한 새로운 단언문 메소드</h4>

<ul>
  <li><code class="highlighter-rouge">assertResult(T... items)</code>: 구독할 때 지정된 순서로 지정된 항목을 정확히 수신한 뒤 에러 없이 <code class="highlighter-rouge">onComplete</code> 되는 것을 단언합니다.</li>
  <li><code class="highlighter-rouge">assertFailure(Class clazz, T... items)</code>: 구독할 때 지정된 순서로 지정된 항목을 정확히 수신한 뒤, <code class="highlighter-rouge">clazz.isInstance()</code>를 만족하는 <code class="highlighter-rouge">Throwable</code> 에러를 수신하는걸 단언합니다.</li>
  <li><code class="highlighter-rouge">assertFailureAndMessage(Class clazz, String message, T... items)</code>: <code class="highlighter-rouge">assertFailure</code>와 비슷한 역할을 하며, <code class="highlighter-rouge">getMessage()</code>를 통해 특정 에러 메시지를 validation 하는 기능이 더해졌습니다.</li>
  <li><code class="highlighter-rouge">awaitDone(long time, TimeUnit unit)</code>은 블로킹 방식으로 터미널 이벤트를 기다리고, 타임아웃이 경과하면 시퀀스를 취소합니다.</li>
  <li><code class="highlighter-rouge">assertOf(Consumer&gt; consumer)</code>는 단언문을 자연스러운 체인에 구성합니다. (오퍼레이터 결합이 현재 아직 공개된 API가 아니기 때문에 결합 테스트를 위해 내부적으로 사용됩니다.)</li>
</ul>

<p><code class="highlighter-rouge">Flowable</code>을 <code class="highlighter-rouge">Observable</code>로 변경하면서 생기는 이점 중 하나는 <code class="highlighter-rouge">TestSubscriber</code>를 <code class="highlighter-rouge">TestObserver</code>로 암시적으로 변경했기 때문에, 테스트 코드를 전혀 변경할 필요가 없다는 것입니다.</p>

<h3 id="section-12">취소와 먼저 요청하기</h3>

<p><code class="highlighter-rouge">TestObserver</code>에 있는 <code class="highlighter-rouge">test()</code> 메소드는 <code class="highlighter-rouge">test(boolean cancel)</code>을 오버로드해, 구독하기도 전에 <code class="highlighter-rouge">TestSubscriber</code>/<code class="highlighter-rouge">TestObserver</code>를 취소하거나 정리합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PublishSubject</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="c1">// 아직 아무도 구독하지 않았음</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">hasSubscribers</span><span class="o">());</span>

<span class="n">pp</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="c1">// 여전히 아무도 구독하지 않았음</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">hasSubscribers</span><span class="o">());</span></code></pre></figure>

<p><code class="highlighter-rouge">TestSubscriber</code>는 <code class="highlighter-rouge">test(long initialRequest)</code>와 <code class="highlighter-rouge">test(long initialRequest, boolean cancel)</code> 오버로드로 처음 요청할 양을 지정하고, <code class="highlighter-rouge">TestSubscriber</code>도 즉시 취소해야하는지 여부를 지정합니다.  <code class="highlighter-rouge">initialRequest</code>가 주어지면 <code class="highlighter-rouge">TestSubscriber</code> 인스턴스는 <code class="highlighter-rouge">request()</code> 메소드에 접근하기 위해 캡쳐해야 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PublishProcessor</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">PublishProcessor</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="mi">0L</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="n">pp</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">pp</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertFailure</span><span class="o">(</span><span class="n">MissingBackpressureException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h3 id="section-13">비동기 소스를 테스팅하기</h3>

<p>비동기 소스가 주어지면 터미널 이벤트를 자연스럽게 차단할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">single</span><span class="o">())</span>
  <span class="o">.</span><span class="na">test</span><span class="o">()</span>
  <span class="o">.</span><span class="na">awaitDone</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
  <span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h3 id="mockito-testsubscriber">Mockito와 TestSubscriber</h3>

<p>Mockito를 사용하고, 1.x에서 모킹된 Observer를 쓰는 사람들은 <code class="highlighter-rouge">Subscriber.onSubscribe</code> 메소드를 모킹해서 초기 요청을 보내야 합니다. 그렇지 않으면 시퀀스가 멈추거나, 핫 소스와 함께 실패하게 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">mockSubscriber</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Subscriber</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="n">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="k">new</span> <span class="n">Answer</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">answer</span><span class="o">(</span><span class="n">InvocationOnMock</span> <span class="n">a</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="n">Subscription</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getArgumentAt</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">Subscription</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">w</span><span class="o">).</span><span class="na">onSubscribe</span><span class="o">((</span><span class="n">Subscription</span><span class="o">)</span><span class="n">any</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h2 id="section-14">오퍼레이터 변경 사항</h2>

<p>대부분의 오퍼레이터는 2.x에서 여전히 사용되고 있으며 거의 모든 오퍼레이터는 1.x에서와 비슷하게 동작합니다. 다음 하위 섹션에서는 각 기본 리액티브 타입과 1.x와 2.x에서의 차이점이 나와있습니다.</p>

<p>일반적으로 많은 오퍼레이터가 업스트림(또는 내부 소스)을 실행해야 하는 내부 버퍼 크기 또는 pre-fetch 양을 지정할 수 있게 되어 오버로드가 늘었습니다.</p>

<p>일부 연산자 오버로드는 <code class="highlighter-rouge">fromArray</code>, <code class="highlighter-rouge">fromIterable</code> 등과 같이 접미사를 포함해 이름이 바뀌었습니다. 그 이유는 라이브러리가 Java 8로 컴파일 될 때, javac가 함수형 인터페이스 타입을 명확하게 파악할 수 없기 때문입니다.</p>

<p>1.x에서 <code class="highlighter-rouge">@Beta</code>나 <code class="highlighter-rouge">@Experimental</code>였던 오퍼레이터들은 이제 표준이 되었습니다.</p>

<h3 id="x-observable-2x-flowable">1.x Observable에서 2.x Flowable로</h3>

<h4 id="section-15">팩토리 메소드:</h4>

<table>
  <thead>
    <tr>
      <th>1.x</th>
      <th>2.x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">amb</code></td>
      <td><code class="highlighter-rouge">amb(ObservableSource...)</code>  오버로드가 추가되고, 인자가 2-9개인 버전이 삭제되었습니다.</td>
    </tr>
    <tr>
      <td>RxRingBuffer.SIZE</td>
      <td><code class="highlighter-rouge">bufferSize()</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">combineLatest</code></td>
      <td>가변인자 오버로드가 추가되었습니다. <code class="highlighter-rouge">bufferSize</code> 인자에 대한 오버로드가 추가되었고, <code class="highlighter-rouge">combineLatest(List)</code>가 없어졌습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concat</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 5-9 소스에 대한 오버로드가 없어졌습니다, 대신 <code class="highlighter-rouge">concatArray</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">concatArray</code>와  <code class="highlighter-rouge">concatArrayDelayError</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">concatArrayEager</code>와 <code class="highlighter-rouge">concatArrayEagerDelayError</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatDelayError</code></td>
      <td>끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatEagerDelayError</code></td>
      <td>끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(SyncOnSubscribe)</code></td>
      <td><code class="highlighter-rouge">generate</code>로 바뀌었습니다. 인터페이스의 변경으로 한번에 구현할 수 있게 되었습니다. 이에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(AsnycOnSubscribe)</code></td>
      <td>변경 사항이 없습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(OnSubscribe)</code></td>
      <td>안전한 <code class="highlighter-rouge">create(FlowableOnSubscribe, BackpressureStrategy)</code>으로 목적이 바뀌었습니다. raw 형태의 지원은 <code class="highlighter-rouge">unsafeCreate()</code>를 이용합니다..</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">from</code></td>
      <td><code class="highlighter-rouge">fromArray</code>, <code class="highlighter-rouge">fromIterable</code>, <code class="highlighter-rouge">fromFuture</code>로 모호함을 없앴습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">fromPublisher</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">fromAsync</code></td>
      <td><code class="highlighter-rouge">create()</code>로 이름이 바뀌었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">intervalRange()</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">limit</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">take</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">merge</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">mergeDelayError</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sequenceEqual</code></td>
      <td><code class="highlighter-rouge">bufferSize</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchOnNext</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchOnNextDelayError</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">timer</code></td>
      <td>사용하지 않게 된 오버로드를 없앴습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">zip</code></td>
      <td><code class="highlighter-rouge">bufferSize</code>와  <code class="highlighter-rouge">delayErrors</code> 가능성에 대한 오버로드가 추가되었습니다. <code class="highlighter-rouge">zipArray</code>, <code class="highlighter-rouge">zipIterable</code>와의 모호함을 없앴습니다.</td>
    </tr>
  </tbody>
</table>

<h4 id="section-16">인스턴스 메소드:</h4>

<table>
  <thead>
    <tr>
      <th>1.x</th>
      <th>2.x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">all</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">any</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">asObservable</code></td>
      <td><code class="highlighter-rouge">hide()</code>로 바뀌었습니다. 이제 모든 아이덴티티를 숨깁니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">buffer</code></td>
      <td>커스텀 <code class="highlighter-rouge">Collection</code> 서플라이어에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">cache(int)</code></td>
      <td>사용되지 않으며, 삭제되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">collect</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">collect(U, Action2)</code></td>
      <td><code class="highlighter-rouge">collectInto</code>와의 모호함을 없애고 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMap</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapDelayError</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapEager</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapEagerDelayError</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">count</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">countLong</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">count</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">distinct</code></td>
      <td>커스텀 Collection 서플라이어에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">doOnCompleted</code></td>
      <td><code class="highlighter-rouge">doOnComplete</code>로 이름이 바뀌었습니다. <code class="highlighter-rouge">d</code>가 빠졌다는걸 유의하세요!</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">doOnUnsubscribe</code></td>
      <td><code class="highlighter-rouge">Flowable.doOnCancel</code>와 다른 타입에서는 <code class="highlighter-rouge">doOnDispose</code>로 바뀌었습니다. <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon">추가 정보</a></td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">onSubscribe</code>를 다루고, <code class="highlighter-rouge">request</code>와 <code class="highlighter-rouge">cancel</code>를 관찰할 수 있는 <code class="highlighter-rouge">doOnLifecycle</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int)</code></td>
      <td><strong>RC3</strong>부터는 소스가 인덱스보다 짧은 경우에 <code class="highlighter-rouge">NoSuchElementException</code>을 내지 않습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(Func1, int)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).elementAt(int)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAtOrDefault(int, T)</code></td>
      <td><code class="highlighter-rouge">elementAt(int, T)</code>로 이름이 바뀌었으며 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAtOrDefault(Func1, int, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).elementAt(int, T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first()</code></td>
      <td><strong>RC3</strong>부터 <code class="highlighter-rouge">firstElement</code>로 이름이 바뀌었으며 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).first()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstOrDefault(T)</code></td>
      <td><code class="highlighter-rouge">first(T)</code>로 바뀌었으며 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).first(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">flatMap</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>조건부로 소비를 중지하기 위한 <code class="highlighter-rouge">forEachWhile(Predicate, [Consumer, [Action]])</code>이 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">groupBy</code></td>
      <td><code class="highlighter-rouge">bufferSize</code>와 <code class="highlighter-rouge">delayError</code> 옵션에 대한 오버로드가 추가되었습니다. <em>커스텀 내부 맵 버전이 RC1에 포함되지 않았습니다.</em></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ignoreElements</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Completable</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">isEmpty</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last()</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">lastElement</code>로 이름이 바뀌었으며, <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).last()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastOrDefault(T)</code></td>
      <td><code class="highlighter-rouge">last(T)</code>로 이름이 바뀌었습니다. <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).last(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">nest</code></td>
      <td>없어졌습니다. 수동으로 <code class="highlighter-rouge">just</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">publish(Func1)</code></td>
      <td><code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(Func2)</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>가입자-개별(Subscriber-Individual) 방식으로 줄이는 <code class="highlighter-rouge">reduceWith(Callable, BiFunction)</code>가 추가되었습니다. <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">repeatUntil(BooleanSupplier)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">repeatWhen(Func1, Scheduler)</code></td>
      <td>오버로드가 없어졌습니다. 대신 <code class="highlighter-rouge">subscribeOn(Scheduler).repeatWhen(Function)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">retry</code></td>
      <td><code class="highlighter-rouge">retry(Predicate)</code>, <code class="highlighter-rouge">retry(int, Predicate)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">retryUntil(BooleanSupplier)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">retryWhen(Func1, Scheduler)</code></td>
      <td>오버로드가 없어졌습니다. 대신 <code class="highlighter-rouge">subscribeOn(Scheduler).retryWhen(Function)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>가입자-개별(Subscriber-Individual) 방식으로 스캔하는 <code class="highlighter-rouge">sampleWith(Callable, BiFunction)</code>이 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single()</code></td>
      <td><strong>RC3</strong>부터 <code class="highlighter-rouge">singleElement</code>로 이름이 바뀌었으며 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).single()</code>을 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleOrDefault(T)</code></td>
      <td><code class="highlighter-rouge">single(T)</code>로 이름이 바뀌었으며, <strong>RC3</strong>부터 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. <code class="highlighter-rouge">filter(predicate).single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">skipLast</code></td>
      <td><code class="highlighter-rouge">bufferSize</code>, <code class="highlighter-rouge">delayError</code> 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">startWith</code></td>
      <td>인자가 2-9개인 버전이 삭제되었습니다. 대신  <code class="highlighter-rouge">startWithArray</code>을 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>added <code class="highlighter-rouge">startWithArray</code> to disambiguate</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>added <code class="highlighter-rouge">subscribeWith</code> that returns its input after subscription</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchMap</code></td>
      <td><code class="highlighter-rouge">prefetch</code> 인자에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchMapDelayError</code></td>
      <td><code class="highlighter-rouge">prefetch</code> 인자에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">takeLastBuffer</code></td>
      <td>없어졌습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">test()</code>가 추가되었습니다. (<code class="highlighter-rouge">TestSubscriber</code>를 반환하여 이를 구독할 수 있습니다.) 자연스러운 테스트를 위한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">timeout(Func0, ...)</code></td>
      <td><code class="highlighter-rouge">timeout(Publisher, ...)</code>로 서명이 바뀌었습니다. 가능할 경우  <code class="highlighter-rouge">defer(Callable&gt;)</code>를 써주세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toBlocking().y</code></td>
      <td><code class="highlighter-rouge">toFuture</code>를 제외하고는 <code class="highlighter-rouge">blockingY()</code> 오퍼레이터로 인라인됩니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toCompletable</code></td>
      <td><strong>RC3</strong>에서 없어졌습니다. <code class="highlighter-rouge">ignoreElements</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toList</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMap</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMultimap</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">toFuture</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td><code class="highlighter-rouge">toObservable</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSingle</code></td>
      <td><strong>RC3</strong>에서 없어졌습니다. <code class="highlighter-rouge">single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSortedList</code></td>
      <td><strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">withLatestFrom</code></td>
      <td>5-9 소스 오버로드가 없어졌습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">zipWith</code></td>
      <td><code class="highlighter-rouge">prefetch</code>와  <code class="highlighter-rouge">delayErrors</code> 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
  </tbody>
</table>

<h4 id="section-17">달라진 반환 타입</h4>

<p>정확히 하나의 값이나 에러를 생성한 오퍼레이터는 2.x에서는 <code class="highlighter-rouge">Single</code>을 반환합니다. (빈 소스가 허용되면 <code class="highlighter-rouge">Maybe</code>도 가능합니다).</p>

<p><em>(Remark: 이는 RC2와 RC3에서 혼합된 타입의 시퀀스로 프로그래밍하는게 어떤지, 또 거기에 너무 많은 toObservable/toFlowable 변환이 너무 많지 않은지를 보기 위한 “실험적 기능”입니다.)</em></p>

<table>
  <thead>
    <tr>
      <th>오퍼레이터</th>
      <th>예전 반환 타입</th>
      <th>새 반환 타입</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">all(Predicate)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>모든 요소가 인자와 일치하면 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">any(Predicate)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>특정 요소가 인자와 일치하면 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">count()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>시퀀스에 있는 항목의 갯수를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>주어진 인덱스의 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int, T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>주어진 인덱스의 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>첫 항목을 방출하거나 <code class="highlighter-rouge">NoSuchElementException</code>를 냅니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>첫 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ignoreElements()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Completable</code></td>
      <td>터미널 이벤트를 제외한 모든 걸 무시합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">isEmpty()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>소스가 비어있을 때 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>마지막 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>맨 마지막 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>줄어든 값을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(Callable, BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>초깃값 혹은 줄어든 값을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduceWith(U, BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>초깃값 혹은 줄어든 값을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>유일한 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>유일한 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toList()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td><code class="highlighter-rouge">List</code>로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMap()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td><code class="highlighter-rouge">Map</code>으로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMultimap()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td><code class="highlighter-rouge">Map</code>과 콜렉션으로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSortedList()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td><code class="highlighter-rouge">List</code>로 항목을 모으고 정렬합니다.</td>
    </tr>
  </tbody>
</table>

<h3 id="section-18">삭제된 사항</h3>

<p>2.0의 최종 API를 최대한 깨끗하게 만들기 위해, 우리는 릴리즈 후보를 거치면서 메소드와 일부 컴포넌트를 사용되지 않도록 만들지 않고 바로 삭제했습니다.</p>

<table>
  <thead>
    <tr>
      <th>삭제된 버전</th>
      <th>컴포넌트</th>
      <th>대안</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toCompletable()</code></td>
      <td><code class="highlighter-rouge">Flowable.ignoreElements()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toSingle()</code></td>
      <td><code class="highlighter-rouge">Flowable.single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toMaybe()</code></td>
      <td><code class="highlighter-rouge">Flowable.singleElement()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toCompletable()</code></td>
      <td><code class="highlighter-rouge">Observable.ignoreElements()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toSingle()</code></td>
      <td><code class="highlighter-rouge">Observable.single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toMaybe()</code></td>
      <td><code class="highlighter-rouge">Observable.singleElement()</code>를 쓰세요.</td>
    </tr>
  </tbody>
</table>

<h2 id="section-19">잡다한 변경사항</h2>

<h3 id="dooncancel--doondispose--unsubscribeon">doOnCancel / doOnDispose / unsubscribeOn</h3>

<p>1.x에서는 <code class="highlighter-rouge">SafeSubscriber</code>가 자체적으로 <code class="highlighter-rouge">unsubscribe</code>를 호출했기 때문에 <code class="highlighter-rouge">doOnUnsubscribe</code>는 터미널 이벤트에서 항상 실행되었습니다. 이것은 실질적으로 불필요한 일이며, Reactive-Streams 사양에서는 터미널 이벤트가 <code class="highlighter-rouge">Subscriber</code>에게 도착하면 업스트림 <code class="highlighter-rouge">Subscription</code>이 취소된 것으로 간주하여야 하므로<code class="highlighter-rouge">cancel()</code>을 호출하는 것은 아무 작업도 수행하지 않아야한다고 명시합니다.</p>

<p>같은 이유로 <code class="highlighter-rouge">unsubscribeOn</code>는 일반적인 종료 경로에서 호출되지 않고 체인에서 실제 <code class="highlighter-rouge">cancel</code>(또는 <code class="highlighter-rouge">dispose</code>)  호출이 있을 때만 호출됩니다.</p>

<p>따라서 다음 시퀀스는 <code class="highlighter-rouge">doOnCancel</code>을 호출하지 않을 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">doOnCancel</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cancelled!"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span></code></pre></figure>

<p>그러나 다음 시퀀스는 <code class="highlighter-rouge">take</code> 오퍼레이터가 <code class="highlighter-rouge">onNext</code> 이벤트가 전달된 후에 취소되기 때문에 <code class="highlighter-rouge">doOnCancel</code>이 호출됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">doOnCancel</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cancelled!"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span></code></pre></figure>

<p>만약 일반적인 터미네이션 과정이나 종료 과정에서 모두 정리를 해야할 때는, 대신 <code class="highlighter-rouge">using</code> 오퍼레이터를 쓰는걸 고려해보세요.</p>

<h1 id="section-20">후기</h1>

<p>주관적인 생각이지만 영어 번역은 확실히 일본어 번역보다 더 어려웠던 것 같습니다. 특히 글의 분량도 많았고, 어떻게 하면 이 표현을 자연스럽게 우리말로 쓸 수 있을까에 대한 고민도 꽤 했지만 그럼에도 많이 부족한 것 같습니다. 이 글을 통해 RxJava 2가 어떤 점들이 바뀌었는지 아는데 도움이 되면 좋겠습니다. 오타나 번역에 대한 지적이라던가 댓글은 언제나 환영합니다. 감사합니다. :D</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>rxjava-2-x-무엇이-달라졌을까</wp:post_id>
            <wp:post_date>2017-01-25 12:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Redux의 개념을 RxJS와 TypeScript로 이해하기 Ver. 2</title>
            <link>http://realignist.me/code/2017/01/18/redux-with-typescript-rxjs.html</link>
            <pubDate>Wed, 18 Jan 2017 12:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2017/01/18/redux-with-typescript-rxjs.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h3 id="section">글에 앞서,</h3>

<p>이 글은 @ovrmrw님의 <a href="http://qiita.com/ovrmrw/items/8cca6f40d5f78909a3dc">글</a>을 한국어로 번역한 글입니다. 이미 꽤 인기를 얻어서 최신 버전까지 나온 글로, 제가 번역한 것은 2번째 버전입니다. 좋은 글을 번역할 수 있도록 흔쾌히 허락해주신 ovrmrw님께 다시 한번 감사의 말씀을 드립니다. 그리고 번역하다가 헷갈려할 때 도와주신 최종찬 형(@disjukr), 이재호님(@sairion)께도 감사하다는 말씀 드립니다. :D</p>

<p><a href="http://qiita.com/advent-calendar/2016/redux">Redux Advent Calendar 2016</a> 15일차입니다. 치키 씨입니다.</p>

<h2 id="section-1">서론과 반성</h2>

<p>이 글은 필자가 Qiita에 투고한 글 중 제일 스톡이 많이 된 글인 <a href="http://qiita.com/ovrmrw/items/89c79fae4a2acd8159fc">초심자를 위한 Redux의 개념을 RxJS와 TypeScript로 이해하기</a>를 다시 쓴 글입니다. (역주: Qiita에서는 스톡이라는 기능이 있어, 좋아하는 글을 담아두고 볼 수 있도록 제공하고 있습니다.)</p>

<p>지금 다시 되돌아보면, 지난 글에는 몇가지 문제점이 있었습니다.</p>

<ol>
  <li>State와 Reducer에 Promise를 넣는건 좋지 못했던 것 같습니다.</li>
  <li>Action의 dispatch 순서를 무시하고, 비동기 처리가 끝난 순서대로 처리가 흐르는 구조로 되어있었다.</li>
</ol>

<p>1번에 관해서는 처음에는 문제가 없다고 생각했었지만, 점점 시간이 흘러 그 생각은 젊은 치기였던 것 같다고 생각하게 되었습니다. 2번은 요구사항에 따라선 그것대로 괜찮다고 생각되지만, 그래도 기본적으로 dispatch 순서대로 처리하는 것이 더 올바른 동작이라고 생각하게 되었습니다.</p>

<p>“RxJS로 Redux를 쓰자”라는 테마는 이번에 글을 다시 쓰면서 이제서야 본질에 접근할 수 있었다고 생각합니다.</p>

<h2 id="section-2">여기서부터 본편</h2>

<p>GitHub 리포지터리는 여기에 있습니다. <a href="https://github.com/ovrmrw/understanding-redux-with-rxjs-2">ovrmrw/understanding-redux-with-rxjs-2</a></p>

<p><code class="highlighter-rouge">git clone</code>한 뒤, <code class="highlighter-rouge">npm install</code>해서 <code class="highlighter-rouge">npm start</code>를 통해 실행해볼 수 있습니다.</p>

<p>(주의사항: React에 관한 이야기는 일절 나오지 않습니다.)</p>

<h2 id="redux">Redux는?</h2>

<p><a href="http://redux.js.org/">Redux 공식 홈페이지</a></p>

<p>전체 애플리케이션의 상태(State)를 하나의 JSON 트리 구조로 가지게 되어, Action이 발생할 때마다 트리를 전체적으로 업데이트해서 전달한다는 개념. 필자는 처음에 Flux나 Redux에 대해서 잘 몰랐지만, 다양한 것들을 참고하면서 직접 쓰면서 겨우 이해할 수 있었습니다.</p>

<p>Middleware라는 개념은 잘 몰랐었고, 지금도 잘 모릅니다. 로거같은 편리한 것도 있습니다만, 원래 Redux를 그대로 사용해본 적이 없습니다. 치명적인 문제로 Redux는 Reducer의 안에서 비동기 처리를 할 수 없기 때문에, 그것을 처리하기 위한 미들웨어 전쟁이 일어나고 있는 것이 있습니다.</p>

<h2 id="redux-">Redux를 이해하기</h2>

<p>“그러나 Angular 파인 우리들은 원래부터 RxJS가 있었다! 그래서 RxJS를 풀로 써서 Redux같은걸 만들어서 쓰자!”같은 말도 나왔습니다. 원래 글은 여기에 있습니다. <a href="https://vsavkin.com/managing-state-in-angular-2-applications-caf78d123d02#.7zwj38sy1">“Tackling State” by Victor Savkin</a> (Victor Savkin은 Angular 팀의 핵심 멤버입니다. 그의 블로그는 구독할만한 가치가 있다고 생각합니다.)</p>

<p>에서, 당시 RxJS에 대한 지식이 얕았었다. (JS에 대한 이해도 부족했었다.) 그래서 나는 이것을 이해하는데 매우 오랜 시간이 걸렸습니다. Savkin류 Redux를 나름대로 몇번이나 고쳐쓰는 것을 반복해서, 마침내 지금까지 오게 되었습니다. 사실은 하나의 간단한 짧은 코드로 모든 것을 설명할 수 있다는 것을 알 수 있었습니다.</p>

<p><a href="https://qiita-image-store.s3.amazonaws.com/0/74793/6c582eff-0424-3f65-c421-8dcbc931db4d.jpeg"><img src="https://qiita-image-store.s3.amazonaws.com/0/74793/6c582eff-0424-3f65-c421-8dcbc931db4d.jpeg" alt="687474703a2f2f692e696d6775722e636f6d2f4149696d5138432e6a7067.jpeg" /></a></p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="k">import</span> <span class="s1">'core-js'</span><span class="p">;</span>
<span class="k">import</span> <span class="s1">'zone.js/dist/zone-node'</span><span class="p">;</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">lodash</span> <span class="k">from</span> <span class="s1">'lodash'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Observable</span><span class="p">,</span> <span class="nx">Subject</span><span class="p">,</span> <span class="nx">BehaviorSubject</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'rxjs'</span><span class="p">;</span>
<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">Zone</span><span class="err">:</span> <span class="kr">any</span><span class="p">;</span>


<span class="c1">///////////////////////////////// Action</span>
<span class="kr">class</span> <span class="nx">IncrementAction</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">num</span><span class="err">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">OtherAction</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Action</span> <span class="o">=</span> <span class="nx">IncrementAction</span> <span class="o">|</span> <span class="nx">OtherAction</span><span class="p">;</span>


<span class="c1">///////////////////////////////// State</span>
<span class="kr">interface</span> <span class="nx">IncrementState</span> <span class="p">{</span>
  <span class="nl">counter</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">OtherState</span> <span class="p">{</span>
  <span class="nl">foo</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">bar</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">AppState</span> <span class="p">{</span>
  <span class="nl">increment</span><span class="p">:</span> <span class="nx">IncrementState</span><span class="p">;</span>
  <span class="nx">other</span><span class="p">?:</span> <span class="nx">OtherState</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">const</span> <span class="nx">initialState</span><span class="err">:</span> <span class="nx">AppState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">increment</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">counter</span><span class="p">:</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="c1">///////////////////////////////// Redux</span>
<span class="nx">Zone</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">fork</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="s1">'myZone'</span> <span class="p">}).</span><span class="nx">runGuarded</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'zone name:'</span><span class="p">,</span> <span class="nx">Zone</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="cm">/* OUTPUT&gt; zone name: myZone */</span>

  <span class="kd">const</span> <span class="nx">dispatcher$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Subject</span><span class="o">&lt;</span><span class="nx">Action</span> <span class="o">|</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span> <span class="o">|</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;&gt;</span><span class="p">();</span> <span class="c1">// Dispatcher</span>
  <span class="kd">const</span> <span class="nx">provider$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BehaviorSubject</span><span class="o">&lt;</span><span class="nx">AppState</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span> <span class="c1">// Provider</span>


  <span class="kd">const</span> <span class="nx">dispatcherQueue$</span> <span class="o">=</span> <span class="c1">// Queue</span>
    <span class="nx">dispatcher$</span>
      <span class="p">.</span><span class="nx">concatMap</span><span class="p">(</span><span class="nx">action</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// async actions are resolved here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="k">instanceof</span> <span class="nb">Promise</span> <span class="o">||</span> <span class="nx">action</span> <span class="k">instanceof</span> <span class="nx">Observable</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nx">share</span><span class="p">();</span>


  <span class="nx">Observable</span> <span class="c1">// ReducerContainer</span>
    <span class="p">.</span><span class="nx">zip</span><span class="p">(...[</span>
      <span class="nx">dispatcherQueue$</span><span class="p">.</span><span class="nx">scan</span><span class="p">((</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// Reducer</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="k">instanceof</span> <span class="nx">IncrementAction</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="na">counter</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span> <span class="o">+</span> <span class="nx">action</span><span class="p">.</span><span class="nx">num</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">},</span> <span class="nx">initialState</span><span class="p">.</span><span class="nx">increment</span><span class="p">),</span>

      <span class="p">(</span><span class="nx">increment</span><span class="p">):</span> <span class="nx">AppState</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// projection</span>
        <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="o">&lt;</span><span class="p">{},</span> <span class="nx">AppState</span><span class="p">,</span> <span class="p">{}</span><span class="o">&gt;</span><span class="p">({},</span> <span class="nx">initialState</span><span class="p">,</span> <span class="p">{</span> <span class="nx">increment</span> <span class="p">});</span> <span class="c1">// always create new state object!</span>
      <span class="p">}</span>
    <span class="p">])</span>
    <span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">newState</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">provider$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">newState</span><span class="p">);</span>
    <span class="p">});</span>


  <span class="nx">provider$</span>
    <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">appState</span> <span class="o">=&gt;</span> <span class="nx">appState</span><span class="p">.</span><span class="nx">increment</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">distinctUntilChanged</span><span class="p">((</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lodash</span><span class="p">.</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">))</span> <span class="c1">// restrict same values to pass through.</span>
    <span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'counter:'</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span><span class="p">);</span> <span class="cm">/* (First time) OUTPUT&gt; counter: 0 */</span>
    <span class="p">});</span>


  <span class="cm">/* 
    OUTPUT: 0 -&gt; 1 -&gt; 2 -&gt; 4 -&gt; 3 
    outputs are not determined by async resolution order but by action dispatched order.
  */</span>
  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">promiseAction</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">100</span><span class="p">));</span>  <span class="cm">/* OUTPUT&gt; counter: 1 */</span>
  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">promiseAction</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">50</span><span class="p">));</span>  <span class="cm">/* OUTPUT&gt; counter: 2 */</span>
  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">observableAction</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">100</span><span class="p">));</span>  <span class="cm">/* OUTPUT&gt; (restricted) */</span>
  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">observableAction</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">50</span><span class="p">));</span>  <span class="cm">/* OUTPUT&gt; counter: 4 */</span>
  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span> <span class="cm">/* OUTPUT&gt; counter: 3 */</span>
<span class="p">});</span>



<span class="c1">///////////////////////////////// Helper</span>
<span class="kd">function</span> <span class="nx">promiseAction</span><span class="p">(</span><span class="na">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">,</span> <span class="na">timeout</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">action</span><span class="p">),</span> <span class="nx">timeout</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">observableAction</span><span class="p">(</span><span class="na">action</span><span class="p">:</span> <span class="nx">Action</span><span class="p">,</span> <span class="na">timeout</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="nx">Observable</span><span class="o">&lt;</span><span class="nx">Action</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="nx">action</span><span class="p">).</span><span class="nx">delay</span><span class="p">(</span><span class="nx">timeout</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>어떤가요, 초간단하죠?</p>

<p>덧붙여서 이번 코드는 <a href="https://github.com/angular/zone.js/">zone.js</a>을 사용할 필요는 없습니다만, 추후 Angular에서 돌아갈 코드는 가능한 Node.js 환경에서도 Zone을 이용하여 쓰는 것이 좋습니다. 그렇지 않으면 Node.js 환경에서 동작하는 코드가 Angular에서 동작하지 않는다던가 하는 일이 발생할 수 있기 때문입니다. (전 그저 Angular를 좋아할 뿐입니다.)</p>

<h2 id="subject">요점 1. Subject</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">  <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">promiseAction</span><span class="p">(</span><span class="k">new</span> <span class="nx">IncrementAction</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">100</span><span class="p">));</span></code></pre></figure>

<p>이것이 Action의 시작점입니다. 덧붙여서 <code class="highlighter-rouge">dispatcher$</code>는 <code class="highlighter-rouge">Subject</code>의 인스턴스입니다. 이 다음에 스트림이 어디로 흐를까요? 정답은 <code class="highlighter-rouge">dispatcherQueue$</code>입니다.</p>

<h2 id="concatmap">요점 2. concatMap</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">  <span class="kd">const</span> <span class="nx">dispatcherQueue$</span> <span class="o">=</span> <span class="c1">// Queue</span>
    <span class="nx">dispatcher$</span>
      <span class="p">.</span><span class="nx">concatMap</span><span class="p">(</span><span class="nx">action</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// async actions are resolved here.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="k">instanceof</span> <span class="nb">Promise</span> <span class="o">||</span> <span class="nx">action</span> <span class="k">instanceof</span> <span class="nx">Observable</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">of</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">})</span>
      <span class="p">.</span><span class="nx">share</span><span class="p">();</span></code></pre></figure>

<p><code class="highlighter-rouge">dispatcher$</code>로 부터 흘러들어온 Action을 <code class="highlighter-rouge">concatMap</code> 오퍼레이터로 받고 있습니다. 무엇을 하고 있냐면…</p>

<ul>
  <li>Promise 혹은 Observable, 즉 비동기라면 <code class="highlighter-rouge">Obervable.from()</code>로 비동기를 해결해서 돌려줍니다.</li>
  <li>그 외, 동기식이라면 <code class="highlighter-rouge">Observable.of()</code>로 단순히 Observable로 변환해줍니다.</li>
</ul>

<p>이것을 통해 <code class="highlighter-rouge">Observable | Observable&gt;</code>이었던 Action의 타입은 <code class="highlighter-rouge">Observable</code>로 통일됩니다.</p>

<p>게다가 <code class="highlighter-rouge">concatMap</code>의 효과에 의해 Action의 dispatch 순서를 준수합니다. 멋지네요. 이 Reducer의 앞에서 비동기를 해결하자는 어프로치는 redux-observable에서도 통하는 부분이 있습니다.</p>

<p><a href="http://reactivex.io/documentation/operators/images/concatMap.png"><img src="http://reactivex.io/documentation/operators/images/concatMap.png" alt="img" /></a></p>

<h2 id="behaviorsubject">요점 3. BehaviorSubject</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kd">const</span> <span class="nx">provider$</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BehaviorSubject</span><span class="o">&lt;</span><span class="nx">AppState</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">initialState</span><span class="p">);</span></code></pre></figure>

<p>여기에서는 <code class="highlighter-rouge">Subject</code>로서가 아니라 <code class="highlighter-rouge">BehaviorSubject</code>인게 의미가 있습니다. 만약 이를 Subject로 바꾼다면 처음 “counter: 0”이 출력되지 않습니다. 초기 값이 바로 전달되는 모습은 아래 마블 다이어그램에서 보면 알기 쉬울 것 같습니다.</p>

<p><a href="http://reactivex.io/documentation/subject.html">Subject의 문서</a></p>

<p><a href="https://qiita-image-store.s3.amazonaws.com/0/74793/ddbaa374-6810-129b-5ba1-d1162bd6902d.png"><img src="https://qiita-image-store.s3.amazonaws.com/0/74793/ddbaa374-6810-129b-5ba1-d1162bd6902d.png" alt="S.BehaviorSubject.png" /></a></p>

<h2 id="scan">요점 4. scan</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">      <span class="nx">dispatcherQueue$</span><span class="p">.</span><span class="nx">scan</span><span class="p">((</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// Reducer</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="k">instanceof</span> <span class="nx">IncrementAction</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">{</span> <span class="na">counter</span><span class="p">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">counter</span> <span class="o">+</span> <span class="nx">action</span><span class="p">.</span><span class="nx">num</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">state</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">},</span> <span class="nx">initialState</span><span class="p">.</span><span class="nx">increment</span><span class="p">)</span></code></pre></figure>

<p>이 부분이 바로 Reducer입니다. <code class="highlighter-rouge">scan</code> 오퍼레이터는 Store(Reducer)를 구축하게 됩니다. 이것은 시간과 만나는 reduce라고 이해하면 그걸로 충분할거라 생각합니다. 이 <code class="highlighter-rouge">scan</code>과 아래의 <code class="highlighter-rouge">zip</code>을 제대로 이해할 수 있는가가 이 글을 이해했는가를 결정합니다.</p>

<p><a href="http://rxmarbles.com/#scan">scan의 마블 다이어그램</a></p>

<p><code class="highlighter-rouge">dispatcher$.scan()</code> 대신, <code class="highlighter-rouge">dispatcherQueue$.scan()</code>인 것이 중요합니다.</p>

<h2 id="zip-projection">요점 5. zip, projection</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">      <span class="p">(</span><span class="nx">increment</span><span class="p">)</span><span class="err">:</span> <span class="nx">AppState</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// projection</span>
        <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="o">&lt;</span><span class="p">{},</span> <span class="nx">AppState</span><span class="p">,</span> <span class="p">{}</span><span class="o">&gt;</span><span class="p">({},</span> <span class="nx">initialState</span><span class="p">,</span> <span class="p">{</span> <span class="nx">increment</span> <span class="p">});</span>
      <span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">zip</code> 오퍼레이터의 마지막 인자로 projection이라고 불리는 함수를 넣어 반환 값을 갖추고 있습니다. 참고로 <code class="highlighter-rouge">zip</code> 안이 여러 개 있을 때에는 다음과 같이 씁니다.</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">    <span class="p">.</span><span class="nx">zip</span><span class="o">&lt;</span><span class="nx">AppState</span><span class="o">&gt;</span><span class="p">(...[</span>
      <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="cm">/* 생략 */</span><span class="p">),</span> <span class="c1">// state1</span>
      <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="cm">/* 생략 */</span><span class="p">),</span> <span class="c1">// state2</span>
      <span class="nx">dispatcher$</span><span class="p">.</span><span class="nx">scan</span><span class="p">(</span><span class="cm">/* 생략 */</span><span class="p">),</span> <span class="c1">// state3</span>

      <span class="p">(</span><span class="nx">state1</span><span class="p">,</span> <span class="nx">state2</span><span class="p">,</span> <span class="nx">state3</span><span class="p">)</span><span class="err">:</span> <span class="nx">AppState</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// projection</span>
        <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="o">&lt;</span><span class="p">{},</span> <span class="nx">AppState</span><span class="p">,</span> <span class="p">{}</span><span class="o">&gt;</span><span class="p">({},</span> <span class="nx">initialState</span><span class="p">,</span> <span class="p">{</span> <span class="nx">state1</span><span class="p">,</span> <span class="nx">state2</span><span class="p">,</span> <span class="nx">state3</span> <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">])</span></code></pre></figure>

<p><a href="http://rxmarbles.com/#zip">zip의 마블 다이어그램</a>
<code class="highlighter-rouge">zip</code>과 비슷한 <code class="highlighter-rouge">combineLatest</code>라는 오퍼레이터가 있습니다만 <code class="highlighter-rouge">zip</code>은 내포하는 모든 Observable의 next를 기다리는 반면, <code class="highlighter-rouge">combineLatest</code>는 한 Observable이 next할 때마다 각각의 Observable의 최신 값을 넘겨줍니다.</p>

<p>이와 같은 이유로, Redux의 개념에는 <code class="highlighter-rouge">zip</code>이 적합하다 할 수 있습니다.
<a href="http://rxmarbles.com/#combineLatest">combineLatest의 마블 다이어그램</a></p>

<h2 id="distinctuntilchanged">요점 6. distinctUntilChanged</h2>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript">    <span class="p">.</span><span class="nx">distinctUntilChanged</span><span class="p">((</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lodash</span><span class="p">.</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">))</span></code></pre></figure>

<p><code class="highlighter-rouge">distinctUntilChanged</code>오퍼레이터는 통과하는 스트림이 같은 값일 경우에는 없애주는 역할을 합니다. 하지만 이번 코드는 위의 Projection의 쪽에서,</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="o">&lt;</span><span class="p">{},</span> <span class="nx">AppState</span><span class="p">,</span> <span class="p">{}</span><span class="o">&gt;</span><span class="p">({},</span> <span class="nx">initialState</span><span class="p">,</span> <span class="p">{</span> <span class="nx">increment</span> <span class="p">});</span></code></pre></figure>

<p>이렇게 하고 있기 때문에, 단순히 <code class="highlighter-rouge">.distinctUntilChanged()</code>라고 써버리면 흘러온 데이터가 <code class="highlighter-rouge"><span class="p">{</span><span class="err">counter:</span><span class="w"> </span><span class="err">2</span><span class="p">}</span></code>→<code class="highlighter-rouge"><span class="p">{</span><span class="err">counter:</span><span class="w"> </span><span class="err">2</span><span class="p">}</span></code>와 같이 같은 값이 계속 오더라도 모두 통과해버립니다. 이것은 객체의 내용을 보지 않기 때문입니다.</p>

<p>객체의 내용을 확인하기 위해 소위 deepEqual 비교를 해야하기 때문에, comparer라고 불리는 함수를 아래와 같이 작성합니다.</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="p">(</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">lodash</span><span class="p">.</span><span class="nx">isEqual</span><span class="p">(</span><span class="nx">oldValue</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span></code></pre></figure>

<p><a href="http://reactivex.io/documentation/operators/distinct.html">distinctUntilChanged의 문서</a>
<a href="https://lodash.com/docs/#isEqual">lodash.isEqual의 문서</a></p>

<h2 id="angular--">Angular에서 쓰기 위해선</h2>

<p>Dispatcher를 DI 컨테이너에 넣어 Component에 주입하면 Component부터 Action을 날릴 수 있습니다. 또한 Provider 스트림의 마지막 부분을 어떻게 해서 Component에 주입하면 Component에서 갱신된 State를 얻을 수 있습니다.</p>

<p>덧붙여서 <a href="http://qiita.com/ovrmrw/items/27d06475f405fd4ca9b4">Firebase-as-a-Store “RxJS로 만드는 Firebase 백엔드의 Redux”</a>에서 소개하고 있는 Angular 애플리케이션은 이 개념을 고스란히 이용해 구축했습니다.</p>

<h2 id="section-3">정리하기</h2>

<p>요점은 여러 가지가 있지만 가장 중요한 것은 Reducer를 구성하는 <code class="highlighter-rouge">scan</code>, <code class="highlighter-rouge">zip</code> 오퍼레이터 부분입니다. Reducer를 늘리고 싶다면 <code class="highlighter-rouge">zip</code> 오퍼레이터에 점점 <code class="highlighter-rouge">dispatcherQueue$.scan</code>을 추가해가면 됩니다. 해야할 일은 그것 뿐입니다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>redux의-개념을-rxjs와-typescript로-이해하기-ver-2</wp:post_id>
            <wp:post_date>2017-01-18 12:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Vue.js를 쓸 때의 모범 사례에 대해서 생각해보다.</title>
            <link>http://realignist.me/code/2017/01/17/vue-js-best-practice.html</link>
            <pubDate>Tue, 17 Jan 2017 12:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2017/01/17/vue-js-best-practice.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h3 id="section">글에 앞서,</h3>

<p>이 글은 Qiita에 올라온 @EdwardKenFox님의 <a href="http://qiita.com/edwardkenfox/items/6f4aa591485d2a270841">글</a>을 한국어로 번역한 글입니다. 개인적으로 Vue.js에 관심이 있어서 찾아보면서 좋은 글을 발견해서 번역해봤습니다. 혹시 번역에 이상하거나 모르는 부분이 있다면 댓글로 남겨주시면 감사하겠습니다. 흔쾌히 번역을 허락해주신 EdwardKenFox님께도 감사하다는 말씀 드립니다.</p>

<p>Vue.js는 공식 문서가 매우 충실하고, 또 포럼에서의 토론이나 의사 소통 또한 매우 활발합니다. 개발 중에 무언가 문제가 발생했을 때에는 문서 혹은 포럼에 올라온 정보를 참고하면 많은 문제들을 해결할 수 있다고 해도 무방합니다. 하지만 실제 애플리케이션을 개발할 때에는 그러한 정보만으로 해결이 어려운 구체적인 문제들이나, 원래 어떻게 개발해야 좋을지 모르는 일이 생기는 경우도 많이 있습니다.</p>

<p>필자 자신이 Vue.js를 이용해서 프론트엔드 개발을 해온 경험과 더불어, Vue.js의 공식 문서와 샘플 프로젝트, 그리고 Vue.js의 플러그인 등의 소스를 읽고 축적한 노하우들을 문서로 정리했습니다.</p>

<p>“모범 사례”라고 이름을 붙이고는 있지만, 필자의 취향과 개발 경험에 의존하는 부분이 크겠죠. 본 자료를 보다 의미있게 만들기 위해 Vue.js를 이용해서 개발을 할 때의 노하우와 사례를 가지고 계신 분들은 꼭 댓글이나 편집 요청(역주: Qiita에는 편집 요청을 통해 다른 사용자가 글에 수정 요청을 할 수 있습니다.)을 통해 가르쳐주세요!</p>

<h2 id="section-1">버전</h2>

<p>당연한 이야기이지만, 새로 개발을 시작하는 프로젝트라면 Vue.js의 최신 버전을 쓴다고 해서 문제가 될 것이 없습니다. 2016년 12월 18일 기준으로는 <a href="https://github.com/vuejs/vue/tree/v2.1.6">v2.1.6</a>이 최신 버전입니다.</p>

<p>또한 1.x 버전을 이용하고 있는 프로젝트는 2.x로 업그레이드하는 것을 추천합니다. 완전히 새로워진 부분도 있기 때문에 1.x에서 2.x로의 마이그레이션이 쉽지 않을 수도 있지만, 그래도 많은 혜택을 누릴 수 있을 것입니다. 1.x에서 2.x로 마이그레이션하는데 사용할 수 있는 도구가 있고, deprecated된 API에 대한 안내와 가이드도 잘 쓰여 있기 때문에 참고하시면 도움이 될 것입니다.</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://github.com/vuejs/vue-migration-helper">vue-migration-helper</a></li>
  <li><a href="https://vuejs.org/v2/guide/migration.html">Migration from Vue 1.x</a></li>
</ul>

<h2 id="section-2">패키지 관리 도구</h2>

<p>Vue 플러그인의 리포지터리를 다양하게 찾아보면 보통은 npm 패키지의 관리를 위해 npm을 이용하는 곳이 대부분이었습니다. 개발이 활발한 일부 저장소의 경우는 yarn을 이용하는 곳도 있었습니다만 그 수는 많지 않았던 것 같습니다.</p>

<p>하지만 npm에 비해 yarn은 의존하는 라이브러리가 많을수록 설치가 빠르다는 벤치마크 결과도 나와 있어 새 프로젝트에서 yarn을 쓰지 않을 이유는 없을지도 모릅니다. CI 등으로 yarn을 사용할 때는 캐시 설정 등을 조심해서 사용할 필요가 있습니다.</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://speakerdeck.com/pine613/yarn-vs-npm-at-2-vs-npm-at-3">yarn vs npm@2 vs npm@3</a></li>
</ul>

<h2 id="section-3">빌드 도구</h2>

<p>Vue.js 공식에서 제공하고 있는 vuejs-templates에는 webpack과 browserify를 위한 샘플 설정 파일과 구현이 있습니다. 각 저장소의 스타 수를 보면 webpack쪽이 압도적으로 인기인 것 같네요. Vue.js 라이브러리 등을 봐도 webpack을 사용하고 있는 곳이 대부분이며, 어셋 등을 쉽게 관리할 수 있는 기능이 있는 webpack을 사용하는 것을 권장합니다.</p>

<h2 id="section-4">기법</h2>

<p>v-on과 v-bind를 이용할 때는 역시 간결한 단축법을 선호하는 것 같습니다. 또한 여러 사람이 개발하는 프로젝트라면 ESLint과 <code class="highlighter-rouge">.editorconfig </code> 등을 이용하여 문법과 구문을 통일하는게 일반적입니다.</p>

<h2 id="props--">Props의 타입 체크</h2>

<p><code class="highlighter-rouge">props</code>를 통해 들어오는 값의 타입 체크는 가능한 사용하는 것이 좋겠죠. 예를 들어 양의 정수를 기대하는 <code class="highlighter-rouge">props</code>일 때에는 Number 형인지 검사하는 것과 함께 음수가 아닌지 validate해준다면 알아채기 어려운 버그를 줄이는데 큰 도움이 됩니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// not so good</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">[</span><span class="s1">'age'</span><span class="p">]</span>
<span class="p">})</span> 

<span class="c1">// good</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">age</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="nb">Number</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span> 

<span class="c1">// better</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">age</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="nb">Number</span><span class="p">,</span>
      <span class="na">required</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="na">validator</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span> </code></pre></figure>

<p><code class="highlighter-rouge">props</code>의 타입 체크에는 여러가지 형태를 지정하거나 <code class="highlighter-rouge">null</code>로 지정하여 모든 형태를 허용할 수 있습니다만, 이처럼 <code class="highlighter-rouge">null</code>로 지정하는 것은 지양하는 것을 추천합니다. 아무래도 <code class="highlighter-rouge">null</code>을 지정하는 경우에는 하나의 형식의 값을 전달할 수 있도록 컴포넌트나 <code class="highlighter-rouge">props</code>로 넘기는 방식으로 데이터의 구조를 다시 검토해보는 것이 좋을 것 같습니다.</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://vuejs.org/v2/guide/components.html#Prop-Validation">Prop Validation</a></li>
</ul>

<h2 id="section-5">라이프사이클 훅의 활용</h2>

<p>Vue.js에는 편리한 API가 많이 준비되어 있습니다만, 이벤트 계열의 메소드나 세세한 컴포넌트 옵션을 구사하기 전에 구현하려고 하는 처리나 행위가 라이프사이클 훅을 잘 활용해서 돌아가는지 점검해볼 필요가 있습니다. 필자의 경험으로는 컴포넌트가 생각했던대로 동작하지 않을 경우 라이프사이클 훅의 사용이 잘못됬었던 경우가 많았습니다. 그럴 경우 자칫 <code class="highlighter-rouge">watch</code>나 <code class="highlighter-rouge">$emit</code>을 필요 이상으로 복잡하게 남용하고 있었던 것입니다. 라이프사이클 훅을 잘 맞춰야 심플하고 자연스럽게 동작합니다.</p>

<p>컴포넌트가 단독으로 존재하고 있는 등의 미니멀한 상황에서는 <code class="highlighter-rouge">created</code>나 <code class="highlighter-rouge">mounted</code> 같은 라이프사이클을 이용해도 그다지 큰 차이는 없을지도 모릅니다. 하지만 컴포넌트들이 <code class="highlighter-rouge">props</code> 등을 통해 서로 맞물려서 동작하는 경우는 부모 컴포넌트의 <code class="highlighter-rouge">created</code>와 자식 컴포넌트의 <code class="highlighter-rouge">mounted</code> 등의 타이밍 차이를 잘 이해하고 컴포넌트를 작성할 필요가 있습니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">mounted</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello from parent"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// =&gt; "Hello from parent"</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">mounted</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello from child"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">mounted</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello from parent"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// =&gt; "Hello from child"</span>
<span class="c1">// =&gt; "Hello from parent"</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">mounted</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello from child"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">created</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Hello from parent"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="c1">// =&gt; "Hello from parent"</span>
<span class="c1">// =&gt; "Hello from child"</span></code></pre></figure>

<h2 id="v-for---">v-for로 표시된 컴포넌트의 제거</h2>

<p><code class="highlighter-rouge">v-for</code>로 렌더링된 아이템의 리스트 중에서 사용자의 조작에 의해 특정 컴포넌트를 제거하는 일은 자주 있다고 생각합니다. 이를 구현하는 방법은 다양할 것이라 생각하지만, 대부분 아래의 두가지 방법인 것 같습니다.</p>

<ol>
  <li>삭제 대상의 컴포넌트(하위 컴포넌트)가 자신의 삭제를 부모 컴포넌트에게 이양하는 패턴 (삭제를 이벤트로 해서 <code class="highlighter-rouge">$emit</code>하고 실제 삭제 처리는 부모 컴포넌트가 하거나, store에 커밋한다.)</li>
  <li>부모 컴포넌트의 함수로 삭제 처리를 구현하고 삭제 함수를 자식 컴포넌트에 <code class="highlighter-rouge">props</code>로 전달합니다. 실제로 삭제할 때 자식 컴포넌트가 받고 있는 함수를 실행해서 컴포넌트 자신을 제거합니다.</li>
</ol>

<p>필자 개인적으로는 어떤 방법이 다른 쪽에 비해 특히 우수하다고는 생각하지 않습니다만, UI나 컴포넌트의 분할 단위 관점에서 처리 흐름이 보다 자연스러운 쪽을 선택하는 것이 좋다고 생각합니다. 또한 자식 컴포넌트의 제거 이외에 추가 처리가 이것저것 부수적으로 있을 때에는 두 번째 방법이 더 다루기 쉬울지도 모릅니다.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 패턴 1</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">removeItem</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">$parent</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">'removeItem'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 패턴 2</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">'child'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">removeItem</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="nb">Function</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<h2 id="section-6">외부 라이브러리의 컴포넌트화</h2>

<p>서드 파티 라이브러리, 특히 UI와 관련한 라이브러리의 경우는 Vue 인스턴스 안에서 직접 라이브러리를 사용하는 것이 아니라 Vue의 컴포넌트로 감싸는 것을 고려해보세요. 다른 컴포넌트에서도 Vue의 API를 통해 동작할 수 있게끔 서드 파티 라이브러리의 API에 관심을 기울일 필요가 있습니다.</p>

<p>또 범용적으로 쓰고 싶은 UI의 효과(애니메이션이나 전환 효과같은…) 등은 컴포넌트와 디렉티브를 모두 준비해야한다고 생각합니다. 이렇게 하면 이 효과를 이용하는 다른 컴포넌트의 사정에 맞춰 컴포넌트로 이용하거나, 디렉티브를 통해 이용할지 선택할 수가 있습니다.</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://vuejs.org/v2/examples/select2.html">Wrapper Component</a></li>
  <li><a href="https://github.com/surmon-china/vue-touch-ripple">vue-touch-ripple</a></li>
</ul>

<h2 id="section-7">비동기 통신 라이브러리</h2>

<p>얼마 전 <a href="https://github.com/pagekit/vue-resource">vue-resource</a>가 Vue.js의 공식 비동기 통신 라이브러리였지만, 현재 Vue.js가 공식으로 제공하는 비동기 통신 라이브러리는 없습니다. 원래 Vue.js는 외부 라이브러리를 통합하기 쉽도록 되어있어 평소 사용하던 익숙한 비동기 통신 라이브러리를 사용하는 것이 좋습니다.</p>

<p>공식에서 벗어나긴 했지만, vue-resource를 이용하고 있는 프로젝트도 많은 것 같습니다. Javascript 전체의 상황을 보면 <a href="https://github.com/mzabriskie/axios">axios</a>나 <a href="https://github.com/request/request">request</a> 등이 인기인 것 같습니다. 또한 브라우저의 fetch API를 이용하는 것도 괜찮겠죠. (Safari에서는 아직 네이티브로 구현되어있지 않기 때문에 <a href="https://github.com/github/fetch">polyfill</a>의 사용이 필요합니다.)</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4#.phooxp2li">Retiring vue-resource</a> </li>
</ul>

<h2 id="flux--">Flux 아키텍쳐의 도입</h2>

<p>작년 경부터 Flux 아키텍쳐가 프론트엔드에 새로운 바람을 가져다주고, Vue.js 세계에도 <a href="https://github.com/vuejs/vuex">Vuex</a>라고 하는 Flux-like한 라이브러리가 공식적으로 제공되고 있습니다. Vuex 자체는 매우 잘 만들어진 라이브러리지만, 애플리케이션의 규모나 복잡도와 잘 부합하는지를 검토해봐야한다고 필자는 생각합니다.</p>

<p>필자 개인적인 감상으로는 중소 규모의 애플리케이션이라면 Vuex를 도입하는 것보다 전에 Vue.js 공식 문서에 적혀있었던 <a href="https://vuejs.org/v2/guide/state-management.html">store 패턴을 도입</a>해서 상태를 관리하는 것이 더 낫다고 생각합니다. Vuex는 상태 관리와 업데이트에 질서를 가져다주지만, 도중에 도입해버리면 오히려 일관성을 잃거나 불필요한 오버 엔지니어링을 낳을 우려도 있습니다.</p>

<p><a href="http://qiita.com/advent-calendar/2016/vue">Vue.js 대림절 달력 2016</a>에도 있듯 <a href="http://qiita.com/nekobato">@nekobato</a>님의 <a href="http://qiita.com/nekobato/items/44a7027504a2c65ce664">“구조의 복잡성와 Vuex 헤쳐보기”</a>가 매우 도움이 되기 때문에 흥미가 있는 분들은 그쪽을 참고하시면 도움이 될 것입니다.</p>

<h2 id="section-8">싱글 파일 컴포넌트</h2>

<p>빌드 환경 및 프로젝트 개발 환경에 크게 의존하고 있지만, 싱글 파일 컴포넌트(.vue 파일)을 이용할 수 있는 경우는 적극적으로 활용하는 것이 좋습니다. 컴포넌트는 사용자 인터페이스의 ‘외형’과 ‘행동’을 바탕으로 분할한 부품의 단위이며 템플릿(HTML), 외관(CSS), 그리고 동작(Javascript)를 하나의 파일로 끝내는데에는 의미가 있다고 생각합니다. 프론트엔드 개발자와 디자이너가 협동하는 경우에도 싱글 파일 컴포넌트는 통일적인 작업 환경을 만들어주기 때문에, 효율적으로 협어하는데 도움이 될 것으로 기대하고 있습니다.</p>

<h2 id="section-9">컴포넌트의 재활용</h2>

<p>“싱글 파일 컴포넌트”에서도 쓴 것처럼 컴포넌트는 극단적으로 말하면 UI를 분할한 부품이며, UI의 부품은 그것이 속한 페이지의 문맥화에 있습니다. 비슷하게 보이는 UI도 실은 행동이 다르거나 하는 엣지 케이스를 가지는 경우는 적지 않습니다.</p>

<p>이러한 “보기처럼 보이고 실제로는 다른” 부품을 공통의 컴포넌트로 구현해버리면 인수나 <code class="highlighter-rouge">props</code>에 의한 제어 뿐만 아니라 컴포넌트의 조건 분기가 증가할 수 밖에 없습니다. 이것은 일반적인 컴포넌트를 이용할 때도 큰 부담을 주기도 하며, 버그의 온상이 될 수도 있습니다.</p>

<p>이러한 상황은 UI 디자인을 검토하는 좋은 타이밍에 포착할 수도 있지만, 어쨋든 무리한 공통화와 범용화는 좋은 결과를 가져오지 않는다는 것을 강조하고 싶습니다. 다른 컴포넌트에서 공통 부분을 찾아서 공통화하는 것보다, 한번 공통화된 것을 분리하는 것이 더 어렵습니다. 브라우저의 성능도 나날이 향상하고 대부분의 클라이언트는 빠른 네트워크에서 웹 애플리케이션을 사용합니다. 약간 파일 크기가 커진다고 해도, 무리한 일반화는 삼가하고 코드 베이스를 취급하기 쉬운 형태로 유지하는 것이 더 이점이 크지 않을까요?</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://vuejs.org/v2/guide/components.html#Authoring-Reusable-Components">Authoring Reusable Components</a></li>
</ul>

<h2 id="section-10">테스트</h2>

<p>Vue.js 대림절 달력 2016에서도 일부 테스트와 관련된 글이 올라왔습니다만, 프론트엔드 개발이 계속 복잡해지고 있는 요즘 Vue.js를 이용한 컴포넌트 유닛 테스트를 작성할 필요성은 점점 높아지고 있다고 생각합니다.</p>

<p>그 컴포넌트의 구현을 본 것만으로 컴포넌트의 움직임이나 처리를 모두 이해할 수 있는 컴포넌트라면 일부러 테스트를 할 필요는 없겠죠. 하지만 컴포넌트 간에 <code class="highlighter-rouge">props</code>가 전달되고, 그것을 바탕으로 컴포넌트의 동작이 바뀌는 경우에는 해당 컴포넌트의 동작이 명시된 테스트 코드가 있으면 안심입니다. 또한 필자 자신은 컴포넌트에서 비동기 통신을 진행하고 응답 내용에 따라 Vue 인스턴스에 값을 설정하는 것 같은 행동을 하는 컴포넌트가 있을 때도 유닛 테스트를 작성하도록 하고 있습니다. 이렇게 테스트를 작성하는 코스트와 테스트를 통해 얻는 안정성(이익)을 헤아리는 것은 어렵지만, 역시 테스트가 있으면 리팩토링을 할 때 안정적으로 진행할 수 있습니다.</p>

<p><strong>Reference</strong></p>

<ul>
  <li><a href="https://vuejs.org/v2/guide/unit-testing.html">Unit Testing</a></li>
  <li><a href="http://qiita.com/potato4d/items/8215941b84c11b845886">Vue.js Vue 컴포넌트의 유닛 테스트를 작성해보자</a></li>
  <li><a href="http://qiita.com/hypermkt/items/e9f34a89221c50de2094">axios을 이용한 Vue component의 UnitTest</a></li>
</ul>

<h2 id="section-11">정리하며</h2>

<p>Vue.js에 한정하지 않고 어떤 프레임워크도 프레임워크의 특성과 습관을 이해하고 활용하는 것이 중요하다는 것은 의심할 여지가 없습니다. 또한 개발된 애플리케이션도 다양하고, 개발자는 요구사항에 부합하는 설계를 하고 적당한 라이브러리를 쓰는 것이 필요합니다. 이 문서가 Vue.js를 이용하여 프론트엔드 개발을 하고 있는 사람과 앞으로 프론트엔드 개발을 하려는 사람에게 도움이 된다면 기쁠 것 같습니다</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>vue-js를-쓸-때의-모범-사례에-대해서-생각해보다</wp:post_id>
            <wp:post_date>2017-01-17 12:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>지킬 블로그에 AMP를 적용해보자</title>
            <link>http://realignist.me/code/2016/12/01/amp-my-jekyll-web.html</link>
            <pubDate>Thu, 01 Dec 2016 18:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/12/01/amp-my-jekyll-web.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>항상 그렇지만 사람이 백수가 되면 심심해지고, 사람이 잉여로워지면 무언가 재미난 것을 하게 된다. 오늘은 지킬 블로그에 AMP(Accelerated Mobile Pages) 페이지를 넣은 후기를 쓰려고 한다. 이 글은 AMP가 무엇인지 아는 사람을 위해 작성된 글로, AMP에 대한 설명과 소개는 <a href="https://www.ampproject.org/ko/learn/about-amp/">여기</a>에서 볼 수 있다.</p>

<h3 id="travis">천리길도 Travis부터.</h3>

<p>사실 지금 보고 있는 이 웹 페이지는 GitHub Pages에서 돌아가고 있다. GitHub Pages는 기본적으로 Jekyll을 지원하기 때문에 소스 코드만 GitHub에 올리면, 알아서 웹에서 생성된 html 파일을 볼 수 있다. 하지만 GitHub Pages는 외부 플러그인을 지원하지 않는 안전 모드로 동작하기 때문에, 나는 AMP를 적용하기 위해 html만이 있는 브랜치와 소스 코드가 있는 브랜치를 분리하게 되었다.</p>

<p>item4님도 Travis로 블로그를 설정하셨길래 어떻게 셋팅했나 보니까 Lektor는 손쉽게 GitHub로 생성된 html만을 Deploy할 수 있었다. 아…! 셋팅하기 너무 귀찮았지만, 백수니까 그냥 셋팅했다. 내 빌드 스크립트는 <a href="https://github.com/Hazealign/hazealign.github.io/blob/src/scripts/deploy.sh">여기</a>에서 볼 수 있다. (블로그 커밋 로그가 엉망이니까 로그는 보지 않는걸 권장한다…)</p>

<h4 id="section">참고했었던 스크립트들이다.</h4>

<ul>
  <li><a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd">처음에 뼈대로 쓴 것</a></li>
  <li><a href="http://eshepelyuk.github.io/2014/10/28/automate-github-pages-travisci.html">그 이후에 참고한 것 </a></li>
</ul>

<p>아, 기분 좋게 Travis가 연동됬다. 이제 Jekyll에 플러그인을 이것저것 넣을 수도 있으니 AMP 플러그인을 넣어보기로 한다.</p>

<h3 id="amp-jekyll-amplify">amp-jekyll과 amplify</h3>

<p>amp-jekyll과 amplify를 소개하기 전에 우선 고백한다. 내 블로그는 끄-음찍한 혼종이다. 상단 부분의 헤더는 amplify를 참고했고, 기본적으로 amp html을 생성하는 것은 amp-jekyll을 이용하고 있다. 내가 웹을 제대로 개발하는 사람은 아니기 때문에 내 블로그는 그만 알아보자…</p>

<p><a href="https://github.com/juusaw/amp-jekyll">amp-jekyll</a>은 jekyll 플러그인 형태로 amp html을 생성시키는 프로젝트다. 또 <a href="https://github.com/ageitgey/amplify">amplify</a>는 amp html을 만들어내는 하나의 jekyll 테마이다. 나는 이미 만들어두고 쓰고 있는 베이스 jekyll 테마가 있었기 때문에 amp html에서만 amplify를 살짝 참고하고, amp html 베이스는 amp-jekyll로 만들었다. amp-jekyll을 약간 수정했는데 내 프로젝트의 <code class="highlighter-rouge">_posts</code> 구조에 맞게 바꾼 것과 <a href="https://github.com/juusaw/amp-jekyll/pull/14/files">Pull Request 하나</a>를 체리픽한게 끝이다.</p>

<h3 id="section-1">하면서 디버깅은 어떻게 했는가.</h3>

<p>다른 amp html을 개발할 때랑 똑같이 amp 페이지 url 뒤에 <code class="highlighter-rouge">#development=1</code>를 넣어주면 된다. 매우 심플하다. 그러면 amp validation이 동작할 것이다.</p>

<p>또, 중간에 <a href="https://github.com/juusaw/amp-jekyll/pull/11">이 PR</a>을 체리픽 했었는데 문제가 있었다. <code class="highlighter-rouge">amp-img</code> 태그에는 기본적으로 이미지의 width와 height가 명시되어야하기 때문에 fastimage라는 모듈을 써서 이미지의 원본 사이즈를 가져오는데, 여기가 제대로 동작하지 않았었다. 한가지 더, amp html은 url 맨 끝에 <code class="highlighter-rouge">.html</code> 확장자를 붙으면 에러가 난다. 참고하자.</p>

<h3 id="amp---">그래서 내 AMP 페이지는 어떻게 보일까?</h3>

<p><img src="http://realignist.me/assets/images/20161201_1.png" alt="스크린샷" /></p>

<p>대충 이렇게 보인다. 디자인적으로는 아쉽긴 하지만, 모바일에서 검색했을 때 빨리 보인다는 메리트 때문에 AMP를 쓰는거라서 크게 거슬리거나 하지는 않았다. 이제 구글 검색이 AMP 검색 결과를 보여주길 기다리면… 될 것 같다. :D</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>지킬-블로그에-amp를-적용해보자</wp:post_id>
            <wp:post_date>2016-12-01 18:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>macOS 기준 Rust에서 OpenSSL과 관련된 빌드 오류 해결하기</title>
            <link>http://realignist.me/code/2016/10/01/rust-osx-openssl-issue.html</link>
            <pubDate>Sat, 01 Oct 2016 01:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/10/01/rust-osx-openssl-issue.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>Rust로 OpenSSL과 연결된 것들을 빌드할 때, 간혹 다음과 같은 에러를 볼 수 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="gd">--- stderr
</span>/…/openssl-sys-0.6.4/src/openssl_shim.c:1:10: fatal error: 'openssl/hmac.h' file not found
#include &lt;openssl/hmac.h&gt;
         ^
1 error generated.
</code></pre>
</div>

<p>이럴 때는 다음과 같이 해결할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">brew install openssl

 <span class="c"># 다음 내용을 환경 변수로 추가해주세요.</span>
<span class="nb">export </span><span class="nv">OPENSSL_INCLUDE_DIR</span><span class="o">=</span><span class="sb">`</span>brew --prefix openssl<span class="sb">`</span>/include/
<span class="nb">export </span><span class="nv">OPENSSL_LIB_DIR</span><span class="o">=</span><span class="sb">`</span>brew --prefix openssl<span class="sb">`</span>/lib/</code></pre></figure>

<p>이럼에도 불구하고, 간혹 같은 에러가 난다면 <code class="highlighter-rouge">OPENSLL_LIB_DIR</code>를 직접 설정해주면 됩니다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">OPENSSL_INCLUDE_DIR</span><span class="o">=</span>/usr/local/Cellar/openssl/<span class="o">(</span>버전<span class="o">)</span>/include/</code></pre></figure>

<p>아 그리고 나서, <code class="highlighter-rouge">cargo clean</code>을 해주고 다시 빌드하는걸 잊지 마세요. :)</p>

<h1 id="reference">Reference</h1>
<ul>
  <li><a href="https://github.com/sfackler/rust-openssl">https://github.com/sfackler/rust-openssl</a></li>
  <li><a href="https://github.com/sfackler/rust-openssl/issues/255#issuecomment-133463099">https://github.com/sfackler/rust-openssl/issues/255#issuecomment-133463099</a></li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>macos-기준-rust에서-openssl과-관련된-빌드-오류-해결하기</wp:post_id>
            <wp:post_date>2016-10-01 01:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Dynamic Motion, DM200H 가벼운 리뷰</title>
            <link>http://realignist.me/life/2016/07/06/dm200h-review.html</link>
            <pubDate>Wed, 06 Jul 2016 01:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/life/2016/07/06/dm200h-review.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>개인적으로 밸런스드 아마츄어의 장점과 다이나믹 드라이버의 장점을 합친 하이브리드 이어폰을 좋아하는데 국내 기업이 세계 최초로 동축 배치의 하이브리드 이어폰을 출시했다는 이야기를 듣고 흥미를 느껴 DM-200H를 구해보았다.</p>

<p>오디오 리뷰는 항상 그렇지만 전문적인 측정 장비가 없을 때는 개인의 주관적 특성을 탈 수 밖에 없다. 읽을 때에는 이 점에 부디 주의해줬으면 좋겠다. 또 개인적으로는 이어폰이나 헤드폰의 에이징(처음에 딱딱하게 굳어있는 진동판을 풀어주는 행위)이라는걸 별로 생각하지 않는 편이고 특별히 이퀄라이징을 해서 음악을 듣는 편도 아니다. 이 리뷰에서는 제품에 대한 일체의 에이징도 하지 않았음을 밝힌다.</p>

<p>다이나믹 모션이라는 음향 장비를 생산하는 업체가 있다는 것은 최근에 지인이 DM100E를 사면서 알게 되었다.(그 지인이 쓴 DM100E 개봉기는 <a href="http://blog.badalab.link/220708653084">여기</a>에서 볼 수 있다.) 근데 사실 그때도 다이나믹 모션에 대한 큰 관심은 없었고 이 업체가 한국 업체라는 것도 모르고 있었다. 나는 이 업체가 세계 최초로 동축 배치의 하이브리드 이어폰을 만들었다는 소식을 일본 매체를 통해 알게 되면서 이 기업이 한국 기업이라는걸 알게 되었다. 이 제품은 일본의 요도바시 카메라같은 곳에서 31000엔에 팔리고 있었고 한국에서도 대략 30만원 내외로 팔리겠구나라고 생각했는데, DMStore에서 판매하고 있는 가격은 198,000원이라서 해외에서 싸게 팔고 국내에서 비싸게 받는거에 익숙해져 있었던 나머지 좀 놀랐다.</p>

<h2 id="section">특이한 하이브리드 유닛 구조와 제품 특성</h2>

<p><img src="http://realignist.me/assets/images/20160706/1.png" alt="" /></p>

<p>일단 구매하기 전에 다이나믹 모션이 특허(등록번호: 1014601700000)로 가지고 있는 드라이버 구조를 보았다. 다이나믹 모션에서 제공하는 위의 그림을 보면 알 수 있겠지만 다이나믹 드라이버가 도넛 모양으로 있고 가운데의 공간을 밸런스드 아마츄어 드라이버가 차지하는 구조를 가지고 있다. 다른 하이브리드 이어폰들은 각 드라이버가 따로 배치하는데, 동축으로 배치하면서 기존의 이어폰들이 가지고 있는 위상 차이를 극복했다고 한다. 저걸 보고 든 생각은 “이론상으로는 이해되지만 역시 실제로 들어봐야 알지”라는 생각이 강했던 것 같다.</p>

<p>제품 정보로만 봤을 때 DM200H는 5Hz ~ 40kHz까지 재생할 수 있고, 24옴으로 꽤 낮은 임피던스를 가지고 있다. 또 선은 케블러 섬유로 감싸서 터치 노이즈를 최소화했다고 한다. 또 신기했던 점은 기본적으로 컴플라이 폼팁을 제공한다는 점이었다.</p>

<h2 id="section-1">언박싱</h2>

<p><img src="http://realignist.me/assets/images/20160706/2.jpg" alt="" /></p>

<p>택배 상자를 열어보니 DM200H, 여분의 컴플라이 폼팁 한쌍과 이어폰 청소를 위한 알콜 스왑 두개가 있었다.</p>

<p><img src="http://realignist.me/assets/images/20160706/3.jpg" alt="" /></p>

<p>박스를 열어보니 제품에 대한 상세한 설명과 함께 제품이 보인다. 이어팁들도 사이즈별로 보이고, 항공기에서 쓸 수 있는 플러그나 옷에 고정할 수 있는 클립, 그리고 대망의 이어폰.</p>

<p><img src="http://realignist.me/assets/images/20160706/4.jpg" alt="" /></p>

<h2 id="section-2">실제로 어땠는가?</h2>

<p>우선 착용감이 좋았다. 정말 다이나믹 드라이버 가운데에 BA 드라이버가 배치된 구조다보니 유닛이 생각했던 것보다 크지 않았고 편하게 착용할 수 있었다. 케이블도 그렇고 실제 전반적인 제품의 퀄리티가 매우 뛰어났다. 아쉬웠던 점은 보통 이 정도 되는 하이브리드 이어폰들이 대부분 선을 교체할 수 있거나, 아니면 기본적으로 4극 케이블로 스마트폰 컨트롤이 가능한데 이 부분은 아쉬웠던 것 같다.</p>

<p>저음의 경우 역시 다이나믹 드라이버 특유의 타격감을 느낄 수 있다. 락 같은 경우 드럼이나 베이스의 악기 저음을 잘 느낄 수 있다. 고음은 내 생각과 좀 달랐던 것 같다. 처음 씨코에서 제공한 리뷰의 측정치를 봤을 때는 역시 전체 대역을 담당하는 BA 유닛 하나와 저음 대역을 담당하는 다이나믹 드라이버 하나로 구성되어서 그런가 고음이 아쉬운 것 같다는 생각이 들었는데, 실제로 내가 들어본 결과는 고음의 해상력도 괜찮았다. 여러 노래들을 들어보면서 여성 보컬의 가요 등도 듣기 좋을 것 같다는 생각이 들었다.</p>

<p>특별히 장르로 추천을 하라고 하면 락과 일렉트로닉에 특히 좋을 것 같다고 이야기할 수 있지만, 보컬의 성별을 가리지도 않고 팝이나 R&amp;B 등 장르도 특별히 가리지 않는 것 같다. 또 가격 대비 품질과 성능도 매우 훌륭한 편이라고 생각한다.</p>

<h2 id="conclusion">Conclusion</h2>

<ul>
  <li>독자적인 기술을 통해 장르나 음역을 가리지 않고 뛰어난 가성비와 해상력을 보여줌</li>
  <li>타 하이브리드 이어폰에 비해 착용감이 편하며 소리의 이질감이 적음</li>
  <li>케이블이 재생 컨트롤이 안되는 점이 아쉬움</li>
  <li>이어팁을 갈아끼울 때 홈이 너무 깊어서 생긴 사소한 불편함</li>
</ul>

<p>한국 기업에서도 이런 높은 퀄리티의 이어폰을 만들 수 있다는 점에 감탄했고, 다이나믹모션이 준비 중이라고 하는 DM300H 모델도 자연스럽게 기대가 된다.</p>

]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>dynamic-motion-dm200h-가벼운-리뷰</wp:post_id>
            <wp:post_date>2016-07-06 01:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>상반기를 정리하며.</title>
            <link>http://realignist.me/life/2016/07/02/half-report.html</link>
            <pubDate>Sat, 02 Jul 2016 18:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/life/2016/07/02/half-report.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>6월이 끝나간다. 곧 있으면 7월이 다가오며 하반기가 된다. 상반기 동안 내가 뭘했을까 정리라도 해둬야 나중에 잊지 못할 것 같다는 생각이 들었다. 이 글이 공개될 때 쯤이면 아마 나는 이상한모임의 720 컨퍼런스에서 내가 취업하면서 나 자신이나, 포트폴리오 등을 관리한 이야기를 이야기한 뒤가 될 것 같다. 이 글에도 그 내용이 일부 들어있다.</p>

<h2 id="section">생존하는 것에 대한 고찰</h2>

<p>1월에 처음 세운 목표는 생존이었다. 작년에 내가 병원비로만 100만원을 썼다는 사실에 멘붕하면서 어떻게든 심신의 안정을 찾고 생활 패턴을 만들고 규칙적인 삶을 살아서 생존하는게 목표였다. 내가 병원에 쓰는 돈을 생각하면 1년에 100만원이 아니라 한달에 몇십만원을 쓰고 있으니 사실 삶을 유지하기 위한 코스트는 더 높아지긴 했다. 그리고 운동도 못했다, 이건 특유의 의지 박약과 인도어한걸 좋아하는 성격이 한 몫 했을 것 같다.</p>

<p>근데 이상하게 작년과 올해 내가 느끼는 심리적인 지침은 확연하게 차이가 난다. 심리학에 대해서 관심이 많아지면서 계속 책을 읽고 상담도 꾸준히 받고 적극적으로 무언가를 하려고 했었던 것들이 분명 도움이 되었을 것이다. 상담이나 치료 등으로 돈이 많이 들었지만, 그 돈이 아깝지 않을만큼 내 마음에 조금이나마 안정을 준다는 생각도 들게 된 것이다.</p>

<p>2년 가까이 습관성 수면제(심심치 않게 뉴스에 나오는 졸피뎀이 그것이다.)를 먹었던 것 같다. 이 약의 도움도 많이 받았지만 어느샌가 내가 계속 약으로만 잠들어야 하는가에 대한 회의감을 느끼게 되었다. 수면 습관을 어떻게든 만들면서 졸피뎀을 끊었는데 힘들지 않다고 하면 거짓말일 것이다. 지금도 과각성 상태가 되거나 할 때는 신경안정제를 먹긴 하지만 그래도 내가 먹는 약 중에서 마약류가 하나 줄었다는 사실만으로도 꽤 기뻤던 것 같다.</p>

<p>어떻게 하면 더 잘 생존할 수 있을지에 대한 고민은 아직 많이 하고 있다. 하반기엔 어떻게 부족한 운동을 시작해야할까라는 고민도 해본다.</p>

<h2 id="section-1">책을 많이 읽게 된 이야기와 전자책</h2>

<p>상반기에 나의 변화에 대해서 생각해보면 책을 많이 읽은 것에도 의미를 좀 두고 싶다. 모리 히로시의 S&amp;M 시리즈같은 추리 소설부터 알프레드 아들러나 빅터 플랭클의 로고테라피같은 심리학 책, CPU와 컴파일러의 최적화나 LLVM에 관련된 기술 책, 하즈키 맛챠의 “내가 나로 있기 위해” 같은 만화책까지… 50권 넘는 책들을 상반기에 읽은 것 같다.</p>

<p>사실 이상한모임에서 전자책에 대해 처음 접했을 때는 책이나 앨범에 대한 소유에 그 의미가 있다고 생각하고 전자책을 부정하게 됬었는데 굉장히 두꺼운 책들과 일본의 문고판 책들, 이런 경우들을 보니까 전자책이 생각보다 괜찮지 않을까라는 생각을 하게 되었다. 결국은 아이패드가 짱이었다. 리디북스 페이퍼의 E-ink 디스플레이는 나를 만족시키지 못했고, AMOLED 디스플레이를 탑재한 갤럭시탭S2는 막상 Epub 책을 열어보는게 버벅거렸다. 킨들, 리디북스, iBooks 등 플랫폼을 아우르지 않고 편안한 독서 경험을 아이패드가 제공한 것 같았다.</p>

<p>인상적이었던 책들을 두 권만 골라보면 바빗 로스차일드의 “내 인생을 힘들게 하는 트라우마”가 내 자신의 PTSD 증상과 대응 방법 등에 대해 알 수 있는 좋은 책이었다고 생각하며, 제임스 팰런의 “괴물의 심연”은 인간의 반사회적인 기질에 대한 발현은 오히려 유전자같은 선천적인 영향보다도 후천적인 부분에 영향을 더 받는 것 같다는걸 느낄 수 있었다.</p>

<h2 id="section-2">번역을 하고, 진짜 블로그를 관리하고.</h2>

<p>내가 지금까지 블로그를 관리하는거는 글을 한번 쓰다가 블로그를 지우고 새로 만드는 것의 무한한 반복이었다. 이것은 의미없는 일이었기도 하지만, 꽤 좋은 글들도 날리기도 했다. (사실 브리즈번에서 토비님이나 오현석님을 만나게 됬던 계기도 내가 관리를 안하다가 날라간 블로그에 올렸던 글이다.) 올해 상반기는 정말 블로그를 만들어서 계속 꾸준히 쓰고 있다. Github에서 페이지를 서빙해주니까 유지 코스트가 들어가지 않아서 굉장히 좋은 것 같다.</p>

<p>사실 블로그를 관리하면서 내 번역이나 글에 대해서 부족함을 많이 느끼는데, 그런 글도 잘 읽어주시는 분들에게 감사를 드리고 싶다. 사실 글재주 없는 공돌이로는 직접 계속 글을 쓰는게 도움이 되는 것 같고, 또 유시민의 글쓰기 특강이라는 책이 굉장히 인상적이었다. 아무튼 Qiita에서 좋은 글들을 보면 번역을 하고 싶은 생각이 들고, 그 생각을 생각에서 멈추지 않고 직접 트위터로 소통하고 번역할 수 있게 되었다.</p>

<h2 id="section-3">프리랜서로 일하다가, 회사에 들어가고.</h2>

<p>올해는 프리랜서로 일하는걸로 시작했다. 사실 쉬고 싶은 마음이 컸지만 사람이 사는데는 돈이 필요하니까 일을 할 수 밖에 없었다. 모 회사의 테스팅 플랫폼에 들어가는 탈옥 기반 iOS 리서치 과제라던가 모 서비스에서 영수증을 자동으로 인식하는 알고리즘 연구 등을 했었고 나중에는 안정적인 병원 치료를 위해 직장이 필요하다는걸 느끼고 회사에 들어가게 되었다.</p>

<p>사실 이모콘에서도 이야기했지만 “내가 같이 일하고 싶은 사람”과 일하는게 중요하다는걸 고민하게 되었다. 프렌트립에 합류한건 딱 1개월 되었다. 일을 시작하기 2일 전에 회사에 가서 계약서에 도장을 찍을 때 소스코드 권한을 같이 받아서 소스를 리딩한게 어느 정도 이해하는데에 도움이 되었다.</p>

<h2 id="conclusion">Conclusion</h2>

<p><strong>상반기에 한 것</strong></p>

<ul>
  <li>생존에 대해서는 체중 감량 등에 대해서는 오히려 아쉬운 점이 많았지만, 생활 패턴을 되찾게 되고 졸피뎀을 끊었다. 나는 아직도 힘들고 만족스럽지는 않지만 병원에서는 그래도 90점 이상의, 빠른 치료 효과를 보이고 있다고 한다.</li>
  <li>독서를 많이 했다. 아이패드를 통해 전자책에도 빠진 것 같다. 하반기에는 100권 가까이의 책을 읽을 수 있으면 좋겠다.</li>
  <li>제대로 블로그를 관리하게 되었다. 재미있는 글들을 찾아 번역하는 재미를 느끼고, 뭔가 파고 싶은 것들이 있거나 아니면 생각을 정리할 때도 블로그는 유용한 것 같다.</li>
  <li>프리랜서로 일하다가 프렌트립에 합류했고, 이번 상반기는 정말 같이 일하고 싶은 분들과 일할 수 있었던 것 같다. 열심히 그러면서도 재밌게 일하고 있어서 의미가 있는 것 같다.</li>
</ul>

<hr />

<p><strong>하반기에 하고 싶은 것</strong></p>

<ul>
  <li>우선 회사 일에 대한 욕심이 있는 것 같다. 제대로 된 안드로이드 앱을 고쳐서 내가 만든 서비스에서 나쁜 경험을 얻지 않게끔 하고 싶은 욕심이 있다.</li>
  <li>트라우마에 대해 좀 편안하게 마주하고, 이인감이나 해리성 장애로 나의 정신을 해리시켜 도망치지 않고 싶다.</li>
  <li>더 많은 좋은 글들을 번역하고 싶은 마음도 크고, 내 실력이 좀 더 늘어서 온전히 내가 좋은 글들을 쓸 수 있게 되었으면 좋겠다.</li>
  <li>피 검사 등을 받아보면 모든 지표가 정상적이긴 한데, 체중과 체지방 양은 그래도 많고 높다. 개인 PT를 해서라도 좀 하반기엔 운동을 해봐야하지 않을까.</li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>상반기를-정리하며</wp:post_id>
            <wp:post_date>2016-07-02 18:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Kotlin 코드를 문서화하자. (for Android)</title>
            <link>http://realignist.me/code/2016/06/24/kotlin-documentation.html</link>
            <pubDate>Fri, 24 Jun 2016 19:30:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/06/24/kotlin-documentation.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>처음 내가 Kotlin을 접할 때만 하더라도 많은 사람들이 Kotlin의 존재를 모르고 있었다. 그리고 Kotlin을 이리저리 설파하려고 하는 나조차도 최근에서야 나도 실무에서 Kotlin을 제대로 쓸 수 있게 되었다. 다른 사람과 협업을 할 때, 문서화는 중요하다. 내가 문법이나 이런걸 프로젝트에 문서화해둘 수는 없어도 프로젝트 안 클래스나 메소드, 프로퍼티들이 어떤 역할을 하고 있는지는 남길 수 있다.</p>

<p>그래서 오늘은 실전 안드로이드 프로젝트에서 어떻게 Kotlin 코드를 문서화할 수 있는지에 대해서 이야기해보고자 한다. 나는 안드로이드 프로젝트를 기준으로 설명하고 있지만, 기본적으로는 Gradle 기반의 프로젝트라면 이 글이 도움이 되리라 믿는다.</p>

<h2 id="kdoc--">KDoc을 남기는 방법</h2>

<p>KDoc은 Kotlin의 Javadoc같은 개념이라고 생각하면 된다. <code class="highlighter-rouge">/**</code>로 시작해서 <code class="highlighter-rouge">*/</code>로 끝이 난다. 여러 줄인데 매 줄마다 아스테리크 문자가 들어가는 형태이다. Kotlin 공식 문서가 제공하는 예시를 보자.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="cm">/**
 * A group of *members*.
 *
 * This class has no useful logic; it's just a documentation example.
 *
 * @param T the type of a member in this group.
 * @property name the name of this group.
 * @constructor Creates an empty group.
 */</span>
<span class="kd">class</span> <span class="nc">Group</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**
     * Adds a [member] to this group.
     * @return the new size of the group.
     */</span>
    <span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">member</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span> <span class="o">..</span><span class="p">.</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>그리고 KDoc은 인라인 마크업에 대해서는 C#의 xml같은 형태가 아니라 마크다운 문법을 따라하고 있다. 그리고 약간 특이한 점은 요런 식으로의 클래스, 프로퍼티, 메소드의 링킹이 가능하다.</p>

<p><code class="highlighter-rouge">Use [this method][doSomething] for this purpose.</code></p>

<p>블록 태그를 지원하며 이 부분은 Javadoc과 굉장히 유사한데, Kotlin에서는 다음과 같은 블록 태그를 지원한다. 그리고 <code class="highlighter-rouge">deprecated</code> 태그가 먹히지 않기 때문에 이 부분은 <code class="highlighter-rouge">Deprecated</code> 어노테이션을 달아줘야한다.</p>

<ul>
  <li>param</li>
  <li>return</li>
  <li>constructor</li>
  <li>property</li>
  <li>throws, exception</li>
  <li>sample</li>
  <li>author</li>
  <li>since</li>
  <li>suppress</li>
</ul>

<h2 id="gradle-dokka-kotlin--export-">Gradle에서 Dokka로 Kotlin 문서를 Export하는 방법</h2>

<ul>
  <li>루트 프로젝트의 <code class="highlighter-rouge">build.gradle</code>을 열어 다음과 같이 추가한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">buildscript</span> <span class="o">{</span>
    <span class="o">...</span>
    
    <span class="n">repositories</span> <span class="o">{</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
        <span class="n">jcenter</span><span class="o">()</span>
        <span class="n">maven</span> <span class="o">{</span>
            <span class="n">url</span> <span class="s1">'https://dl.bintray.com/kotlin/kotlin-eap'</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">dependencies</span> <span class="o">{</span>
	    <span class="o">...</span>
	    <span class="n">classpath</span> <span class="s2">"org.jetbrains.dokka:dokka-android-gradle-plugin:0.9.8"</span>
	    <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="o">...</span></code></pre></figure>

<ul>
  <li>앱 혹은 라이브러리 프로젝트의 <code class="highlighter-rouge">build.gradle</code>을 다음과 같이 설정한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="o">...</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'org.jetbrains.dokka-android'</span>

<span class="n">android</span> <span class="o">{...}</span>

<span class="n">afterEvaluate</span> <span class="o">{</span>
    <span class="n">generateDebugAndroidTestSources</span><span class="o">.</span><span class="na">dependsOn</span> <span class="n">dokka</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="o">...</span>

<span class="n">dokka</span> <span class="o">{</span>
    <span class="n">moduleName</span> <span class="o">=</span> <span class="s1">'...'</span>
    <span class="n">outputFormat</span> <span class="o">=</span> <span class="s1">'html'</span>
    <span class="n">outputDirectory</span> <span class="o">=</span> <span class="s2">"$projectDir/docs"</span>
    <span class="n">processConfigurations</span> <span class="o">=</span> <span class="o">[</span> <span class="s1">'compile'</span> <span class="o">]</span>
    <span class="n">linkMapping</span> <span class="o">{</span>
        <span class="n">dir</span> <span class="o">=</span> <span class="s2">"src/main/kotlin"</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s2">"https://github.com/.../.../blob/master/app/src/main/kotlin"</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">"#L"</span>
    <span class="o">}</span>
    <span class="n">sourceDirs</span> <span class="o">=</span> <span class="n">files</span><span class="o">(</span><span class="s1">'src/main/kotlin'</span><span class="o">)</span>
<span class="o">}</span>

<span class="o">...</span></code></pre></figure>

<p>Dokka의 상세한 정보는 <a href="https://github.com/Kotlin/dokka">GitHub</a>에서 볼 수 있다. <code class="highlighter-rouge">afterEvaluate</code>에, <code class="highlighter-rouge">generateDebugAndroidTestSources</code>는 <code class="highlighter-rouge">dokka</code>에 의존 관계를 갖는다고 명시했기 때문에 프로젝트를 빌드할 때 문서는 자동으로 생성될 것이다.</p>

<h2 id="stylesheet--">커스텀 Stylesheet를 적용하는 방법</h2>

<ul>
  <li>빌드가 끝나면 css와 html 파일이 나오는데 화면의 스타일시트를 수정하고 싶을 때는  Dokka의 소스를 열…뻔 했지만 생각해보니 생성이 끝나고 css 파일만 바꿔치기해주면 된다는 방법을 깨닫고 짜치게 구현해봤다. 앱이나 라이브러리 프로젝트의 <code class="highlighter-rouge">build.gradle</code> 파일을 수정해보자.</li>
</ul>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="o">...</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'org.jetbrains.dokka-android'</span>

<span class="n">android</span> <span class="o">{...}</span>

<span class="n">task</span> <span class="nf">switchStylesheet</span> <span class="o">(</span><span class="nl">type:</span> <span class="n">Copy</span><span class="o">,</span> <span class="nl">overwrite:</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s1">'Switching StyleSheet for Dokka'</span>
    <span class="n">from</span> <span class="s2">"${projectDir}/dokka/"</span>
    <span class="n">include</span> <span class="s2">"style.css"</span>
    <span class="n">into</span> <span class="s2">"${projectDir}/docs/"</span>
<span class="o">}</span>

<span class="n">afterEvaluate</span> <span class="o">{</span>
    <span class="n">generateDebugAndroidTestSources</span><span class="o">.</span><span class="na">dependsOn</span> <span class="n">switchStylesheet</span>
    <span class="n">switchStylesheet</span><span class="o">.</span><span class="na">dependsOn</span> <span class="n">dokka</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="n">dokka</span> <span class="o">{...}</span>

<span class="o">...</span></code></pre></figure>

<ul>
  <li><code class="highlighter-rouge">switchStylesheet</code>라는 task를 만들었다. 얘는 <code class="highlighter-rouge">dock</code> 태스크가 끝나면 실행되도록 의존성이 설정되어있고, 디버그 소스를 빌드할 때는 <code class="highlighter-rouge">switchStylesheet</code>에 의존성을 걸어주면 자연스럽게 동작하게 된다.</li>
  <li>프로젝트 디렉토리에 dokka 폴더를 만들고, 그 안에 css 파일을 넣으면 잘 동작할 것이다.</li>
</ul>

<h2 id="profit">Profit!</h2>

<p><img src="http://realignist.me/assets/images/20160624/1.png" alt="" /></p>

<p>이렇게 깔끔하게 문서가 나온다! 이렇게 나오는 문서를 보니 기분이 너무 조크든요… 개인적으로 클린한 코드를 짰을 때, 좋은 문서를 봤을 때, 문서화를 잘 했을 때 기분이 너무 좋다. 넘나 좋은 것.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://kotlinlang.org/docs/reference/kotlin-doc.html">https://kotlinlang.org/docs/reference/kotlin-doc.html</a></li>
  <li><a href="https://github.com/Kotlin/dokka">https://github.com/Kotlin/dokka</a></li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>kotlin-코드를-문서화하자-for-android</wp:post_id>
            <wp:post_date>2016-06-24 19:30:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>GDG Android Korea RxJava 스터디: 1회차</title>
            <link>http://realignist.me/code/2016/06/09/rxjava-study-1.html</link>
            <pubDate>Thu, 09 Jun 2016 10:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/06/09/rxjava-study-1.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h2 id="section">주제</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>1. Queue로써 Rx 활용
 - gdgand/android-rxjava
 
2. Lambda 동작의 이해
http://www.slideshare.net/jaxlondon2012/lambda-a-peek-under-the-hood-brian-goetz (p.19 ~)

3. 내가 RxJava 를 쓰는 이유
https://speakerdeck.com/jakewharton/android-development-with-kotlin-androidkw-number-001 (p.11)
http://www.slideshare.net/jpaumard/java-8-stream-api-and-rxjava-comparison (p.213 ~)
</code></pre>
</div>

<h2 id="queue-rx-">1. Queue로 Rx 활용하기</h2>

<ol>
  <li>푸쉬 메세지 예제
    <ul>
      <li>Device를 껐다가 켰을 때 오는 100개 정도의 알람을 해결할 때 사용함.</li>
      <li><code class="highlighter-rouge">commandQueue</code>라는 PublishSubject를 만들고, <code class="highlighter-rouge">onBackPressureBuffer</code>를 이용함.</li>
      <li><code class="highlighter-rouge">PublishSubject</code>는 크기의 한계가 있기 때문에 <code class="highlighter-rouge">onBackPressureBuffer</code>를 같이 쓰는게 좋음.</li>
      <li>이렇게 RxJava로 Queue를 구현하면 Multi-thread의 동시성 문제, <code class="highlighter-rouge">synchronize</code> 등등 수많은 작업을 짧게 할 수 있음.</li>
      <li>PublishSubject를 Queue처럼 활용할 수 있음.</li>
    </ul>
  </li>
  <li>RecyclerView의 Adapter에서 Observable 안에서 백그라운드 쓰레드로 처리함으로써 RecyclerView의 Frame 속도를 개선할 수 있음.
    <ul>
      <li>에러의 예외처리같은 경우에는 RxRelay의 <code class="highlighter-rouge">PublishRelay</code>를 쓰면 onError가 호출된 뒤에도 다시 emit을 받을 수 있다.</li>
    </ul>
  </li>
  <li>EventBus인 Otto를 RxJava로 옮기는 예제에서 PubSub를 쓰고 있기 때문에 예제를 체크해볼 필요가 있음.</li>
  <li>CompositeSubscription의 <code class="highlighter-rouge">unsubscribe</code>와 <code class="highlighter-rouge">clear</code>의 차이?
    <ul>
      <li>거의 비슷하지만 <code class="highlighter-rouge">unsubscribed</code>가 true냐 아니냐의 차이.</li>
    </ul>
  </li>
</ol>

<p><strong>참고자료</strong></p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=QdmkXL7XikQ">https://github.com/ReactiveX/RxJava/blob/master/src/main/java/rx/subscriptions/CompositeSubscription.java</a></li>
  <li><a href="https://www.youtube.com/watch?v=QdmkXL7XikQ">https://github.com/ReactiveX/RxJava/issues/2959</a></li>
  <li><a href="https://www.youtube.com/watch?v=QdmkXL7XikQ">https://www.youtube.com/watch?v=QdmkXL7XikQ</a>
    <ul>
      <li><a href="https://www.youtube.com/watch?v=QdmkXL7XikQ">https://speakerdeck.com/dlew/common-rxjava-mistakes</a></li>
    </ul>
  </li>
</ul>

<h2 id="lambda-----3--rxjava--">2. Lambda식이 내부에서 어떻게 동작하는가. &amp; 3. 내가 RxJava를 쓰는 이유</h2>
<ul>
  <li>람다식이 동작하는 원리를 알기 위해서는 Java 7과 8의 스펙을 이해해야함.</li>
  <li>자바 컴파일러는 람다 표현식을 <code class="highlighter-rouge">invokedynamic</code>으로 컴파일한다.</li>
  <li>Java 7에서 <code class="highlighter-rouge">invokedynamic</code>이라는 바이트코드가 폴리글랏을 지원하기 위해 새로 추가됨
    <ul>
      <li><code class="highlighter-rouge">invokedynamic</code>의 인자는 Bootstrap Method에 대한 레퍼런스다.</li>
      <li>Bootstrap Method는 <code class="highlighter-rouge">CallSite</code> 인스턴스를 생성하며, 이 인스턴스는 런타임에 적합한 메소드를 실행하는 역할을 한다.</li>
      <li><code class="highlighter-rouge">CallSite</code> 인스턴스에는 <code class="highlighter-rouge">MethodHandle</code>이 연결되어있고, 런타임에서 JVM에 의해 실행된다.</li>
    </ul>
  </li>
  <li>Android에서는 Java 8의 람다 표현식이나 Stream API를 쓸 수 없음. 람다 표현식을 쓰기 위한 방법은 바이트코드 레벨에서 백포팅해주는 Retrolambda를 이용할 수 있음.</li>
  <li>Stream API를 쓰는데에는 RxJava나 LightweightStream, FunctionalJava 등이 있지만 승욱님이 당시에 알아봤을 때는 RxJava가 제일 잘 맞았기 때문에 이것을 쓰게 되었음.</li>
  <li>물론 Stream API와 직접 비교를 하면 당연히 RxJava가 한참 느릴 수 밖에 없음.
    <ul>
      <li>특히 ParallelStream이 병렬적으로 처리를 하기 때문에 특히 더 빠르지만, 동시성 문제에 대해서 조심해서 사용해야함.</li>
      <li>이 ParallelStream은 Java 7에 추가된 동시성 처리를 위한 Fork/Join을 이용해서 만들어짐.</li>
    </ul>
  </li>
</ul>

<p><strong>참고자료들</strong></p>

<ul>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/MethodHandle.html</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">https://slipp.net/wiki/pages/viewpage.action?pageId=19530380</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">https://groups.google.com/forum/#!topic/ksug/wrFMOwFugwY</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">http://www.oracle.com/technetwork/articles/java/fork-join-422606.html</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html</a></li>
  <li><a href="http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use">http://stackoverflow.com/questions/24629247/where-does-official-documentation-say-that-javas-parallel-stream-operations-use</a></li>
</ul>

<h2 id="section-1">후기</h2>

<p>이번과 같이 Java의 언어 기능의 동작 원리를 알기 위해서는 언어 표준과 바이트코드까지에 대한 지식이 필요한데 개인적으로는 이렇게 깊게까지 공부해본 적이 없었기 때문에 좀 더 공부가 필요하다는 것을 많이 느꼈습니다. 개인적으로 Java 7에서 추가된 기능들이 그렇게 크지 않다고 생각했는데, 람다식과 병렬 스트림을 위해서 필요한 개념들은 Java 7에 추가되었다는 것을 보고 반성하게 되었습니다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>gdg-android-korea-rxjava-스터디-1회차</wp:post_id>
            <wp:post_date>2016-06-09 10:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[번역] 쓰기 시작하면 멈출 수 없어지는 Swift Extension 모음</title>
            <link>http://realignist.me/code/2016/06/05/swift-snippets.html</link>
            <pubDate>Sun, 05 Jun 2016 12:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/06/05/swift-snippets.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>이 글은 tattn님이 Qiita에 올린 <a href="http://qiita.com/tattn/items/647e094936287a6bd2d3">글</a>을 한국어로 번역한 글입니다. 번역을 허락해주신 tattn님께 감사합니다. Swift를 쓰면서 생산성을 높여주는 짤막한 코드들이 인상적입니다. 혹시 어떤 부분이 제일 인상적이었는지 댓글로 남겨주셔도 좋을 것 같습니다.</p>

<p>범용성 높은 Extension 집입니다. 후반에 있는 라이브러리도 정리했습니다. Swift 2.2 기준으로 확인되었습니다.</p>

<h2 id="section">클래스 이름의 표시</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">NSObject</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="k">var</span> <span class="nv">className</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">String</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">var</span> <span class="nv">className</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="k">dynamicType</span><span class="o">.</span><span class="n">className</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">MyClass</span><span class="o">.</span><span class="n">className</span>   <span class="c1">//=&gt; "MyClass"</span>
<span class="kt">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">className</span> <span class="c1">//=&gt; "MyClass"</span></code></pre></figure>

<h2 id="xib--">XIB를 등록하고 호출하기</h2>

<p>XIB 파일과 클래스 이름을 똑같이 설정한 뒤 이용해주세요. 위에서 이야기한 “클래스 이름의 표시”를 활용하고 있습니다.</p>

<h3 id="uitableview">UITableView</h3>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">UITableView</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">registerCell</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">className</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="n">className</span>
        <span class="k">let</span> <span class="nv">nib</span> <span class="o">=</span> <span class="kt">UINib</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="n">className</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="nf">registerNib</span><span class="p">(</span><span class="n">nib</span><span class="p">,</span> <span class="nv">forCellReuseIdentifier</span><span class="p">:</span> <span class="n">className</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">registerCells</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">types</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">types</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="nf">registerCell</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">dequeueCell</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="n">type</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="nv">forIndexPath</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as!</span> <span class="kt">T</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">tableView</span><span class="o">.</span><span class="nf">registerCell</span><span class="p">(</span><span class="kt">MyCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="n">tableView</span><span class="o">.</span><span class="nf">registerCells</span><span class="p">([</span><span class="kt">MyCell1</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="kt">MyCell2</span><span class="o">.</span><span class="k">self</span><span class="p">])</span>

<span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueCell</span><span class="p">(</span><span class="kt">MyCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span></code></pre></figure>

<h2 id="uicollectionview">UICollectionView</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">UICollectionView</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">registerCell</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">className</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="n">className</span>
        <span class="k">let</span> <span class="nv">nib</span> <span class="o">=</span> <span class="kt">UINib</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="n">className</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="nf">registerNib</span><span class="p">(</span><span class="n">nib</span><span class="p">,</span> <span class="nv">forCellWithReuseIdentifier</span><span class="p">:</span> <span class="n">className</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">registerCells</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">types</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">types</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="nf">registerCell</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">registerReusableView</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionReusableView</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">kind</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">UICollectionElementKindSectionHeader</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">className</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="n">className</span>
        <span class="k">let</span> <span class="nv">nib</span> <span class="o">=</span> <span class="kt">UINib</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="n">className</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="nf">registerNib</span><span class="p">(</span><span class="n">nib</span><span class="p">,</span> <span class="nv">forSupplementaryViewOfKind</span><span class="p">:</span> <span class="n">kind</span><span class="p">,</span> <span class="nv">withReuseIdentifier</span><span class="p">:</span> <span class="n">className</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">registerReusableViews</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionReusableView</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">types</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">],</span> <span class="nv">kind</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">UICollectionElementKindSectionHeader</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">types</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="nf">registerReusableView</span><span class="p">(</span><span class="nv">$0</span><span class="p">,</span> <span class="nv">kind</span><span class="p">:</span> <span class="n">kind</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">dequeueCell</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionViewCell</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">dequeueReusableCellWithReuseIdentifier</span><span class="p">(</span><span class="n">type</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="nv">forIndexPath</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as!</span> <span class="kt">T</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="n">dequeueReusableView</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">UICollectionReusableView</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">NSIndexPath</span><span class="p">,</span> <span class="nv">kind</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">UICollectionElementKindSectionHeader</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">dequeueReusableSupplementaryViewOfKind</span><span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="nv">withReuseIdentifier</span><span class="p">:</span> <span class="n">type</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="nv">forIndexPath</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span> <span class="k">as!</span> <span class="kt">T</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">collectionView</span><span class="o">.</span><span class="nf">registerCell</span><span class="p">(</span><span class="kt">MyCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="n">collectionView</span><span class="o">.</span><span class="nf">registerCells</span><span class="p">([</span><span class="kt">MyCell1</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="kt">MyCell2</span><span class="o">.</span><span class="k">self</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">collectionView</span><span class="o">.</span><span class="nf">dequeueCell</span><span class="p">(</span><span class="kt">MyCell</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>

<span class="n">collectionView</span><span class="o">.</span><span class="nf">registerReusableView</span><span class="p">(</span><span class="kt">MyReusableView</span><span class="o">.</span><span class="k">self</span><span class="p">)</span>
<span class="n">collectionView</span><span class="o">.</span><span class="nf">registerReusableViews</span><span class="p">([</span><span class="kt">MyReusableView1</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="kt">MyReusableView2</span><span class="o">.</span><span class="k">self</span><span class="p">])</span>
<span class="k">let</span> <span class="nv">view</span> <span class="o">=</span> <span class="n">collectionView</span><span class="o">.</span><span class="nf">dequeueReusableView</span><span class="p">(</span><span class="nv">type</span><span class="p">:</span> <span class="kt">MyReusableView</span><span class="o">.</span><span class="k">self</span><span class="p">,</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span></code></pre></figure>

<h2 id="nscolor-">16진수를 이용해서 NSColor 만들기</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">UIColor</span> <span class="p">{</span>
    <span class="n">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="nv">hex</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">r</span> <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">hex</span> <span class="o">&amp;</span> <span class="mh">0xFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="k">let</span> <span class="nv">g</span> <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">((</span><span class="n">hex</span> <span class="o">&amp;</span> <span class="mh">0x00FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="n">hex</span> <span class="o">&amp;</span> <span class="mh">0x0000FF</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="n">g</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="kt">CGFloat</span><span class="p">(</span><span class="n">alpha</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="kt">UIColor</span><span class="o">.</span><span class="nf">color</span><span class="p">(</span><span class="mh">0xAABBCC</span><span class="p">)</span></code></pre></figure>

<h2 id="uiviewcontroller--">제일 최상위 UIViewController 객체를 가져오기</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">UIApplication</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">topViewController</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">UIViewController</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">guard</span> <span class="k">var</span> <span class="nv">topViewController</span> <span class="o">=</span> <span class="kt">UIApplication</span><span class="o">.</span><span class="nf">sharedApplication</span><span class="p">()</span><span class="o">.</span><span class="n">keyWindow</span><span class="p">?</span><span class="o">.</span><span class="n">rootViewController</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nv">presentedViewController</span> <span class="o">=</span> <span class="n">topViewController</span><span class="o">.</span><span class="n">presentedViewController</span> <span class="p">{</span>
            <span class="n">topViewController</span> <span class="o">=</span> <span class="n">presentedViewController</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">topViewController</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">UIApplication</span><span class="o">.</span><span class="nf">sharedApplication</span><span class="p">()</span><span class="o">.</span><span class="nf">topViewController</span><span class="p">()?</span></code></pre></figure>

<h2 id="storyboard-viewcontroller-">Storyboard의 ViewController 생성하기</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">StoryBoardHelper</span> <span class="p">{}</span>

<span class="kd">extension</span> <span class="kt">StoryBoardHelper</span> <span class="k">where</span> <span class="k">Self</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">storyboard</span> <span class="o">=</span> <span class="kt">UIStoryboard</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">storyboard</span><span class="o">.</span><span class="nf">instantiateViewControllerWithIdentifier</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">className</span><span class="p">)</span> <span class="k">as!</span> <span class="k">Self</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span><span class="p">(</span><span class="nv">storyboard</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">storyboard</span> <span class="o">=</span> <span class="kt">UIStoryboard</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">storyboard</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">storyboard</span><span class="o">.</span><span class="nf">instantiateViewControllerWithIdentifier</span><span class="p">(</span><span class="k">self</span><span class="o">.</span><span class="n">className</span><span class="p">)</span> <span class="k">as!</span> <span class="k">Self</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">UIViewController</span><span class="p">:</span> <span class="kt">StoryBoardHelper</span> <span class="p">{}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">// Storyboard 파일과 클래스 이름이 같을 때</span>
<span class="kt">MyViewController</span><span class="o">.</span><span class="nf">instantiate</span><span class="p">()</span>
<span class="c1">// Storyboard 파일과 클래스 이름이 다를 때</span>
<span class="kt">MyViewController</span><span class="o">.</span><span class="nf">instantiate</span><span class="p">(</span><span class="s">"MyStoryboard"</span><span class="p">)</span></code></pre></figure>

<p>위에서 이야기한 “클래스 이름의 표시”를 활용하고 있습니다.</p>

<h2 id="xib-view-">XIB의 View를 생성</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">protocol</span> <span class="kt">NibHelper</span> <span class="p">{}</span>

<span class="kd">extension</span> <span class="kt">NibHelper</span> <span class="k">where</span> <span class="k">Self</span><span class="p">:</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">instantiate</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">nib</span> <span class="o">=</span> <span class="kt">UINib</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">className</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nib</span><span class="o">.</span><span class="nf">instantiateWithOwner</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nv">options</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">as!</span> <span class="k">Self</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">UIView</span><span class="p">:</span> <span class="kt">NibHelper</span> <span class="p">{}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">MyView</span><span class="o">.</span><span class="nf">instantiate</span><span class="p">(</span><span class="nv">owner</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span></code></pre></figure>

<p>XIB 파일과 클래스 이름을 똑같이 설정한 뒤 이용해주세요. 위에서 이야기한 “클래스 이름의 표시”를 활용하고 있습니다.</p>

<h2 id="view-">모든 자식 View를 죽이기</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">UIView</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">removeAllSubviews</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">subview</span> <span class="k">in</span> <span class="k">self</span><span class="o">.</span><span class="n">subviews</span> <span class="p">{</span>
            <span class="n">subview</span><span class="o">.</span><span class="nf">removeFromSuperview</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">view</span><span class="o">.</span><span class="nf">removeAllSubViews</span><span class="p">()</span></code></pre></figure>

<h2 id="selector-">Selector를 모으기</h2>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">private</span> <span class="kd">extension</span> <span class="kt">Selector</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">buttonTapped</span> <span class="o">=</span> <span class="kd">#selector(</span><span class="nf">MyViewController.buttonTapped(_:)</span><span class="kd">)</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">button</span> <span class="o">=</span> <span class="kt">UIButton</span><span class="p">()</span>
<span class="n">button</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="nv">action</span><span class="p">:</span> <span class="o">.</span><span class="n">buttonTapped</span><span class="p">,</span> <span class="nv">forControlEvents</span><span class="p">:</span> <span class="o">.</span><span class="kt">TouchUpInside</span><span class="p">)</span></code></pre></figure>

<h2 id="section-1">라이브러리</h2>
<p>개발을 쉽게 해주는 다용도 extension 계의 라이브러리를 정리했습니다.</p>

<h3 id="swiftdatehttpsgithubcommalcommacswiftdate"><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a></h3>

<p>NSDate를 쉽게 쓸 수  있게 만들어주는 라이브러리</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">date1</span> <span class="o">=</span> <span class="kt">NSDate</span><span class="p">(</span><span class="nv">year</span><span class="p">:</span> <span class="mi">2016</span><span class="p">,</span> <span class="nv">month</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nv">day</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="nv">hour</span><span class="p">:</span> <span class="mi">14</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">date2</span> <span class="o">=</span> <span class="s">"2016-01-05T22:10:55.200Z"</span><span class="o">.</span><span class="nf">toDate</span><span class="p">(</span><span class="kt">DateFormat</span><span class="o">.</span><span class="kt">ISO8601</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">date3</span> <span class="o">=</span> <span class="s">"22/01/2016"</span><span class="o">.</span><span class="nf">toDate</span><span class="p">(</span><span class="kt">DateFormat</span><span class="o">.</span><span class="kt">Custom</span><span class="p">(</span><span class="s">"dd/MM/yyyy"</span><span class="p">))</span>
<span class="k">let</span> <span class="nv">date4</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">2</span><span class="o">.</span><span class="n">hours</span> <span class="o">-</span> <span class="mi">15</span><span class="o">.</span><span class="n">minutes</span><span class="p">)</span><span class="o">.</span><span class="n">fromNow</span>
<span class="k">let</span> <span class="nv">date5</span> <span class="o">=</span> <span class="n">date4</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span><span class="n">years</span> <span class="o">+</span> <span class="mi">2</span><span class="o">.</span><span class="n">months</span> <span class="o">+</span> <span class="mi">1</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">2</span><span class="o">.</span><span class="n">hours</span></code></pre></figure>

<p>더 자세히 알고 싶으신 분들은 <a href="https://github.com/malcommac/SwiftDate/blob/master/Documentation/UserGuide.md">여기</a>에서.</p>

<h3 id="chameleonhttpsgithubcomviccalexanderchameleon"><a href="https://github.com/ViccAlexander/Chameleon">Chameleon</a></h3>

<p><img src="http://realignist.me/assets/images/20160605/1.png" alt="" /></p>

<p>좋은 느낌의 플랫 컬러를 제공해주는 라이브러리</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">color1</span> <span class="o">=</span> <span class="kt">UIColor</span><span class="o">.</span><span class="nf">flatGreenColorDark</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">color2</span> <span class="o">=</span> <span class="kt">FlatGreenDark</span><span class="p">()</span> <span class="c1">// 위의 축약형</span>
<span class="k">let</span> <span class="nv">color3</span> <span class="o">=</span> <span class="kt">RandomFlatColor</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">color4</span> <span class="o">=</span> <span class="kt">ComplementaryFlatColorOf</span><span class="p">(</span><span class="n">color1</span><span class="p">)</span> <span class="c1">// 보색</span>

<span class="kt">UIColor</span><span class="o">.</span><span class="nf">pinkColor</span><span class="p">()</span><span class="o">.</span><span class="nf">flatten</span><span class="p">()</span>
<span class="kt">FlatGreen</span><span class="o">.</span><span class="n">hexValue</span> <span class="c1">//=&gt; "2ecc71"</span>
<span class="kt">UIColor</span><span class="p">(</span><span class="nv">averageColorFromImage</span><span class="p">:</span> <span class="n">image</span><span class="p">)</span></code></pre></figure>

<p>컨트롤의 색을 일괄적으로 변경하는 것도 가능합니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Chameleon</span><span class="o">.</span><span class="nf">setGlobalThemeUsingPrimaryColor</span><span class="p">(</span><span class="kt">FlatBlue</span><span class="p">(),</span> <span class="nv">withSecondaryColor</span><span class="p">:</span> <span class="kt">FlatMagenta</span><span class="p">(),</span> <span class="nv">andContentStyle</span><span class="p">:</span> <span class="kt">UIContentStyle</span><span class="o">.</span><span class="kt">Contrast</span><span class="p">)</span></code></pre></figure>

<h3 id="rswifthttpsgithubcommac-cain13rswift"><a href="https://github.com/mac-cain13/R.swift">R.swift</a></h3>

<p>안드로이드의 R.java와 같이 파일 이름 등을 프로퍼티화해주는 라이브러리입니다. Typo가 컴파일 시점에 알 수 있으니 행복해집니다.</p>

<p>Before</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">icon</span> <span class="o">=</span> <span class="kt">UIImage</span><span class="p">(</span><span class="nv">named</span><span class="p">:</span> <span class="s">"settings-icon"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">font</span> <span class="o">=</span> <span class="kt">UIFont</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"San Francisco"</span><span class="p">,</span> <span class="nv">size</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">viewController</span> <span class="o">=</span> <span class="kt">CustomViewController</span><span class="p">(</span><span class="nv">nibName</span><span class="p">:</span> <span class="s">"CustomView"</span><span class="p">,</span> <span class="nv">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">string</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="nv">format</span><span class="p">:</span> <span class="kt">NSLocalizedString</span><span class="p">(</span><span class="s">"welcome.withName"</span><span class="p">,</span> <span class="nv">comment</span><span class="p">:</span> <span class="s">""</span><span class="p">),</span> <span class="nv">locale</span><span class="p">:</span> <span class="kt">NSLocale</span><span class="o">.</span><span class="nf">currentLocale</span><span class="p">(),</span> <span class="s">"Arthur Dent"</span><span class="p">)</span></code></pre></figure>

<p>After</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">icon</span> <span class="o">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="nf">settingsIcon</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">font</span> <span class="o">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="nf">sanFrancisco</span><span class="p">(</span><span class="nv">size</span><span class="p">:</span> <span class="mi">42</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">viewController</span> <span class="o">=</span> <span class="kt">CustomViewController</span><span class="p">(</span><span class="nv">nib</span><span class="p">:</span> <span class="kt">R</span><span class="o">.</span><span class="n">nib</span><span class="o">.</span><span class="n">customView</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">string</span> <span class="o">=</span> <span class="kt">R</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="n">localizable</span><span class="o">.</span><span class="nf">welcomeWithName</span><span class="p">(</span><span class="s">"Arthur Dent"</span><span class="p">)</span></code></pre></figure>

<h3 id="swiftstringhttpsgithubcomamayneswiftstring"><a href="https://github.com/amayne/SwiftString">SwiftString</a></h3>

<p>String에 편리한 메소드를 추가해주는 라이브러리입니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="s">"foobar"</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="s">"foo"</span><span class="p">)</span>         <span class="c1">//=&gt; true</span>
<span class="s">","</span><span class="o">.</span><span class="nf">join</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>                <span class="c1">//=&gt; "1,2,3"</span>
<span class="s">"hello world"</span><span class="o">.</span><span class="nf">split</span><span class="p">(</span><span class="s">" "</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>      <span class="c1">//=&gt; "world"</span>
<span class="s">"hello world"</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="mi">1</span><span class="p">]</span>             <span class="c1">//=&gt; "he"</span>
<span class="s">"hi hi ho hey hihey"</span><span class="o">.</span><span class="nf">count</span><span class="p">(</span><span class="s">"hi"</span><span class="p">)</span> <span class="c1">//=&gt; 3</span></code></pre></figure>

<h3 id="swiftyuserdefaultshttpsgithubcomradexswiftyuserdefaults"><a href="https://github.com/radex/SwiftyUserDefaults">SwiftyUserDefaults</a></h3>

<p>NSUserDefaults를 Swift스럽게 쓰게 해주는 라이브러리입니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">DefaultsKeys</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">username</span> <span class="o">=</span> <span class="kt">DefaultsKey</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">?</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"username"</span><span class="p">)</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">launchCount</span> <span class="o">=</span> <span class="kt">DefaultsKey</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"launchCount"</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 값을 가져오거나 설정하기</span>
<span class="k">let</span> <span class="nv">username</span> <span class="o">=</span> <span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">username</span><span class="p">]</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">hotkeyEnabled</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>

<span class="c1">// 값의 변경</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">launchCount</span><span class="p">]</span><span class="o">++</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">volume</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">0.1</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">strings</span><span class="p">]</span> <span class="o">+=</span> <span class="s">"… can easily be extended!"</span>

<span class="c1">// 배열의 작업</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">libraries</span><span class="p">]</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="s">"SwiftyUserDefaults"</span><span class="p">)</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">libraries</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="s">" 2.0"</span>

<span class="c1">// 커스텀 타입도 OK</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="kt">NSColor</span><span class="o">.</span><span class="nf">whiteColor</span><span class="p">()</span>
<span class="kt">Defaults</span><span class="p">[</span><span class="o">.</span><span class="n">color</span><span class="p">]?</span><span class="o">.</span><span class="n">whiteComponent</span> <span class="c1">// =&gt; 1.0</span></code></pre></figure>

<h3 id="textattributeshttpsgithubcomdelbatextattributes"><a href="https://github.com/delba/TextAttributes">TextAttributes</a></h3>

<p><img src="http://realignist.me/assets/images/20160605/2.gif" alt="" /></p>

<p>NSAttributedString를 쉽게 설정할 수 있는 라이브러리입니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">attrs</span> <span class="o">=</span> <span class="kt">TextAttributes</span><span class="p">()</span>
    <span class="o">.</span><span class="nf">font</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"HelveticaNeue"</span><span class="p">,</span> <span class="nv">size</span><span class="p">:</span> <span class="mi">16</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">foregroundColor</span><span class="p">(</span><span class="nv">white</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">.</span><span class="nf">lineHeightMultiple</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>

<span class="kt">NSAttributedString</span><span class="p">(</span><span class="s">"ほげ"</span><span class="p">,</span> <span class="nv">attributes</span><span class="p">:</span> <span class="n">attrs</span><span class="p">)</span></code></pre></figure>

<h3 id="asynchttpsgithubcomduemunkasync"><a href="https://github.com/duemunk/Async">Async</a></h3>

<p>Grand Central Dispatch (GCD)를 쉽게 쓰게 해주는 라이브러리입니다.</p>

<p>Before</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="nf">dispatch_async</span><span class="p">(</span><span class="nf">dispatch_get_global_queue</span><span class="p">(</span><span class="kt">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"This is run on the background queue"</span><span class="p">)</span>

    <span class="nf">dispatch_async</span><span class="p">(</span><span class="nf">dispatch_get_main_queue</span><span class="p">(),</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"This is run on the main queue, after the previous block"</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">})</span></code></pre></figure>

<p>After</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kt">Async</span><span class="o">.</span><span class="n">background</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"This is run on the background queue"</span><span class="p">)</span>
<span class="p">}</span><span class="o">.</span><span class="n">main</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"This is run on the main queue, after the previous block"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<h3 id="asynckithttpsgithubcommishimayasynckit"><a href="https://github.com/mishimay/AsyncKit">AsyncKit</a></h3>

<p><a href="http://qiita.com/mishimay/items/7df447969a1c38d856d8">http://qiita.com/mishimay/items/7df447969a1c38d856d8</a></p>

<p>여러 비동기 처리를 끝낸 뒤 다음 작업을 할 수 있게 도와주는 라이브러리입니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">async</span> <span class="o">=</span> <span class="kt">AsyncKit</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">NSError</span><span class="o">&gt;</span><span class="p">()</span>

<span class="n">async</span><span class="o">.</span><span class="nf">parallel</span><span class="p">([</span>
    <span class="p">{</span> <span class="n">done</span> <span class="k">in</span> <span class="nf">done</span><span class="p">(</span><span class="o">.</span><span class="kt">Success</span><span class="p">(</span><span class="s">"one"</span><span class="p">))</span> <span class="p">},</span>
    <span class="p">{</span> <span class="n">done</span> <span class="k">in</span> <span class="nf">done</span><span class="p">(</span><span class="o">.</span><span class="kt">Success</span><span class="p">(</span><span class="s">"two"</span><span class="p">))</span> <span class="p">}</span>
<span class="p">])</span> <span class="p">{</span> <span class="n">result</span> <span class="k">in</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c1">//=&gt; Success(["one", "two"])</span>
<span class="p">}</span></code></pre></figure>

]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>번역-쓰기-시작하면-멈출-수-없어지는-swift-extension-모음</wp:post_id>
            <wp:post_date>2016-06-05 12:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Samsung Portable SSD T3 짧은 리뷰</title>
            <link>http://realignist.me/gadget/2016/06/02/samsung-t3-short-review.html</link>
            <pubDate>Thu, 02 Jun 2016 11:50:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/gadget/2016/06/02/samsung-t3-short-review.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h2 id="section">사게 된 계기?</h2>
<p>프렌트립에 입사하면서 쓰게 된 장비가 iMac 4K인데, RAM도 16GB로 넉넉한 편이었지만 딱 하나 크리티컬하게 부족했던건 내장 공간이 HDD라서 빌드나 여러 작업을 할 때 느리다는 문제가 있었다. ‘그래서 외장 SSD를 내장처럼 쓰고 부팅 디스크로 쓰면 어떨까?’라는 생각이 들었고, 회사에 지원 요청을 해서 출근 첫 날 같이 셋팅할 수 있게 되었다. 개인적으로는 매일 페이스북에서 질풍기획과 같이 콜라보하던 광고가 보였는데, 매일 광고로만 보던 외장 SSD를 내가 실제로 쓰게 될 줄은 몰랐다.</p>

<h2 id="section-1">구성</h2>

<p>박스를 열어보니 아래 사진과 같이 SSD와 케이스가 도착을 했다. SSD에 가죽 케이스를 끼워야 하나 싶기도 한데, 메탈 바디와 가격이 외장하드보다 훨씬 비싸다는 것을 생각하면 충분히 납득이 될 것 같다.</p>

<p><img src="http://realignist.me/assets/images/20160601/1.jpg" alt="" /></p>

<p>우선 T3부터 살펴보자. 맥과 윈도우 모두 사용할 수 있고, 심지어는 안드로이드에서도 사용할 수 있다고 적혀있다. 내가 산 모델은 250GB 모델인데, 1TB 하드디스크와 같이 사용할걸 생각하면 꽤 괜찮은 용량이라고 생각한다. 물론 많으면 많을수록 좋지만…</p>

<p><img src="http://realignist.me/assets/images/20160601/2.jpg" alt="" /></p>

<p>포장을 벗기고 T3을 한 손으로 쥐어보았다. 한 손으로 잡히는 이 매우 작고 가벼운 외장 SSD는 확실히 외장 하드디스크보다 충분히 매력적이라고 생각한다. 윗면에 연결 단자는 USB 3.1 Type-C 형태를 쓰고 있고, 케이블로는 기존 USB(Type-A)와 연결하는 케이블을 준다. 가죽 파우치는 매우 심플하게 생겨서 뭔가 더 설명이 필요가 없을 것 같다.</p>

<p><img src="http://realignist.me/assets/images/20160601/5.jpg" alt="" /></p>

<p><img src="http://realignist.me/assets/images/20160601/4.jpg" alt="" /></p>

<h2 id="section-2">그럼 한번 실제로 써보자.</h2>

<p><img src="http://realignist.me/assets/images/20160601/6.jpg" alt="" /></p>

<p>일단 나는 데이터를 마이그레이션하기 위해 내 맥북에 외장 SSD를 연결했고, 내가 기존에 쓰던 맥북의 PCIe SSD의 파티션을 그대로 덤프했다. 덤프에 걸리는 시간은 약 7분 정도였다. 그리고 아이맥에 그대로 꽂으니 부팅이 정상적으로 작동한다. 기기의 ID가 달라졌기 때문에 상용 프로그램들은 다시 한번 인증을 해야했다.</p>

<p>과연 그러면 실제 측정 속도는 얼마나 될까? 맥에서 많이 쓰이는 Blackmagic Disk Speed Test를 통해 측정해보았다.</p>

<p><img src="http://realignist.me/assets/images/20160601/benchmark.png" alt="" /></p>

<p>읽기 속도 427MB/s, 쓰기 속도 303.9MB/s. PCIe나 NVMe m.2.같이 신형 SSD만큼 속도가 빠른건 아니지만 USB를 사용하는 TLC SSD로는 매우 만족스러운 속도가 나온다고 생각한다. 실제로 프로젝트를 빌드하거나 할 때 속도가 느리다는 생각이 들지 않게 되었다. 개인적으로는 삼성이 Thunderbolt를 이용한 전문가용 고속 외장 SSD도 만들면 어떨까라고 생각해본다.</p>

<h2 id="section-3">결론</h2>

<p>충분히 매력적인 크기와 무게, 속도까지 겸비했다. 내장 드라이브처럼 써도 괜찮을지는 좀 더 지켜보고 이야기할 수 있겠지만, 아직까지는 매우 만족스럽다. 그리고 회사에서 장비를 잘 지원해줘서 좋다. 아직 백엔드 개발자를 뽑고 있으니… 관심 있으신 분들은 언제든지 연락 주세요! (참고로 안드로이드는 제가 하고 있습니다.)</p>

<blockquote class="twitter-tweet" data-lang="ko"><p lang="ko" dir="ltr">♚♚안드로이드♚♚ §§백엔드§§ ♜개발자♜를 뽑.습.니.다. §§입사시§§전원 맥북레티나☜☜ 100% 증정※ @@최대1억원@@의 $연봉$ 즉시이동 &gt;&gt;&gt; <a href="https://t.co/S0ndG6T6XF">https://t.co/S0ndG6T6XF</a> &lt;&lt;&lt;</p>&mdash; Wanbok Choi (@wanbok) <a href="https://twitter.com/wanbok/status/734747658422607872">2016년 5월 23일</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>samsung-portable-ssd-t3-짧은-리뷰</wp:post_id>
            <wp:post_date>2016-06-02 11:50:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[번역] RxJava를 3일만에 입문해서, 안드로이드 애플리케이션의 리스트 작업이나 비동기 처리와 알림을 해결한 이야기.</title>
            <link>http://realignist.me/code/2016/05/29/rxjava-on-android.html</link>
            <pubDate>Sun, 29 May 2016 16:55:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/05/29/rxjava-on-android.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>이번 글도 <a href="http://twitter.com/yuya_presto">@yuya_presto</a>님이 쓰신 <a href="http://qiita.com/yuya_presto/items/152fa80d073d865cfc90">글</a>을 한국어로 번역한 글입니다. 일부 오역이나 의역이 있을 수 있으며 이 부분에 대해서 양해를 부탁드리며 댓글로의 지적도 환영합니다, 좋은 글을 한국어로도 번역할 수 있게 해주신 yuya_presto님께 감사하다는 말씀 드립니다.</p>

<p>Java 8과 RxJava를 최대한 활용해서 이렇게 사용할 수 있다라는걸 보여주는 좋은 예제 글인 것 같습니다. <strong>글을 읽으시고 나서 하단의 Recommend나 댓글, SNS로의 공유는 힘이 됩니다! 원작자에 대한 감사 댓글도 달아주신다면 일본어로 번역해서 전달해드릴 수 있도록 하겠습니다.</strong> Rx쪽 시리즈 글들은 시간이 나는대로 허락을 받아서 번역할 수 있도록 하겠습니다.</p>

<h2 id="section">왜 이런 글을 썼는가?</h2>

<p>지금 개발 중인 프로젝트에서 RxJava를 도입했기 때문에, 실제로 사용한 예와 찾아보지 않으면 알 수 없는 것들을 올려뒀습니다.</p>

<p>그렇게 도입(RetroLambda를 위해 JDK8도 도입)했었을 때의 장점을 이야기해도 샘플 코드가 없으면 알 수 없다는 이야기를 들어왔기 때문에 실제로 무엇이 해결되었는지, 어떤 코드로 해결했는지와 그것을 위해 공부해야만 했던 점들에 대해서 써봤습니다.</p>

<p>(+1) 경고: 만들어둔 코드에서는 해결되었습니다만, 아직 릴리즈 단계는 아니기 때문에 그 점에 충분히 유의해주세요. 변경 사항이 있으면 다시 이야기하겠습니다.</p>

<p>(+2) 릴리즈한 뒤 안정적으로 운용하고 있습니다. 최근까지 모니터링에 어려움이 있었지만 그 부분도 수정했습니다. 이 기사에 대한 모니터링 스니펫 코드도 추가해뒀습니다.</p>

<h2 id="rxjava-">왜 RxJava를 도입했는가?</h2>

<p>다음 문제들을 모두 해결해줄 수 있는게 RxJava라고 생각했고 리팩토링도 할 겸 같이 도입하게 되었습니다. (기세로 밀어붙여 죄송합니다…)</p>

<ul>
  <li>팀 내에서 안드로이드의 비동기 처리나 그 외 에러 핸들링을 처리하는게 귀찮다는 이야기가 계속 전부터 나오고 있었습니다.</li>
  <li>리스트 작업이나 람다식을 쓰는게 소스 코드의 가독성이 높은 것 같았습니다.</li>
  <li>리팩토링을 통해 데이터 소스가 변경되었을 때, 화면의 갱신을 이벤트로 처리하도록 방침을 바꿨습니다.</li>
  <li>Cookpad에서는 처음부터 리스트 작업부터 도입했다는 것 같습니다. (<a href="http://techlife.cookpad.com/entry/2015/04/17/100000">Android 개발에서 RxJava를 팀에 도입한 이야기</a>)</li>
</ul>

<p>그러나 당초 리스트 조작이나 Loader 완료 후의 상태 변경의 전달에만 사용하기로 했습니다만, <a href="http://qiita.com/ainame">@ainame</a>님이 “이런 코드라면 장점이 잘 와닿지 않는다.”라는 말을 듣고 Loader와 EventBus로 구현된 부분들을 전부 RxJava로 바꾸게 되었습니다.</p>

<h2 id="rxjava--1">RxJava의 기본</h2>

<p>Reactive Programming의 개념에 대해서는 참고용 글을 쓰는데 그쳤고, 이번 글에서는 실제 사용 예에 대해서 다뤄보도록 하겠습니다.</p>

<ul>
  <li>개념이나 익숙해지는 방법에 대해서라면 이 슬라이드를 보는게 알기 쉽습니다. (<a href="https://speakerdeck.com/sys1yagi/rxjavaxue-xi-falsehesutohurakuteisutuhoimofalse">RxJava 학습의 베스트 프랙티스같은 것들</a>)</li>
  <li><a href="http://ninjinkun.hatenablog.com/entry/introrxja">(번역) 당신이 원하고 있던 리액티브 프로그래밍 입문</a></li>
  <li><a href="http://reactivex.io/intro.html">ReactiveX의 Intro 페이지</a></li>
</ul>

<p>※ 여담입니다만, 본인은 하스켈이나 논문을 읽어본 적이 없기 때문에 Functional Reactive Programming이라는 개념에 대해서는 잘 알지 못합니다. 이 점 양해해주세요.</p>

<p>공통적인 사용법만 아래에 적어뒀습니다. 코드 샘플은 후술하도록 하겠습니다.</p>

<p><img src="http://realignist.me/assets/images/20160529/1.png" alt="" /></p>

<ul>
  <li><a href="http://reactivex.io/documentation/observable.html">Observable</a>부터 Item이 동기식으로나 비동기식으로 내려옵니다. (스트림)</li>
  <li><code class="highlighter-rouge">Observable.from(List)</code>를 사용하면, List 안에 있는 객체가 하나씩 스트림으로 내려오는 Observable를 만드는 것이 가능합니다.</li>
  <li><code class="highlighter-rouge">map()</code>이나 <code class="highlighter-rouge">filter()</code>를 시작으로 하는 <a href="http://reactivex.io/documentation/operators.html">Operator</a>를 사용하면 스트림으로 내려오는 Item을 수정할 수 있습니다.</li>
  <li>동기적으로 결과를 얻고 싶을 때에는 <code class="highlighter-rouge">toBlocking()</code>을 사용합니다.</li>
  <li><code class="highlighter-rouge">observeOn()</code>에 <a href="http://reactivex.io/documentation/scheduler.html">Scheduler</a>를 설정해두면 <code class="highlighter-rouge">subscribe()</code>의 콜백을 설정해둔 스레드(메인스레드 등…)에서 호출하는 것이 가능합니다.</li>
  <li>취소하고 싶을 때에는 <code class="highlighter-rouge">unsubscribe()</code>를 실행합니다. (다만, 적절히 구현된 Observable에만 Activity나 Fragment가 메모리 누수를 일으키지 않습니다.)</li>
</ul>

<p>메인 문서는 RxJava의 Repository에서 제공하는 Wiki를 보는 것이 좋을 것 같습니다. 작동의 확인은 <a href="http://rxmarbles.com">http://rxmarbles.com</a>이 아마 제일 편리할겁니다. 다만 RxJS로 작성되어있기 때문에, 이름이 다른 메소드 등이 존재할 수 있습니다.</p>

<h2 id="rxjava--2">현재의 과제와 RxJava로의 해결책</h2>

<p>(군데군데 <code class="highlighter-rouge">arg -&gt; process()</code>라던가 <code class="highlighter-rouge">Class::method</code>같은 표현이 나옵니다만, 이것은 Java 8에서 쓰이는 람다 표현식이기 때문에 RetroLambda를 설정하지 않은 분들은 적절한 Callback을 선언해주세요.)</p>

<h3 id="for-">리스트 처리가 아직도 for문으로 처리된다?</h3>

<p><strong>(+1) RxJava는 단순히 루프로 돌아가고 있는게 아니기 때문에, <code class="highlighter-rouge">zip()</code> 등의 일부 메소드의 처리 속도가 느린 것 같습니다. 리스트 작업을 편리하게 하기 위해서는 Java 8의 Stream API의 백포팅 라이브러리인 <a href="https://github.com/aNNiMON/Lightweight-Stream-API">Lightweight-Stream-API</a>를 추천합니다. 메소드 수는 350여가지입니다.</strong></p>

<p>Java 8부터 Lambda 식이나 Stream API를 사용해서 <code class="highlighter-rouge">map()</code>이나 <code class="highlighter-rouge">filter()</code>와 같은 Ruby, Python, Underscore.js / ECMAScript5와 비슷한 for loop를 사용하지 않은 리스트 처리가 가능해졌습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Java 7</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">otherUserNames</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">users</span><span class="o">.</span><span class="na">size</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="n">User</span> <span class="n">user</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">id</span> <span class="o">!=</span> <span class="n">selfUser</span><span class="o">.</span><span class="na">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">otherUserNames</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Java 8</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">otherUserNames</span> <span class="o">=</span> <span class="n">users</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">id</span> <span class="o">!=</span> <span class="n">selfUser</span><span class="o">.</span><span class="na">id</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">User:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span> <span class="c1">// user -&gt; user.getName()의 단순 표현, method references라고 부릅니다.</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span></code></pre></figure>

<p>new나 add 같은 절차적인 코드가 사라지고 리스트에 대한 가공만 코드에 나타나서 읽기가 쉽다! 하지만 Android에서 Java 8을 쓸 수 있는건 꽤 먼 이야기가 될 것 같습니다. <em>(역주 : Android N Preview부터는 Jack Toolchain을 이용하여 Java 8의 기능들을 사용할 수 있습니다.)</em></p>

<h4 id="rxjava--3">그거 RxJava로 되는데요…</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// RxJava</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">otherUserNames</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">users</span><span class="o">)</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">user</span> <span class="o">-&gt;</span> <span class="n">user</span><span class="o">.</span><span class="na">id</span> <span class="o">!=</span> <span class="n">selfUser</span><span class="o">.</span><span class="na">id</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">User:</span><span class="o">:</span><span class="n">getName</span><span class="o">)</span>
    <span class="o">.</span><span class="na">toList</span><span class="o">().</span><span class="na">toBlocking</span><span class="o">().</span><span class="na">single</span><span class="o">();</span> <span class="c1">// 전부 리스트로 묶어서, 동기 처리할 수 있도록 설정하고, 하나로 결과를 합칩니다.</span></code></pre></figure>

<p>비동기 처리를 전제로 하고 있기 때문에, 동기 처리로 바꾸기 위해서는 <code class="highlighter-rouge">toBlocking()</code>을 계속 호출하는게 버릇처럼 되곘지만 그 부분만 해결한다면 충분히 실용적일 것이라고 생각합니다.</p>

<p>サンプルはこの記事にいくつか載っています：Java 8: No more loopsをRxJavaでやる(Androidの環境で)</p>

<p>샘플 코드는 이 글에 몇가지 들어있습니다. (<a href="http://sys1yagi.hatenablog.com/entry/2015/01/14/141710">Java 8: No More loops를 안드로이드 환경에서 RxJava로 해보자.</a>)</p>

<h3 id="section-1">비동기 (백그라운드) 처리가 귀찮은 문제</h3>

<p>안드로이드의 프레임워크에서 백그라운드 처리를 실행하기 위해 사용하는 패턴은 주로 아래에 있는 세가지입니다. 하지만, 각자의 단점이 있습니다.</p>

<ul>
  <li><a href="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask</a>
    <ul>
      <li>실행 중에 Activity, Fragment가 Destroy되면, 특별히 노력하지 않는 한 메모리 누수가 일어나거나 크래쉬가 일어난다.</li>
      <li>특별히 cancel할 때의 처리가 어렵다.</li>
      <li>에러를 핸들링하는 부분이 귀찮다.</li>
    </ul>
  </li>
  <li><a href="http://developer.android.com/reference/android/content/AsyncTaskLoader.html">AsyncTaskLoader</a>
    <ul>
      <li>올바르게 구현하기 위한 Boilerplate가 매우 어렵다. (전에 코드를 읽을 때는 링크 출처의 공식 샘플도 잘못 구현한 것 같았다.)</li>
      <li>destroy나 화면 회전이 일어날 떄, Activity나 Fragment가 비활성화될 때 등 조건에 따라 동작이 복잡해진다.</li>
      <li>Activity나 Fragment에서밖에 쓸 수 없다.</li>
      <li>파라미터로 Bundle밖에 줄 수 없다. (그 의도는 알겠지만 마음에 들지는 않는다.)</li>
      <li>에러를 핸들링하는 부분이 귀찮다.</li>
    </ul>
  </li>
  <li><a href="http://techbooster.jpn.org/andriod/application/1570/">IntentService</a>
    <ul>
      <li>결과를 반환하는 방법이 이벤트(EventBus나 LocalBroadcast)로 한정된다.</li>
      <li>만들 때마다 AndroidManifest에서의 추가가 필요하다.</li>
    </ul>
  </li>
</ul>

<h4 id="rxjava--4">그거, RxJava로 되는데요…</h4>

<p>해결책으로 Promise를 도입하는 방법이 있습니다. RxJava의 Observable는 Promise처럼 사용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">observable</span>
    <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">result</span><span class="o">));</span></code></pre></figure>

<p>예를 들면 REST Client 라이브러리인 Retrofit은 RxJava에 대응하고 있어서, Observable를 반환하는 것이 가능합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="nd">@GET</span><span class="o">(</span><span class="s">"/users"</span><span class="o">)</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="nf">getUsers</span><span class="o">();</span>

    <span class="nd">@GET</span><span class="o">(</span><span class="s">"/users"</span><span class="o">)</span>
    <span class="n">Observable</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="nf">users</span><span class="o">();</span> <span class="c1">// Retrofit의 경우 처음부터 백그라운드 스레드에서 처리됩니다.</span>
<span class="o">}</span></code></pre></figure>

<p>이것을 이용한 실제 구현 예는 다음과 같습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserListFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Subscription</span> <span class="n">mSubscription</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Client</span> <span class="n">mClient</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">();</span>
        <span class="n">mSubscription</span> <span class="o">=</span> <span class="n">mClient</span><span class="o">.</span><span class="na">users</span><span class="o">()</span>
            <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span> <span class="c1">// 결과의 통지는 UI Thread에서 실행됩니다.</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span>                                <span class="c1">// subscribe의 타이밍에 처리가 시작되어 Callback에 결과가 보내집니다.</span>
                <span class="k">this</span><span class="o">::</span><span class="n">render</span><span class="o">,</span>                          <span class="c1">// 결과를 render 메소드에 전달합니다.</span>
                <span class="n">error</span> <span class="o">-&gt;</span> <span class="n">showErrorAlert</span><span class="o">(</span><span class="n">error</span><span class="o">),</span>        <span class="c1">// 에러가 발생할 때의 예외 처리를 지정해줍니다.（optional）</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">showCompletedAlert</span><span class="o">());</span>           <span class="c1">// 정상적으로 처리가 끝났을 때의 처리를 지정해줍니다. (optional)</span>
    <span class="o">}</span>
    <span class="c1">// ※ mainThread()는 RxAndroid의 구현을 참조할 것.</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// View가 사라지기 전에 처리가 끝나지 않았어도 unsubscript를 통해 취소하고, callback으로 넘어가지 않도록 합니다.</span>
        <span class="c1">// (Observable이 바르게 구현되어 있다면) 참조가 사라지면 Activity나 Fragment가 메모리 누수를 일으키지 않습니다.</span>
        <span class="c1">// 어느 라이프사이클에서 subscribe나 unsubscribe할지 베스트 케이스가 정해지지 않았습니다. (역주: 있으면 공유를 부탁드립니다...)</span>
        <span class="n">mSubscription</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">();</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStop</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userList</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span></code></pre></figure>

<p>이처럼 AsyncTask나 AsyncTaskLoader, IntentService를 새로 만들지 않고도 메모리 누수 없이 심플하게 코드를 작성할 수 있습니다…! 이번에는 화면 회전을 할 때 특별히 캐시를 지정하지는 않도록 결론 지은 구현입니다만, 가능하면 그 근처에서도 try해보려고 합니다.</p>

<p>※ Promise와 Observable의 큰 차이점은 여러 값을 반환할 수 있는가입니다.</p>

<p>한편, 이번에 직접 만든 <code class="highlighter-rouge">AndroidSchedulers.mainThread()</code>는 RxAndroid에서 만든 것을 이용하지 않고 제가 다시 구현한 것을 사용하고 있습니다. RxAndroid을 사용하지 않은 이유는 후술합니다.</p>

<h3 id="section-2">변경 알림 흐름을 쫓기 어려워진 문제</h3>

<p>표시할 때마다 Fragment에서 Model을 호출하는 장소에서 변경 알림 이벤트에 의한 View의 갱신을 가하면 호출의 흐름이 복잡하게 되어버립니다. 또 이것을 EventBus를 통해서 구현하면 그 이벤트가 어디서 날아오는지 명확히 알 수 없다는 문제도 존재합니다.</p>

<p><img src="http://realignist.me/assets/images/20160529/2.png" alt="" /></p>

<p>이것을 Observer 패턴을 이용하면 변경 내용이 통지될 때마다 render하는 것만으로도 괜찮아지며, 또 subscribe할 때에 Model를 참조하기 때문에 가독성이 높아집니다.</p>

<p><img src="http://realignist.me/assets/images/20160529/3.png" alt="" /></p>

<h4 id="rxjava--">그거 RxJava로… (이하 생략)</h4>

<p><strong>(+1) 원래의 구현은 타이밍에 따라 최신 상태를 받을 수 없게 되어버리는 문제와 <code class="highlighter-rouge">onBackpressureLatest()</code>가 제대로 동작하지 않았었기 때문에 <code class="highlighter-rouge">replay(1)</code>를 사용하여 다시 작성되었습니다.</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserModel</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="c1">// 통지가 올 때마다 Request를 날리기 위한 Observable을 만듭니다.</span>
    <span class="kd">private</span> <span class="n">PublishSubject</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">mUpdateNotificationPublisher</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
    <span class="kd">private</span> <span class="n">Observable</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="n">mUserUpdateObservable</span> <span class="o">=</span> <span class="n">mUpdateNotificationPublisher</span>
            <span class="o">.</span><span class="na">onBackpressureLatest</span><span class="o">()</span>            <span class="c1">// 뒤에서 처리할 수 있는 것보다 많이 오게 된다면 최근에 하나만 큐잉하고 나머지를 버립니다.</span>
            <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">aVoid</span> <span class="o">-&gt;</span> <span class="n">mClient</span><span class="o">.</span><span class="na">users</span><span class="o">(),</span> <span class="mi">1</span><span class="o">)</span>            <span class="c1">// 값이 날아 오면 Request를 던지는 Observable을 돌려 준다. flatMap은 반환된 Observable를 subscribe()한 뒤에 연결합니다. maxConcurrent를 1로 설정하게 되면 동시에 1개의 리퀘스트만 설정할 수 있게 됩니다.</span>
            <span class="o">.</span><span class="na">replay</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">refCount</span><span class="o">()</span>             <span class="c1">// 여러번 subscribe되어도 1개의 결과를 전체에 배포합니다. replay(1)는 subscribe()되었을 때 최신인 하나의 onNext()를 통과합니다. refCount()는 누군가 한명이라도 subscribe()하고 있을 때 상류의 처리를 담당합니다.</span>
            <span class="c1">// ※ publish()혹은 replay() 없이는 subscribe()한 횟수만큼 (낭비) 병렬로 Request를 날려 버립니다. 여러 번 달리는 이유는 Hot / Cold Observable의 개념에서 설명하겠습니다.</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">notifyUpdate</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mUpdateNotificationPublisher</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Observable</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="nf">observeUsers</span><span class="o">()</span> <span class="o">{</span>
				<span class="c1">// 몇번 호출되더라도 같은 Hot Observable를 subscribe() 합니다.</span>
        <span class="k">return</span> <span class="n">mUserUpdateObservable</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserListFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Subscription</span> <span class="n">mSubscription</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">UserModel</span> <span class="n">mUserModel</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStart</span><span class="o">();</span>
        <span class="n">mSubscription</span> <span class="o">=</span> <span class="n">mUserModel</span><span class="o">.</span><span class="na">observeUsers</span><span class="o">()</span>
            <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span> <span class="c1">// 결과의 통지는 UI Thread에서 실행됩니다.</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">render</span><span class="o">)</span>                   <span class="c1">// subscribe로 감시와 초기의 Request가 시작되며, 변경이 있을 때마다 render 메소드가 호출되게 됩니다.</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStop</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mSubscription</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">();</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onStop</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">render</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">userList</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span></code></pre></figure>

<p>Fragment쪽에 특별히 복잡한 처리 코드를 적지 않고서도 Reactive한 느낌이 넘치는, 변경이 마음대로 반영되는 구현이 완성되었습니다…!</p>

<p>※ 여담입니다만, 누구라도 post할 수 있는 이벤트라면 EventBus를 쓰는 것이 낫고 특정한 상대에게 이벤트를 보여주고 싶을 때에는 Observable를 쓰는 제안을 받은 적이 있습니다.</p>

<h2 id="section-3">도입하고 싶어졌다면?</h2>

<ul>
  <li><a href="https://github.com/ReactiveX/RxJava/releases">RxJava</a>: 본체
    <ul>
      <li><code class="highlighter-rouge">build.gradle</code>에 <code class="highlighter-rouge">compile 'io.reactivex:rxjava:x.xx.xx'</code> 최신 버전은 위의 링크에서 확인해주세요.</li>
    </ul>
  </li>
  <li><a href="https://github.com/evant/gradle-retrolambda">retrolambda</a>: Lambda식
    <ul>
      <li>안드로이드에서도 람다식을 쓸 수 있게 됩니다.</li>
    </ul>
  </li>
  <li><a href="https://github.com/ReactiveX/RxJavaDebug">RxJavaDebug</a>: 디버그용
    <ul>
      <li>결국 사용하지 않게 됩니다.</li>
    </ul>
  </li>
</ul>

<h2 id="section-4">나름대로 알아보지 않으면 잘 몰랐던 것들</h2>

<p>우선은 구현 예를 적어봤습니다만, 리스트 작업 이외에는 이해해야할 것들이 점점 많아집니다.</p>

<ul>
  <li>리스트 작업 : 스트림 처리, Operator, <code class="highlighter-rouge">toBlocking()</code></li>
  <li>비동기 처리 : 리스트 처리 + <code class="highlighter-rouge">subscribe()</code> + <code class="highlighter-rouge">unsubscribe()</code>, Scheduler, (필요에 따라서) Observable의 자작 방법</li>
  <li>변경 통지 : 비동기 처리 + Subject + 가능하면 Backpressure</li>
</ul>

<p>이 이후는 솔직히 처음부터 이해하려고 하면 힘든 영역이라고 생각되기 때문에, 간단한 리스트 처리부터 시작하는 편이 좋다고 생각합니다. 비동기 처리를 해보겠어…! 라고 생각한다면 다음 순서대로 해보세요.</p>

<h3 id="unsubscribe-------rxandroid----"><code class="highlighter-rouge">unsubscribe()</code>하는 것이 귀찮다. <del>한편 그것을 어떻게 하는 RxAndroid는 지금 사용할 수 없다</del>.</h3>

<p>(+1) <a href="https://github.com/trello/RxLifecycle">RxLifecycle</a>가 원래의 RxAndroid의 unsubscribe에 가깝습니다만, 위에서 쓴 것처럼 onStart()만으로도 충분했다고 생각하기 때문에 쓰고 있지 않습니다.</p>

<p><strong>(+2) subscribe/unsbuscribe 라이프 사이클에 관련해서는 별도의 Qiita 글 (<a href="http://qiita.com/yuya_presto/items/c8c3d77ac958c9c8f67b">RxJava의 자세한 설명</a>)에 지금의 견해를 적었습니다.</strong></p>

<p><code class="highlighter-rouge">subscribe()</code>에서 반환되는 Subscription을 <code class="highlighter-rouge">unsubscribe()</code> 하지 않으면 AsyncTask처럼 작업이 완료될 떄까지 Activity나 Fragment가 메모리에서 누수되어 버립니다.(일단 <code class="highlighter-rouge">onComplete()</code> 또는 <code class="highlighter-rouge">onError()</code>시 자동으로 <code class="highlighter-rouge">unsubscribe()</code> 됩니다.) 원래는 RxAndroid에서 대응할 수 있을 것이라고 생각했습니다만, 너무 커지기 때문에 불편해질 것이라는 <a href="https://github.com/ReactiveX/RxAndroid/issues/172">Jake Wharton의 의견</a>대로 지금은 그다지 사용되고 있지 않는 것 같습니다.</p>

<p>학습 코스트를 줄이기 위해도 겸해 <code class="highlighter-rouge">onCreate()</code> 등의 메소드에 <code class="highlighter-rouge">subscribe()</code>와 <code class="highlighter-rouge">unsubscribe()</code>를 직접 추가하기로 했습니다. Subscription 관리를 간단하게 하기 위해서는 <code class="highlighter-rouge">CompositeSubscription</code>에 <code class="highlighter-rouge">add()</code>한 뒤, 나중에 모아서 한꺼번에 <code class="highlighter-rouge">unsubscribe()</code>합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserListFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">CompositeSubscription</span> <span class="n">mCompositeSubscription</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Client</span> <span class="n">mClient</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">mCompositeSubscription</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompositeSubscription</span><span class="o">();</span>
        <span class="n">Subscription</span> <span class="n">subscription</span> <span class="o">=</span> <span class="n">mClient</span><span class="o">.</span><span class="na">users</span><span class="o">()</span>
            <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span>
            <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">result</span><span class="o">));</span>
        <span class="n">mCompositeSubscription</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">subscription</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">mCompositeSubscription</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">();</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span></code></pre></figure>

<p>업데이트 작업을 수행하는 경우 등 <code class="highlighter-rouge">subscribe()</code>를 여러 번 호출하는 경우가 있다고 생각 합니다만, 이 경우 작업이 완료될 때마다 매번 CompositeSubscription에서 <code class="highlighter-rouge">remove()</code>하지 않으면 점점 늘어나버립니다. 따라서 <code class="highlighter-rouge">subscribe()</code>와 <code class="highlighter-rouge">unsubscribe()</code> (혹은 종료)시에 마음대로 <code class="highlighter-rouge">CompositeObservable</code>의 <code class="highlighter-rouge">add()</code>와 <code class="highlighter-rouge">remove()</code>를 호출할 수 있는 구조를 만들었습니다. (<a href="https://gist.github.com/ypresto/accec4409654a1830f54">Gist</a>)</p>

<p><strong>(+1) 이것은 반드시 <code class="highlighter-rouge">subscribe()</code>의 맨 마지막에 호출하지 않으면 잘 unsubscribe되지 않는 경우가 있으므로 주의가 필요합니다.</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">mClient</span><span class="o">.</span><span class="na">users</span><span class="o">()</span>
    <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">())</span>
    <span class="o">.</span><span class="na">lift</span><span class="o">(</span><span class="n">CompositeObservables</span><span class="o">.</span><span class="na">attachTo</span><span class="o">(</span><span class="n">mCompositeObservable</span><span class="o">))</span> <span class="c1">// lift는 커스텀 Operator를 사용하기 위해서 쓰는 것입니다.</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">result</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">result</span><span class="o">));</span></code></pre></figure>

<p>※ CompositeSubscription는 한 번 unsubscribe하면 다시 사용할 수 없기 때문에 주의하세요. <code class="highlighter-rouge">attachTo()</code>는 <code class="highlighter-rouge">mCompositeObservable</code>을 만들고 때마다 다시 호출해야합니다. <a href="http://gfx.hatenablog.com/entry/2015/06/08/091656">http://gfx.hatenablog.com/entry/2015/06/08/091656</a></p>

<h3 id="subscribeon-observeon-scheduler---"><code class="highlighter-rouge">subscribeOn()</code>, <code class="highlighter-rouge">observeOn()</code>과 Scheduler 스레드 전환과 범위</h3>

<p><strong>(+1) 이 글을 썼을 때보다 Rx에 대한 이해가 깊어졌기 때문에 의사코드와 설명을 다른 Qiita 글(<a href="http://qiita.com/yuya_presto/items/c8c3d77ac958c9c8f67b">RxJava의 자세한 설명</a>)에 썼습니다.</strong></p>

<p>먼저 이해하는데 시간이 꽤 걸린 부분 중 하나입니다만, 실행 스레드를 전환하기 위해서 Scheduler를 사용합니다. Scheduler를 사용하면 스트림의 실행(<code class="highlighter-rouge">onNext()</code>, <code class="highlighter-rouge">onComplete()</code>, <code class="highlighter-rouge">onError()</code> 등의 호출) 스레드를 변경할 수 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">subscribeOn()</code>: <code class="highlighter-rouge">subscribe()</code>에서 실행되는 모든 스레드</li>
  <li><code class="highlighter-rouge">observeOn()</code>: 호출한 이후의 스트림을 다른 스레드에서 실행</li>
</ul>

<p><code class="highlighter-rouge">subscribeOn()</code>은 느린 메소드를를 <code class="highlighter-rouge">map()</code>과 사용자가 정의한 Observable에서 호출할 때 지정해야합니다. <a href="https://groups.google.com/d/msg/rxjava/XXJJPhn8PHQ/BJhBUNHnwtgJ">그러나 가장 소스에 가까운 <code class="highlighter-rouge">subscribeOn()</code>만 유효</a>합니다. 여러번 호출하면 스레드가 생성되는만큼 낭비라는 것. 또한 Retrofit같은 경우 <a href="https://github.com/square/retrofit/issues/830#issuecomment-98441589">처음부터 실행되는 스레드가 정해져 있는</a> 것 같아서 효과가 없는 것 같습니다. <code class="highlighter-rouge">observeOn()</code>은 View의 업데이트는 메인 스레드에서만 호출할 수 있기 때문에 비동기 요청을 했을 경우에는 <code class="highlighter-rouge">subscribe()</code> 직전에 반드시 호출해야 합니다. RxAndroid의 1.0은 AndroidSchedulers의 구현만을 포함하는 라이브러리도 존재하기 때문에 이를 사용하는 것이 좋습니다.</p>

<p>또한 문서화되지 않는 한 <code class="highlighter-rouge">subscribeOn()</code>의 지정이 없으면 <code class="highlighter-rouge">subscribe()</code> 스레드에서 실행됩니다.</p>

<p>※ Observable을 반환할 수 있는 <code class="highlighter-rouge">flatMap()</code>을 사용한 경우가 까다롭긴 하지만, 반환된 Observable에서 <code class="highlighter-rouge">subscribeOn()</code>을 호출하고 있는 경우 <code class="highlighter-rouge">onNext()</code>를 호출한 Observable에 대응하는 스레드에서 계속 처리되는 것 같습니다. <a href="https://groups.google.com/d/msg/rxjava/hVFl4YCORDQ/F-KorYBmpV0J">https://groups.google.com/d/msg/rxjava/hVFl4YCORDQ/F-KorYBmpV0J</a></p>

<h3 id="observable--">동기적 메소드를 Observable로 만드는 방법</h3>

<p><strong>(+1) 아래의 구현를 이용하면 특히 느린 처리에서 subscriber가 누출하여 결과 Activity 등이 같이 메모리에서 누출되어 버립니다. 자세한 내용은 다른 Qiita 글로 쓸 예정입니다.</strong></p>

<p>가장 간단한 방법을 하면 다음과 같이 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">new</span> <span class="n">Observable</span><span class="o">.</span><span class="na">OnSubscribe</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="n">Subscriber</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;&gt;</span> <span class="n">subscriber</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">mClient</span><span class="o">.</span><span class="na">getUsers</span><span class="o">());</span>
        <span class="n">subscriber</span><span class="o">.</span><span class="na">onCompleted</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>입니다만, 사실은 처리가 끝날 떄까지 subscriber(Activity나 Fragment 속의 Inner Class나 Lambda식 혹은 그것을 랩핑한 객체)에 대한 참조가 유지되기 때문에 AsyncTask와 마찬가지로 메모리 누수가 발생합니다. AbstractOnSubscribe를 사용하면 처음부터 <code class="highlighter-rouge">unsubscribe()</code>에 의한 취소 등을 지원하는게 가능해집니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 주의: AbstractOnSubscribe는 아직 Experimental 단계입니다.</span>
<span class="n">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">AbstractOnSubscribe</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">new</span> <span class="n">Action1</span><span class="o">&lt;</span><span class="n">AbstractOnSubscribe</span><span class="o">.</span><span class="na">SubscriptionState</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;,</span> <span class="n">Void</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="n">AbstractOnSubscribe</span><span class="o">.</span><span class="na">SubscriptionState</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">MediaFile</span><span class="o">&gt;,</span> <span class="n">Void</span><span class="o">&gt;</span> <span class="n">subscriptionState</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">subscriptionState</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getUsers</span><span class="o">());</span>
        <span class="n">subscriptionState</span><span class="o">.</span><span class="na">onCompleted</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">})).</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">io</span><span class="o">());</span> </code></pre></figure>

<p>※ [rxjava-async-util](https://github.com/ReactiveX/RxJava/wiki/를 사용하면 <code class="highlighter-rouge">AsyncObservable.start()</code>를 사용하는 것도 가능합니다만, 값이 캐싱되거나 하는 일이 있기 때문에 이번엔 사용하지 않았습니다.</p>

<h3 id="hot--cold-observable--connectable-observable--">Hot / Cold Observable 개념과 Connectable Observable이 어려운 문제</h3>

<p>또 한가지 어려웠던 것 중 하나가 Hot과 Cold라는 개념이 있었던 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Observable</span> <span class="n">mObservable</span> <span class="o">=</span> <span class="n">mClient</span><span class="o">.</span><span class="na">users</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="n">users</span> <span class="o">-&gt;</span> <span class="n">heavyMethod</span><span class="o">(</span><span class="n">users</span><span class="o">));</span>

<span class="o">...</span>

<span class="n">mObservable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">users</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">users</span><span class="o">));</span>
<span class="n">mObservable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">users</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">users</span><span class="o">));</span>
<span class="n">mObservable</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">users</span> <span class="o">-&gt;</span> <span class="n">render</span><span class="o">(</span><span class="n">users</span><span class="o">));</span></code></pre></figure>

<p>처음에는 <code class="highlighter-rouge">heavyMethod()</code>의 호출은 한번으로 끝난다고 생각해버렸습니다. 그러나 Observable은 비동기적이며 mObsercable에는 어떠한 결과도 캐싱되지 않고 <code class="highlighter-rouge">heavyMethod()</code>는 3회 호출되게 됩니다. 변경 알림을 구현하는 예에서 <code class="highlighter-rouge">share()</code>(<code class="highlighter-rouge">publish().refCount()</code>와 같음)의 호출을 하고 있었던 것은 분기의 뿌리에 처리 결과를 공유하기 때문입니다. 이처럼 분기의 뿌리가 되는 특별한 것을 Hot Observable이라고 하고, 그 이외의 일반적인 것들을 Cold Observable이라고 부릅니다. 이 부분은 <a href="http://qiita.com/toRisouP/items/f6088963037bfda658d3">“Rx의 Hot과 Cold에 대해”</a>라는 글에서 자세히 설명하고 있습니다.</p>

<p>Connectable Observable은 subscribe되면 즉시 작동이 시작해서 Hot Observable을 모두에게 <code class="highlighter-rouge">subscribe()</code>가 끝날 때까지 지연시키는 구조로, <code class="highlighter-rouge">refCount()</code>를 사용하면 누군가가 <code class="highlighter-rouge">subscribe()</code>하고 있을 때만 시작되는게 됩니다. 다음과 같은 경우가 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">publish()</code>: <code class="highlighter-rouge">subscribe()</code>하기에 앞서 이후에 도착한 것들을 내려보낸다. (Multicast）</li>
  <li><code class="highlighter-rouge">replay()</code>: <code class="highlighter-rouge">subscribe()</code>할 때마다 지금까지 도착한 item들을 전부 다시 전달합니다. (최근의 n건만 전달하는 것도 가능.)</li>
</ul>

<p>또한 Hot Observable이 시작되면 <strong>그 직전까지의 스트림을 대표하여 <code class="highlighter-rouge">subscribe()</code> 하고있는 상태</strong>가 됩니다.</p>

<h3 id="observable----subject-">Observable에 직접 값을 내리는 Subject를 사용하기</h3>

<p><code class="highlighter-rouge">Observable.from(List)</code>를 쓰면 먼저 결정한 값 밖에 스트림에 내릴 수 있습니다. 나중에 값을 바꿔서 내리고 싶다면 Subject를 사용해 <code class="highlighter-rouge">onNext()</code>을 부릅니다. Subject는 Observable이자 Callback(Subscriber)이기도 합니다.</p>

<ul>
  <li>PublishSubject
    <ul>
      <li>PublishSubject의 <code class="highlighter-rouge">onNext()</code>를 호출할 때 <code class="highlighter-rouge">subscribe()</code> 콜백에 동일한 값을 전달합니다.</li>
      <li>통지(이벤트)의 구현에 편리합니다.</li>
    </ul>
  </li>
  <li>BehaviorSubject
    <ul>
      <li><code class="highlighter-rouge">subscribe()</code>시 마지막에 <code class="highlighter-rouge">onNext()</code>된 값을 내리며, 이후 <code class="highlighter-rouge">onNext()</code>될 때마다 값을 내립니다.</li>
      <li>변경이 일어날 때 값을 표현하는 데 유용합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="backpressure-">Backpressure 개념</h3>

<p>(+1) Backpressure의 구조에 대해서는 <a href="http://qiita.com/yuya_presto/items/0e95271bc85efe7f768e">다른 글</a>를 썼습니다. 이쪽도 함께 부탁드립니다.</p>

<p>Backpressure에 대해서는 아직 공부 중입니다. ReactiveX의 intro에 나와 있는 바와 같이 Iterable는 pull(<code class="highlighter-rouge">next()</code>에서 따온), Observable은 push(<code class="highlighter-rouge">onNext()</code>에서 건너오는)입니다. push의 경우 자신이 pull하는 경우에 비해 연속 처리가 늦어질 때의 제어가 어려워집니다. 이를 제어하기 위해 얼마만큼의 <code class="highlighter-rouge">onNext()</code>가 연속으로 호출되어도 괜찮은지 소스 쪽에 전달하는 구조입니다.</p>

<p><a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">https://github.com/ReactiveX/RxJava/wiki/Backpressure</a></p>

<p>UI로 문자의 입력에 따라 처리를 호출하는 경우 등에 도움이 될 것입니다만, 그런 경우에는 일정 시간 내에 이벤트 수를 제어하는 Operator를 사용해보라고 적혀 있습니다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>번역-rxjava를-3일만에-입문해서-안드로이드-애플리케이션의-리스트-작업이나-비동기-처리와-알림을-해결한-이야기</wp:post_id>
            <wp:post_date>2016-05-29 16:55:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[번역] ButterKnife, 지금까지 고마웠어. Data Binding, 앞으로 잘 부탁해.</title>
            <link>http://realignist.me/code/2016/05/25/data-binding-guide.html</link>
            <pubDate>Wed, 25 May 2016 15:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/05/25/data-binding-guide.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>이 글은 @izumin5210님이 Qiita에 올린 <a href="http://qiita.com/izumin5210/items/2784576d86ce6b9b51e6">글</a>을 번역한 글입니다. 일부 오역이나 의역이 있을 수 있으며 이 부분에 대해서 양해를 부탁드리며, 좋은 글을 한국어로도 번역할 수 있게 해주신 izumin5210님께 감사하다는 말씀 드립니다.</p>

<h2 id="butterknife--">ButterKnife, 지금까지 고마웠어.</h2>

<p>어떤 어플리케이션의 master 브랜치에 <a href="http://jakewharton.github.io/butterknife/">ButterKnife</a>로 되어있던 부분을 없애는 Pull Request를 머지했다.</p>

<p><img src="http://realignist.me/assets/images/20160525/5.png" alt="" /></p>

<p>지금까지 ButterKnife가 하고 있던 일은 전부 <a href="http://developer.android.com/tools/data-binding/guide.html">Data Binding</a>이 대신 하게 되었다. Data Binding은 공식에서는 아직 beta release 단계에 있는 상태로, <a href="https://bintray.com/android/android-tools">거의 1.0에 가까운 RC(Release Candidate) 수준</a>까지 되었기 때문에 실전에 투입할 수 있게 되었다.</p>

<p>실행할 때에 Reflection을 하는 ButterKnife와는 달리 Data Binding은 Annotation Processing으로 사전에 이것저것 해주는 방식이 좋았다. (c.f. ButterKnife도 Annotation Processing을 하는 방식으로 바뀌는 것 같다. -&gt; <a href="https://github.com/JakeWharton/butterknife/pull/323">Split the compiler and runtime into separate artifacts. by serj-lotutovici · Pull Request #323 · JakeWharton/butterknife</a>)</p>

<p>“Data Binding으로 ButterKnife를 대체할 수 있다!”라고 말하는 사람들은 많지만 실제 사례를 별로 본 적이 없는 것 같아서 여기에 소개해두도록 하겠다.</p>

<h2 id="yet-another-butterknife-data-binding">Yet Another ButterKnife로의 Data Binding</h2>

<h3 id="view-binding">View Binding</h3>

<h4 id="before">Before</h4>

<p>아마 모두들 ButterKnife에서 제일 원하고 있는 기능, <code class="highlighter-rouge">findViewById(int id)</code>가 필요 없어지는 다음과 같은 코드</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ExampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
  <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">title</span><span class="o">)</span> <span class="n">TextView</span> <span class="n">title</span><span class="o">;</span>
  <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">subtitle</span><span class="o">)</span> <span class="n">TextView</span> <span class="n">subtitle</span><span class="o">;</span>
  <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">footer</span><span class="o">)</span> <span class="n">TextView</span> <span class="n">footer</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">simple_activity</span><span class="o">);</span>
    <span class="n">ButterKnife</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 부분은 전부 Data Binding으로 다음과 같이 바꿔서 사용할 수 있다.</p>

<h4 id="after">After</h4>

<p>레이아웃 전체를 <code class="highlighter-rouge">&lt;layout&gt;&lt;/layout&gt;</code>으로 감싸준다.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;layout&gt;</span>
  <span class="nt">&lt;LinearLayout&gt;</span>
    <span class="nt">&lt;TextView</span> <span class="na">android:id=</span><span class="s">"@+id/title"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;TextView</span> <span class="na">android:id=</span><span class="s">"@+id/subtitle"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;TextView</span> <span class="na">android:id=</span><span class="s">"@+id/footer"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/LinearLayout&gt;</span>
<span class="nt">&lt;/layout&gt;</span></code></pre></figure>

<p>이렇게 하면 <code class="highlighter-rouge">activity_sample.xml</code> 파일이라고 한다면 <code class="highlighter-rouge">ActivitySampleBinding</code>이라는 클래스가 생성된다.<code class="highlighter-rouge">DataBindingUtils.setContentView(Activity activity, int id)</code>를 통해 Binding 인스턴스를 반환하기 때문에 이 인스턴스를 유지해두면 좋다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ExampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">ActivitySampleBinding</span> <span class="n">binding</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">binding</span> <span class="o">=</span> <span class="n">DataBindingUtils</span><span class="o">.</span><span class="na">setContentView</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">simple_activity</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 Binding 인스턴스가 id로 설정된 각 View의 인스턴스를 가지고 있는걸 확인할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">text</span> <span class="o">=</span> <span class="n">binding</span><span class="o">.</span><span class="na">footer</span><span class="o">.</span><span class="na">getText</span><span class="o">();</span></code></pre></figure>

<h3 id="non-activity-binding">Non-Activity Binding</h3>

<h4 id="before-1">Before</h4>

<p>Activity 뿐만이 아니라, 예를 들면 Fragment에서의 View Binding.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FancyFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
  <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button1</span><span class="o">)</span> <span class="n">Button</span> <span class="n">button1</span><span class="o">;</span>
  <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">button2</span><span class="o">)</span> <span class="n">Button</span> <span class="n">button2</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">View</span> <span class="nf">onCreateView</span><span class="o">(</span><span class="n">LayoutInflater</span> <span class="n">inflater</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">container</span><span class="o">,</span> <span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">View</span> <span class="n">view</span> <span class="o">=</span> <span class="n">inflater</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">fancy_fragment</span><span class="o">,</span> <span class="n">container</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="n">ButterKnife</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">view</span><span class="o">);</span>
    <span class="c1">// TODO Use fields...</span>
    <span class="k">return</span> <span class="n">view</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="after-1">After</h4>

<p>생성된 Binding 클래스에 <code class="highlighter-rouge">bind(View view)</code>라는 정적 메소드가 존재하기 때문에, 그것을 이용하면 된다. 그 다음은 같다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FancyFragment</span> <span class="kd">extends</span> <span class="n">Fragment</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">FragmentFancyBinding</span> <span class="n">binding</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">View</span> <span class="nf">onCreateView</span><span class="o">(</span><span class="n">LayoutInflater</span> <span class="n">inflater</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">container</span><span class="o">,</span> <span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">inflater</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">fragment_fancy</span><span class="o">,</span> <span class="n">container</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onActivityCreated</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onActivityCreated</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">binding</span> <span class="o">=</span> <span class="n">FragmentFancyBinding</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">getView</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="view-binding-viewholder">View Binding (ViewHolder)</h3>

<h4 id="before-2">Before</h4>

<p>ButterKnife를 이용하면 <code class="highlighter-rouge">ListView</code>를 위한 <code class="highlighter-rouge">ViewHolder</code>의 구현을 쉽게 할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyAdapter</span> <span class="kd">extends</span> <span class="n">BaseAdapter</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">View</span> <span class="nf">getView</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ViewHolder</span> <span class="n">holder</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">view</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">holder</span> <span class="o">=</span> <span class="o">(</span><span class="n">ViewHolder</span><span class="o">)</span> <span class="n">view</span><span class="o">.</span><span class="na">getTag</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">view</span> <span class="o">=</span> <span class="n">inflater</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">list_item_sample</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
      <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ViewHolder</span><span class="o">(</span><span class="n">view</span><span class="o">);</span>
      <span class="n">view</span><span class="o">.</span><span class="na">setTag</span><span class="o">(</span><span class="n">holder</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">holder</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"John Doe"</span><span class="o">);</span>
    <span class="c1">// etc...</span>

    <span class="k">return</span> <span class="n">view</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ViewHolder</span> <span class="o">{</span>
    <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">title</span><span class="o">)</span> <span class="n">TextView</span> <span class="n">name</span><span class="o">;</span>
    <span class="nd">@Bind</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">job_title</span><span class="o">)</span> <span class="n">TextView</span> <span class="n">jobTitle</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ViewHolder</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ButterKnife</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">view</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="after-listview">After (ListView)</h4>

<p>Data Binding을 이용하면 Binding 클래스가 ViewHolder와 같은 방식으로 작동하므로, 원래 <code class="highlighter-rouge">ViewHolder</code>가 필요 없어진다. (<code class="highlighter-rouge">RecyclerView</code>에 대해서는 조금 다른 이야기가 되기 때문에 후술하도록 하겠다.) Data Binding을 이용하고 있으면 setter 또한 구현 되어있기 때문에 각 View에 값을 일일히 줄 필요도 없다. (Snippet 안에 있는 주석을 참조하라.)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyAdapter</span> <span class="kd">extends</span> <span class="n">BaseAdapter</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">View</span> <span class="nf">getView</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="n">View</span> <span class="n">convertView</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">parent</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">ListItemSampleBinding</span> <span class="n">binding</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">convertView</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">binding</span> <span class="o">=</span> <span class="n">DataBindingUtil</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">inflater</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">list_item_sample</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
          <span class="n">convertView</span> <span class="o">=</span> <span class="n">binding</span><span class="o">.</span><span class="na">getRoot</span><span class="o">();</span>
          <span class="n">convertView</span><span class="o">.</span><span class="na">setTag</span><span class="o">(</span><span class="n">binding</span><span class="o">);</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">binding</span> <span class="o">=</span> <span class="o">(</span><span class="n">ListItemSampleBinding</span><span class="o">)</span> <span class="n">convertView</span><span class="o">.</span><span class="na">getTag</span><span class="o">();</span>
      <span class="o">}</span>

			<span class="c1">// 예를 들면 User의 리스트라면 항목 별로 지정하는게 아니라 User의 인스턴스를 바로 지정할 수 있다.</span>
    
      <span class="n">binding</span><span class="o">.</span><span class="na">setUser</span><span class="o">(</span><span class="n">getItem</span><span class="o">(</span><span class="n">position</span><span class="o">));</span>
      <span class="c1">// binding.name.setText("John Doe");</span>

      <span class="k">return</span> <span class="n">convertView</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="after-recyclerview">After (RecyclerView)</h4>

<p><code class="highlighter-rouge">RecyclerView</code>같은 경우에는 <code class="highlighter-rouge">RecyclerView.ViewHolder</code>가 필수가 된다. 이 ViewHolder에 BindingHolder같은 이름을 붙이고 Binding 클래스와 연결해주도록 하면 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleRecyclerAdapter</span> <span class="kd">extends</span> <span class="n">RecyclerView</span><span class="o">.</span><span class="na">Adapter</span><span class="o">&lt;</span><span class="n">SampleRecyclerAdapter</span><span class="o">.</span><span class="na">BindingHolder</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">RegisterableDeviceListAdapter</span><span class="o">.</span><span class="na">ViewHolder</span> <span class="nf">onCreateViewHolder</span><span class="o">(</span><span class="n">ViewGroup</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">viewType</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="n">View</span> <span class="n">v</span> <span class="o">=</span> <span class="n">LayoutInflater</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">parent</span><span class="o">.</span><span class="na">getContext</span><span class="o">()).</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">list_item_sample</span><span class="o">,</span> <span class="n">parent</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">BindingHolder</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onBindViewHolder</span><span class="o">(</span><span class="n">BindingHolder</span> <span class="n">holder</span><span class="o">,</span> <span class="kt">int</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// BindingHolder#getBinding()がViewDataBindingを返すのでsetVariable()を呼んでいる</span>
    <span class="c1">// 専用のBinding（この場合だとListItemSampleBinding）を返すことが出来るなら普通にsetUser()でOK</span>
    <span class="n">holder</span><span class="o">.</span><span class="na">getBinding</span><span class="o">().</span><span class="na">setVariable</span><span class="o">(</span><span class="n">BR</span><span class="o">.</span><span class="na">user</span><span class="o">,</span> <span class="n">getItem</span><span class="o">(</span><span class="n">position</span><span class="o">));</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">BindingHolder</span> <span class="kd">extends</span> <span class="n">RecyclerView</span><span class="o">.</span><span class="na">ViewHolder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ViewDataBinding</span> <span class="n">binding</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BindingHolder</span><span class="o">(</span><span class="n">View</span> <span class="n">itemView</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">super</span><span class="o">(</span><span class="n">itemView</span><span class="o">);</span>
      <span class="n">binding</span> <span class="o">=</span> <span class="n">DataBindingUtil</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="n">itemView</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">ViewDataBinding</span> <span class="nf">getBinding</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">binding</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="listener-binding-onclick">Listener Binding (onClick)</h3>

<h4 id="before-3">Before</h4>

<p><code class="highlighter-rouge">@OnClick</code>이나 <code class="highlighter-rouge">@OnItemClick</code> 등의 어노테이션을 사용하는걸 통해 <code class="highlighter-rouge">setOnClickListener()</code>를 지정해주는 것과 비슷한 것을 할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@OnClick</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">submit</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">submit</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// TODO submit data to server...</span>
<span class="o">}</span></code></pre></figure>

<h4 id="after-2">After</h4>

<p>레이아웃에 Activity의 인스턴스를 지정해주고, <code class="highlighter-rouge">Button</code>의 <code class="highlighter-rouge">android:onClick</code> 항목에 Listener 메소드를 지정해준다.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;layout&gt;</span>
  <span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;variable</span> <span class="na">name=</span><span class="s">"activity"</span> <span class="na">type=</span><span class="s">"info.izumin.android.databindingsample.SampleActivity"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/data&gt;</span>
  <span class="nt">&lt;LinearLayout&gt;</span>
    <span class="nt">&lt;Button</span> <span class="na">android:onClick=</span><span class="s">"@{activity.onSampleButtonClick}"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/LinearLayout&gt;</span>
<span class="nt">&lt;/layout&gt;</span></code></pre></figure>

<p>Activity의 <code class="highlighter-rouge">onCreate()</code>에서는 Binding 인스턴스에 Activity의 인스턴스를 지정해주면 그 이후에는 편하게 사용할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">SampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">ActivitySampleBinding</span> <span class="n">binding</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
    <span class="n">binding</span> <span class="o">=</span> <span class="n">DataBindingUtils</span><span class="o">.</span><span class="na">setContentView</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">simple_activity</span><span class="o">);</span>
    <span class="n">binding</span><span class="o">.</span><span class="na">setActivity</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSampleButtonClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// do something...</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>다만, 앞의 예제의 Activity는 Layout를 참고하고 있으며 Layout은 Activity를 참조하고 있는 것처럼 완전히 서로 결합되는 구조가 된다. 이것이 싫다면 이벤트 처리만을 담당하는 Interface를 만들어주면 좋다. 이제 느슨하게 서로 연결되는 구조가 실현된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SampleActivityHandlers</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">onSampleButtonClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p><a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture</a>에서 이야기하는 Controller에 해당될려나?</p>

<h3 id="data-binding--">그 외 Data Binding의 편리한 기능들</h3>

<h4 id="listener-bindings">Listener Bindings</h4>

<p>Data Binding은 <code class="highlighter-rouge">@BindingAdapter</code>나 <code class="highlighter-rouge">@BindingMethod</code>라고 하는 어노테이션을 이용한 어노테이션 프로세싱을 통해 <code class="highlighter-rouge">OnClickListener</code> 이외의 Event Listener도 설정할 수 있다.</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;Button</span> <span class="na">android:onClick=</span><span class="s">"@{handlers.onPrevButtonClick}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;Button</span> <span class="na">android:onClick=</span><span class="s">"@{handlers.onNextButtonClick}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;EditText</span> <span class="na">android:onTextChanged=</span><span class="s">"@{handlers.onTextChanged}"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;ListView</span> <span class="na">android:onScroll=</span><span class="s">"@{handlers.onScroll}"</span> <span class="nt">/&gt;</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SampleActivityHandlers</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">onPrevButtonClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">onNextButtonClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">onTextChanged</span><span class="o">(</span><span class="n">CharSequence</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">before</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">onScroll</span><span class="o">(</span><span class="n">AbsListView</span> <span class="n">view</span><span class="o">,</span> <span class="kt">int</span> <span class="n">firstVisibleItem</span><span class="o">,</span> <span class="kt">int</span> <span class="n">visibleItemCount</span><span class="o">,</span> <span class="kt">int</span> <span class="n">totalItemCount</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>표준으로 제공하는 Adapter에 대해서는 <a href="https://android.googlesource.com/platform/frameworks/data-binding/+/android-6.0.0_r7/extensions/baseAdapters/src/main/java/android/databinding/adapters">extensions/baseAdapters/…/data-binding/</a>에 있는 파일을 참조하길 바란다.</p>

<h4 id="adapter-binding">Adapter Binding</h4>

<p><code class="highlighter-rouge">@BindingAdapter</code> 및 <code class="highlighter-rouge">@BindingMethod</code>의 악용 사례</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@BindingMethods</span><span class="o">({</span>
    <span class="nd">@BindingMethod</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="n">SwipeRefreshLayout</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">attribute</span> <span class="o">=</span> <span class="s">"android:onRefresh"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">"setOnRefreshListener"</span><span class="o">),</span>
    <span class="nd">@BindingMethod</span><span class="o">(</span><span class="n">type</span> <span class="o">=</span> <span class="n">RecyclerView</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">attribute</span> <span class="o">=</span> <span class="s">"android:adapter"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s">"setAdapter"</span><span class="o">)</span>
<span class="o">})</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ViewBindingUtils</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SampleActivityHandlers</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">onRefresh</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;layout&gt;</span>
  <span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;variable</span> <span class="na">name=</span><span class="s">"handlers"</span>
      <span class="na">type=</span><span class="s">"info.izumin.android.databindingsample.SampleActivityHandlers"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;variable</span> <span class="na">name=</span><span class="s">"adapter"</span>
      <span class="na">type=</span><span class="s">"android.support.v7.widget.RecyclerView.Adapter"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/data&gt;</span>
  <span class="nt">&lt;android.support.v4.widget.SwipeRefreshLayout</span>
    <span class="na">android:onRefresh=</span><span class="s">"@{handlers.onRefresh}"</span> <span class="nt">&gt;</span>

    <span class="nt">&lt;android.support.v7.widget.RecyclerView</span>
      <span class="na">android:adapter=</span><span class="s">"@{adapter}"</span> <span class="nt">/&gt;</span>

  <span class="nt">&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;</span>
<span class="nt">&lt;/layout&gt;</span></code></pre></figure>

<p>이렇게까지 해야할 필요성이 있는지 모르겠다.</p>

<h4 id="image-source-binding">Image Source Binding</h4>

<p>“어떤 값에 따라 표시하는 이미지를 바꿀 수 없을까?”같은 것도 <code class="highlighter-rouge">BindingAdapter</code>를 이용하면 쉽게 할 수 있다. 정적 메소드이기 때문에 테스트도 편하게 할 수 있지 않을까?</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ViewBindingUtils</span> <span class="o">{</span>
  <span class="nd">@BindingAdapter</span><span class="o">(</span><span class="s">"signalStrength"</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSignalStrengthIcon</span><span class="o">(</span><span class="n">ImageView</span> <span class="n">imageView</span><span class="o">,</span> <span class="n">BluetoothDevice</span> <span class="n">device</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">resId</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="na">mipmap</span><span class="o">.</span><span class="na">ic_signal_weak</span><span class="o">;</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">rssi</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="na">getRssi</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rssi</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">40</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">resId</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="na">mipmap</span><span class="o">.</span><span class="na">ic_signal_strong</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">rssi</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">40</span> <span class="o">&amp;&amp;</span> <span class="n">rssi</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">60</span><span class="o">){</span>
      <span class="n">resId</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="na">mipmap</span><span class="o">.</span><span class="na">ic_signal_medium</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">imageView</span><span class="o">.</span><span class="na">setImageResource</span><span class="o">(</span><span class="n">resId</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><span class="nt">&lt;layout&gt;</span>
  <span class="nt">&lt;data&gt;</span>
    <span class="nt">&lt;variable</span> <span class="na">name=</span><span class="s">"device"</span> <span class="na">type=</span><span class="s">"android.bluetooth.BluetoothDevice"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/data&gt;</span>
  <span class="nt">&lt;LinearLayout&gt;</span>
    <span class="nt">&lt;ImageView</span> <span class="na">app:signalStrength=</span><span class="s">"@{device}"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;TextView</span> <span class="na">android:text=</span><span class="s">"@{device.getName()}"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;TextView</span> <span class="na">android:text=</span><span class="s">"@{device.getAddress()}"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/LinearLayout&gt;</span>
<span class="nt">&lt;/layout&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">BindingAdapter</code>로 namespace를 쓰지 않는 것(<code class="highlighter-rouge">app</code>)과, <code class="highlighter-rouge">android</code>를 쓰는 것 중 어느 쪽이 좋은가요?</p>

<h4 id="data-binding-on-custom-view">Data Binding on Custom View</h4>

<p>당연하게도 Data Binding은 Custom View에서도 쓸 수 있다. <code class="highlighter-rouge">@BindingAdapter</code>를 잘못 사용하면 <code class="highlighter-rouge">attrs.xml</code>을 쓰고 <code class="highlighter-rouge">TypedArray</code>에서 Custom Attrs를 얻는 등의 일을 쉽게 할 수 있다. <del>그게 좋은지 나쁜지는 다른 문제로 두고</del>.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pagination</span> <span class="kd">extends</span> <span class="n">RelativeLayout</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="n">ViewPaginationBinding</span> <span class="n">binding</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">Pagination</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nf">Pagination</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">AttributeSet</span> <span class="n">attrs</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">attrs</span><span class="o">);</span>
    <span class="n">binding</span> <span class="o">=</span> <span class="n">DataBindingUtil</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">LayoutInflater</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">context</span><span class="o">),</span> <span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">view_pagination</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setListener</span><span class="o">(</span><span class="n">Pagination</span> <span class="n">paginate</span><span class="o">,</span> <span class="n">View</span> <span class="n">target</span><span class="o">,</span> <span class="n">OnPaginationClickListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">listener</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">target</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="n">_v</span> <span class="o">-&gt;</span> <span class="n">listener</span><span class="o">.</span><span class="na">onClick</span><span class="o">(</span><span class="n">paginate</span><span class="o">));</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@BindingAdapter</span><span class="o">({</span><span class="s">"android:onPrevButtonClicked"</span><span class="o">})</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPrevClickListener</span><span class="o">(</span><span class="n">Pagination</span> <span class="n">view</span><span class="o">,</span> <span class="n">OnPaginationClickListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setListener</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="n">view</span><span class="o">.</span><span class="na">binding</span><span class="o">.</span><span class="na">btnPrevPage</span><span class="o">,</span> <span class="n">listener</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@BindingAdapter</span><span class="o">({</span><span class="s">"android:onNextButtonClicked"</span><span class="o">})</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setNextClickListener</span><span class="o">(</span><span class="n">Pagination</span> <span class="n">view</span><span class="o">,</span> <span class="n">OnPaginationClickListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setListener</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="n">view</span><span class="o">.</span><span class="na">binding</span><span class="o">.</span><span class="na">btnNextPage</span><span class="o">,</span> <span class="n">listener</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OnPaginationClickListener</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">Pagination</span> <span class="n">pagination</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="butterknife-data-binding----">ButterKnife에서 Data Binding으로 대체할 수 없는 기능들</h3>

<h4 id="resource-binding">Resource Binding</h4>

<p>이 기능은 Data Binding에는 존재하지 않는다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">ExampleActivity</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="o">{</span>
  <span class="nd">@BindString</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">string</span><span class="o">.</span><span class="na">title</span><span class="o">)</span> <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
  <span class="nd">@BindDrawable</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">graphic</span><span class="o">)</span> <span class="n">Drawable</span> <span class="n">graphic</span><span class="o">;</span>
  <span class="nd">@BindColor</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">color</span><span class="o">.</span><span class="na">red</span><span class="o">)</span> <span class="kt">int</span> <span class="n">red</span><span class="o">;</span> <span class="c1">// int or ColorStateList field</span>
  <span class="nd">@BindDimen</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">dimen</span><span class="o">.</span><span class="na">spacer</span><span class="o">)</span> <span class="n">Float</span> <span class="n">spacer</span><span class="o">;</span> <span class="c1">// int (for pixel size) or float (for exact value) field</span>
  <span class="c1">// ...</span>
<span class="o">}</span></code></pre></figure>

<h4 id="view-lists">View Lists</h4>

<p>View Lists는 여러 View를 한 곳에 모아 처리하는 기능 같다. <del>이 글을 쓸 때 처음 안 기능이다</del>.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 이렇게 해서…</span>
<span class="nd">@Bind</span><span class="o">({</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">first_name</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">middle_name</span><span class="o">,</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">last_name</span> <span class="o">})</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">EditText</span><span class="o">&gt;</span> <span class="n">nameViews</span><span class="o">;</span>

<span class="c1">// 이런 것들을 준비해주면…</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="n">ButterKnife</span><span class="o">.</span><span class="na">Action</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;</span> <span class="n">DISABLE</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ButterKnife</span><span class="o">.</span><span class="na">Action</span><span class="o">&lt;</span><span class="n">View</span><span class="o">&gt;()</span> <span class="o">{</span>
  <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">apply</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">view</span><span class="o">.</span><span class="na">setEnabled</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">};</span>

<span class="c1">// 이런 느낌으로 한번에 쓸 수 있다！</span>
<span class="n">ButterKnife</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">nameViews</span><span class="o">,</span> <span class="n">DISABLE</span><span class="o">);</span></code></pre></figure>

<p>이것도 Data Binding에서는 존재하지 않는다.</p>

<h2 id="section">정리</h2>
<ul>
  <li>ButterKnife의 기능은 대체로 Data Binding으로 대체할 수 있다.
    <ul>
      <li>Resource Binding, View Lists만 Data Binding에서 대체 불가</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">ViewHolder</code> 패턴은 모두 대체할 수 있다.
    <ul>
      <li><code class="highlighter-rouge">RecyclerView.ViewHolder</code>는 Binding의 Wrapper로 감싸주면 OK</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">@BindingAdapter</code>와 <code class="highlighter-rouge">@BindingMethod</code>를 <del>악용</del>이용하면 비교적 뭐든지 할 수 있다.</li>
</ul>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://jakewharton.github.io/butterknife/">ButterKnife</a></li>
  <li><a href="http://developer.android.com/tools/data-binding/guide.html">Data Binding Guide - Android Developers</a></li>
  <li><a href="http://tech.recruit-mp.co.jp/mobile/android-data-binding/">Android – Data Binding 연결해봤다. – NET BIZ DIV. TECH BLOG</a></li>
  <li><a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture - 8th Light</a></li>
  <li><a href="https://android.googlesource.com/platform/frameworks/data-binding/+/android-6.0.0_r7/extensions/baseAdapters/src/main/java/android/databinding/adapters">extensions/baseAdapters/src/main/java/android/databinding/adapters - platform/frameworks/data-binding - Git at Google</a></li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>번역-butterknife-지금까지-고마웠어-data-binding-앞으로-잘-부탁해</wp:post_id>
            <wp:post_date>2016-05-25 15:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[번역] 중급 이상의 Android 개발자가 Android다운 개발을 하려면 봐야할 URL 목록들</title>
            <link>http://realignist.me/code/2016/05/25/better-android-developer-guide.html</link>
            <pubDate>Wed, 25 May 2016 02:30:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/05/25/better-android-developer-guide.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>이 글은 <a href="http://twitter.com/yuya_presto">@yuya_presto</a>님이 쓰신 <a href="http://qiita.com/yuya_presto/items/ab2162078e5d5076c718">글</a>을 한국어로 번역한 글입니다. 일부 오역이나 의역이 있을 수 있으며 이 부분에 대해서 양해를 부탁드리며, 좋은 글을 한국어로도 번역할 수 있게 해주신 yuya_presto님께 감사하다는 말씀 드립니다.</p>

<p>사실 글에서는 <em>중급 이상의</em>라는 말이 들어가지만, 안드로이드 애플리케이션을 개발하는 개발자라면 꼭 알아둬야할 개념들에 대해서 이야기하는 글이라고 생각합니다.</p>

<hr />

<p>Java에 대한 이야기는 여러 이야기가 있다고 생각합니다만, Android 개발을 잘 하기 위해서 어떤 것들을 해야 좋을지에 대한 이야기를 해보고자 합니다. 개발 입문을 위한 가이드로는 이미 <a href="https://github.com/mixi-inc/AndroidTraining">좋은 가이드</a>(일본어)가 있기 때문에 여기서는 더욱 실전적인 내용에 포커스를 맞추고자 합니다.</p>

<h2 id="section">안드로이드 다운 디자인과 개발</h2>

<h3 id="material-design-">Material Design의 가이드라인</h3>

<p>Google이 생각한 최고(?)의 디자인 가이드라인, 그것이 머티리얼 디자인입니다.<br />
<a href="https://www.google.com/design/spec/material-design/introduction.html">https://www.google.com/design/spec/material-design/introduction.html</a></p>

<p>사용해야할 UI 컴포넌트, ListView 등의 레이아웃, 다이얼로그를 띄울 타이밍과 표시할 내용, 화면 전환 시의 애니메이션과 사용 방법 등에 대한 설명이 다양하게 적혀있습니다. 이 내용에 따라 개발하면 상당히 현대적인 Android 앱으로 보이게 됩니다. 사용하려고 마음 먹은 UI 컴포넌트에 대해 조사하는 것만으로도 꽤 큰 효과를 발휘합니다.</p>

<p><img src="http://realignist.me/assets/images/20160525/1.png" alt="" /></p>

<p>※ 여담입니다만, iOS를 하는 사람들에게는 iOS Human Interface Guidelines가 필수 요소라고 생각합니다.</p>

<h3 id="section-1">생명 주기</h3>

<p>안드로이드 애플리케이션을 개발하는 것은 Java 언어를 마스터하는 것보다도 생명 주기를 마스터해야하는 일이라는 말을 스터디 등에서 나오고 있습니다. 안드로이드 개발이라고 하면 그 생명 주기를 제대로 생각하고 개발하는 것이 중요합니다.</p>

<p><a href="http://developer.android.com/intl/ja/training/basics/activity-lifecycle/index.html">공식 문서의 입문편</a>에서는 재개, 일시 정지, 정지 등의 3가지 상태밖에 나오지 않지만 실제로는 엄청나게 큰 생명 주기 메소드의 호출도 있는 것입니다. (특히 Fragment가 얽혀있는 경우 더 복잡해지겠죠.)</p>

<p>그에 대한 정리가 다음 <a href="https://github.com/xxv/android-lifecycle">Repository</a>에 올라와있습니다. (CC-BY-SA 4.0)</p>

<p><img src="http://realignist.me/assets/images/20160525/2.png" alt="" /></p>

<p>※ 여담입니다만, Android N에서 멀티윈도우가 지원되면서 onPause()와 onStop()에 대한 개념이 약간 미묘하게 복잡하게 변할 수도 있기 때문에 이 부분은 주의할 필요가 있다고 생각합니다.</p>

<h3 id="section-2">백 스택과 태스크</h3>

<p><code class="highlighter-rouge">startActivity()</code>한 후 백 버튼의 동작을 제어하는 것이 백 스택과 태스크입니다. 백 버튼 뿐만이 아니라 작업 스위처(멀티태스킹 화면)에 표시해야할 내용(예를 들면 외부 메일 앱을 실행했을 때, 작업 스위처에 메일 응용 프로그램을 표시할지 여부 등…)도 주의 깊게 생각할 필요가 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Android 개발자라면 누구나 백 스택과 태스크에 대해서 설명할 수 있고, AndroidManifest.xml에 나오는 launchMode의 차이점에 대해서 설명할 수 있겠지요?
</code></pre>
</div>

<p>라는 말을 하는 것은 정작 <a href="http://developer.android.com/intl/ja/guide/components/tasks-and-back-stack.html">공식 문서</a>뿐이었고, 실제 동작의 차이를 몰라서 괴로워합니다. 저는 다음 사이트를 참고해서 마침내 어떻게 돌아가는지 이해할 수 있게 되었습니다.</p>

<ul>
  <li><a href="http://techblog.qoncept.jp/?p=102">그림으로 이해하는 액티비티 스택 (Qoncept TechBlog)</a> (일본어)</li>
  <li><a href="http://y-anz-m.blogspot.jp/2011/02/androidlauchmode.html">Y.A.M의 잡동사니 메모장: Android launchMode의 차이</a> (일본어)</li>
</ul>

<p>아래 그림은 “그림으로 이해하는 액티비티 스택”에서 인용한 것입니다. 그림이 매우 알기 쉬웠습니다.</p>

<p><img src="http://realignist.me/assets/images/20160525/3.png" alt="" /></p>

<p>※ 사실은 “taskAffinity”에 대해서도 알아야한다고 생각하지만, 저는 아직 이 부분에 대해서 확실하게 이해하지 못하고 있습니다.</p>

<h3 id="up-">Up 내비게이션</h3>

<p>안드로이드 개발자라면 백 버튼과 왼쪽 상단의 “Up 버튼”이 어떻게 다른지 설명할 수 있죠? Up 버튼은 전에 표시된 화면으로 되돌아가는 것이 아니라 “상위 개념”으로 이동해야만 합니다. Up 내비게이션은 간과하기 쉬운 구조이므로 화면 전환이 많은 프로그램에서는 꼭 짚고 넘어가야한다고 생각합니다.</p>

<p><a href="http://developer.android.com/intl/ko/design/patterns/navigation.html">http://developer.android.com/intl/ko/design/patterns/navigation.html</a></p>

<p><img src="http://realignist.me/assets/images/20160525/4.png" alt="" /></p>

<p>구현 방법은 <a href="http://developer.android.com/intl/ko/training/implementing-navigation/ancestral.html">여기</a>서 확인할 수 있습니다.</p>

<h3 id="section-3">결론</h3>

<p><a href="http://developer.android.com/intl/ko/index.html">http://developer.android.com/intl/ko/index.html</a>에 있는 정보는 API 레퍼런스를 포함해서 꽤 중요한 자료들이 많기 때문에, 시간이 있을 때 읽어두는 편이 좋습니다.</p>

<h2 id="section-4">태블릿과 화면 회전에 대응</h2>

<p>Android는 iOS와는 다르게 AndroidManifest.xml에서 “이 앱은 태블릿용 애플리케이션입니다.”라고 선언하지 않아도 보통 태블릿에서 사용할 수 있도록 되어있습니다. 하지만 Google Play 스토어를 보면 “이 애플리케이션은 태블릿용으로 설계되었습니다.”라고 되어있지 않으면 랭킹에 올라가지 않는 등의 문제가 있습니다.</p>

<p>사실 이것은 옛날에는 태블릿용 스크린샷을 등록하는 것만으로도 괜찮았지만, 최근에는 사람이 직접 레이아웃을 일일히 체크하는 것 같습니다.</p>

<p>Fragment의 사용 방법</p>

<p><a href="http://developer.android.com/intl/ko/guide/practices/tablets-and-handsets.html#Fragments">http://developer.android.com/intl/ko/guide/practices/tablets-and-handsets.html#Fragments</a></p>

<p><a href="http://qiita.com/HideMatsu/items/ddf640899cbe1b2027ed">http://qiita.com/HideMatsu/items/ddf640899cbe1b2027ed</a> (일본어)</p>

<h2 id="section-5">좀 더 테크니컬한 이야기</h2>

<h3 id="support-library---">Support Library의 최신 변경 사항</h3>

<p>Android에서는 처음부터 사용 가능한 Fragment와 Support Library 안에 있는 Fragment로 Fragment 구현이 두가지가 있었는데, Google 직원분께서 하신 말로는 최신 기능과 버그 수정을 위해 항상 Support Library의 구현을 쓰는 것을 권장한다는 이야기를 듣고(DroidKaigi 2016 2일차 기조연설에서) Support Library의 구현체를 반드시 사용해야 한다고 생각하게 되었습니다.</p>

<p>하지만, 버전 업으로 인하여 사양이 변경되는 일(메소드가 없어지거나)이 있을 수가 있어 주의가 필요합니다. Android Studio가 업데이트를 하라고 노란색 밑줄을 표시하고 있지만, 꾹 참으시고 우선 아래 페이지에서 어떤 사항이 바뀌었는지를 체크하고 업데이트하는 것이 바람직합니다.</p>

<p><a href="http://developer.android.com/intl/ko/tools/support-library/index.html">http://developer.android.com/intl/ko/tools/support-library/index.html</a></p>

<h3 id="android-framework-api-diff">Android Framework의 API Diff</h3>

<p>Android의 compileSdkVersion을 올리면 메소드가 사라지는 일이 발생합니다. 최근같은 경우 Notification.Builder의 serLatestEventInfo() 메소드(API 23)가 없어져서 <a href="http://stackoverflow.com/questions/32345768/cannot-resolve-method-setlatesteventinfo">한바탕 소동</a>이 일어났습니다.</p>

<p>Google이 Android API Differences Report를 내고 있기 때문에 이걸 보면 각 버전에서 어떤 인터페이스가 바뀌었는지 확인할 수 있습니다.
<a href="http://qiita.com/takahirom/items/b46afb73a5c8429d8675">http://qiita.com/takahirom/items/b46afb73a5c8429d8675</a> (일본어)</p>

<h3 id="section-6">편리한 라이브러리 목록</h3>
<ul>
  <li><a href="https://github.com/wasabeef/awesome-android-ui">wasabeef/awesome-android-ui</a> ← UI 라이브러리 목록은 정말 편리합니다.</li>
  <li><a href="http://qiita.com/KeithYokoma/items/b5b53c94f6ab27b604e7">http://qiita.com/KeithYokoma/items/b5b53c94f6ab27b604e7</a></li>
</ul>

<p>이거 외에도 Qiita에 글이 많이 올라와있습니다.</p>

<h3 id="section-7">라이브러리를 도입할 때 유용한 사이트</h3>

<p>대부분의 라이브러리는 GitHub의 README.md에 적혀져 있습니다만, 우선 build.gradle에 무엇을 추가하면 좋을지를 찾으려면 <a href="http://mvnrepository.com">http://mvnrepository.com</a>이 편리합니다. 일부 라이브러리는 Maven Central 대신 jCenter에만 업로드 되는 것이 있기 때문에 이런 라이브러리는 <a href="https://bintray.com/bintray/jcenter">bintray</a>에서 찾지 않으면 안됩니다.</p>

<p>그렇다고 해서, 뭐든 좋다고 휙휙 쓸 수 있는게 아니라 넣으면 넣을수록 빌드 시간이 길어집니다. <a href="http://methodscount.com">http://methodscount.com</a>을 사용하면 build.gradle을 복사해서 붙여넣으면 라이브러리의 크기와 메소드의 수를 알려줍니다. (Android Studio 플러그인도 있습니다!)</p>

<p>여담이지만, <a href="https://github.com/novoda/bintray-release">bintray-release</a>를 사용하면 jCenter 라이브러리를 몇 번의 클릭으로 공개할 수 있으므로 꼭 공개하고 갑시다.</p>

<h2 id="section-8">어찌됬던 일단 소스 코드를 읽는다.</h2>

<blockquote class="twitter-tweet" data-lang="ko"><p lang="en" dir="ltr">Android development is about 10% writing Java. The other 90% is reading, crying, debugging, and pressing alt+enter</p>&mdash; Jon F Hancock (@JonFHancock) <a href="https://twitter.com/JonFHancock/status/702973001600364544">2016년 2월 25일</a></blockquote>
<script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>울며 겨자먹기로 코드를 읽고, Alt + Enter를 연타하는 것이 안드로이드 개발입니다. URL 등을 이야기했지만 코드를 읽는 것이 안드로이드 개발입니다. 중요하니까 두번 말했습니다. 우선 문제가 있으면 공식 이슈 트래커 등에 찾아보고, 나오지 않을 경우 아래의 URL을 이용해서 SDK 소스 코드를 읽을 수 있습니다.</p>

<ul>
  <li><a href="https://sites.google.com/site/devcollaboration/codesearch">소스 코드 검색 (OpenGrok)</a></li>
  <li><a href="https://github.com/android">GitHub의 안드로이드 미러</a>
    <ul>
      <li><a href="https://github.com/android/platform_frameworks_base">Android Framework의 Mirror Repository</a></li>
      <li><a href="https://github.com/android/platform_frameworks_support">Support Library의 Mirror Repository</a></li>
    </ul>
  </li>
  <li>Android Studio SDK의 소스 코드를 참조해서 읽는 방법 <a href="http://qiita.com/makoto_kw/items/032e210aecf57deeb5a5">(조금 낡은 기사)</a></li>
</ul>

<h3 id="section-9">샘플 애플리케이션과 읽어봐야 할 부분</h3>

<p>konifar 씨의 DroidKaigi 2016의 애플리케이션은 간단하게 정보를 표시하고 즐겨찾기 등을 관리할 수 있는 샘플 응용 프로그램으로 매우 깨끗한 코드라고 정평이 나 있습니다. 우리들의 신, Jake Wharton 씨의 u2020도 일부를 차용했다는 이야기를 간혹 듣기 때문에 분명 뭔가 얻을 수 있을 것입니다. 확인하니 RxJava라던가 Retrofit 2 등의 현대적인 구성으로 되어있는 것 같습니다.</p>

<p>ActivityThread나 FragmentManager쪽은 생명주기와 관련해서 제대로 문서화되지 않은 동작(화면 회전 시, 처음부터 끝까지 다른 처리를 Main Thread에서 하는 것인지 궁금한 소박한 의문 등…)을 확인하기 위해 읽어둘 필요가 있을지도 모릅니다. 저는 읽게 되었습니다.</p>

<p><a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java">https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java</a>
<a href="https://github.com/android/platform_frameworks_base/blob/master/core/java/android/app/ActivityThread.java">https://github.com/android/platform_frameworks_support/blob/master/v4/java/android/support/v4/app/FragmentManager.java</a></p>

<h2 id="section-10">마치며</h2>
<p>일본에서는 iOS 사용자가 많기 때문인지 iOS 개발자가 더 우세하고 Android는 iOS의 디자인 카피같은 시안도 많이 받고 외롭습니다. Android 다운 멋진 애플리케이션을 늘려갑시다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>번역-중급-이상의-android-개발자가-android다운-개발을-하려면-봐야할-url-목록들</wp:post_id>
            <wp:post_date>2016-05-25 02:30:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>JIT(Just-in-Time) 컴파일러도 들어간 ART를 살펴보자</title>
            <link>http://realignist.me/code/2016/05/21/art-with-jit-compiler.html</link>
            <pubDate>Sat, 21 May 2016 17:30:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/05/21/art-with-jit-compiler.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>Android N부터 ART에 JIT(Just-in-Time) 컴파일러 기능이 추가되었다고 한다. 종래의 버전에서 ART는 AOT(Ahead-of-Time) 컴파일 방식을 통해 dex 바이너리를 oat 형식의 네이티브 바이너리로 컴파일했는데, N부터는 프로필 가이드를 기반한 컴파일을 통해 AOT 컴파일 방식과 JIT 컴파일 방식을 혼용해서 쓸 수 있게끔 변경된 것이다. JIT 컴파일러를 혼용함으로써 앱의 설치와 시스템 업데이트 시 걸리는 시간이 단축될 수 있다는게 구글의 설명이다.</p>

<p>프로필 가이드에 기반한 최적화는 프로파일링을 통해 런타임의 퍼포먼스를 높여주는 컴파일러의 최적화 기술이다. 그러면 ART는 언제부터 JIT 컴파일 기능이 추가가 되었는지, 어떻게 동작하는지 궁금한 나같은 사람들을 위해 같이 ART의 소스 코드와 커밋을 살펴보기로 하자.</p>

<h2 id="art-kitkat------">ART는 Kitkat부터 사용 빈도가 높은 메소드를 다시 컴파일했다.</h2>

<p>아니 이게 무슨 소리인가. 실시간으로 컴파일을 하는 JIT는 Android N 런타임에 추가된 새로운 기능이다. 근데 ART가 시범적으로 적용됬었던 Android 4.4부터 비슷한 기능이 있었다니?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>I/art     (  636): DexFile_isDexOptNeeded size of new profile file /data/dalvik-cache/profiles/com.android.launcher is significantly different from old profile file /data/dalvik-cache/profile-cache/com.android.launcher (top 90% samples changed in proportion of 18.75%)
I/PackageManager(  636): Running dexopt on: com.android.launcher
I/dex2oat ( 1047): dex2oat: /system/bin/dex2oat --zip-fd=6 --zip-location=/system/priv-app/Launcher2.apk --oat-fd=7 --oat-location=/data/dalvik-cache/system@priv-app@Launcher2.apk@classes.dex --profile-file=/data/dalvik-cache/profiles/com.android.launcher
 ...
I/dex2oat ( 1047): compiling method android.view.View com.android.launcher2.PagedView.getPageAt(int) because its usage is part of top 3.08642% with a percent of 0.205761%
I/dex2oat ( 1047): compiling method void com.android.launcher2.AppsCustomizeTabHost.onFinishInflate() because its usage is part of top 0.617284% with a percent of 0.617284%
I/dex2oat ( 1047): compiling method void com.android.launcher2.CellLayout.&lt;init&gt;(android.content.Context, android.util.AttributeSet, int) because its usage is part of top 2.88066% with a percent of 0.411523%
I/dex2oat ( 1047): compiling method void com.android.launcher2.CellLayout.onDraw(android.graphics.Canvas) because its usage is part of top 3.08642% with a percent of 0.205761%
 ...
I/dex2oat ( 1047): compiling method void com.android.launcher2.Workspace.addInScreen(android.view.View, long, int, int, int, int, int, boolean) because its usage is part of top 3.08642% with a percent of 0.205761%
I/dex2oat ( 1047): dex2oat took 3.496627214s (threads: 1)
I/art     ( 1019): Starting profile with period 10s, duration 30s, interval 10000us.  Profile file /data/dalvik-cache/profiles/com.android.launcher
</code></pre>
</div>

<p>Android 4.4에서 ART 방식으로 런타임을 사용할 때 볼 수 있는 로그의 일부분이다. 로그를 보면 별도의 쓰레드에서 프로파일링을 하고, 그 결과에 따라 많이 실행되는 메소드를 다시 컴파일하는걸 볼 수 있다. <em><a href="http://d.hatena.ne.jp/embedded/20140511/p1">참고한 글</a></em></p>

<p><a href="https://android.googlesource.com/platform/art/+/39c3bfbd03d85c63cfbe69f17ce5800ccc7d6c13/runtime/profiler.cc"><code class="highlighter-rouge">runtime/profiler.cc</code></a>의 <code class="highlighter-rouge">void BackgroundMethodSamplingProfiler::Start(int period, int duration, ...)</code> 메소드와 <a href="https://android.googlesource.com/platform/art/+/39c3bfbd03d85c63cfbe69f17ce5800ccc7d6c13%5E%21/compiler/driver/compiler_driver.cc"><code class="highlighter-rouge">compiler/driver/compiler_driver.cc</code></a>의 <code class="highlighter-rouge">bool CompilerDriver::SkipCompilation(const std::string&amp; method_name)</code> 메소드를 통해 위에 있는 로그가 어떻게 찍혔는지 알 수 있다.</p>

<p>지금 Marshmallow나 N의 소스 코드를 보면 <code class="highlighter-rouge">compiler/driver/compiler_driver.cc</code>에는 <code class="highlighter-rouge">CompilerDriver::SkipCompilation</code>라는 메소드가 존재하지 않을 것이다. 그러면 이 메소드는 언제 왜 없어졌는지에 대해서는 후술하도록 하겠다.</p>

<h2 id="jit--aosp-">JIT 컴파일러가 AOSP에 들어갔다!</h2>

<p>정식으로 ART에 JIT 컴파일과 관련된 코드가 등록된 것은 2015년 2월의 일이다. <a href="https://android.googlesource.com/platform/art/+/2535abe7d1fcdd0e6aca782b1f1932a703ed50a4">다음 커밋</a>을 보면 작년 2월부터 JIT의 기능을 시험적으로 써볼 수 있는걸 확인할 수 있다.</p>

<p>커밋이 큰데, diff를 보면 Runtime의 <code class="highlighter-rouge">IsCompiler()</code> 메소드의 이름이 <code class="highlighter-rouge">IsAotCompiler()</code>로 바뀐 것을 확인할 수 있다. AOT 컴파일과 JIT 컴파일을 구분하기 위함이라고 생각한다. 또, 해당 커밋의 <a href="https://android.googlesource.com/platform/art/+/2535abe7d1fcdd0e6aca782b1f1932a703ed50a4/runtime/runtime.cc#474"><code class="highlighter-rouge">runtime/runtime.cc</code></a> 코드를 확인해보자. SELinux의 R/W/X 메모리 구역 제한으로 인해 Zygote에서는 Code Cache가 만들어질 때까지는 JIT 컴파일을 사용하지 못한다는 것을 확인할 수 있다.</p>

<h2 id="profile-guided-optimization-">Profile-Guided Optimization을 도입하다.</h2>

<p>그 이후로 눈 여겨본 커밋은 Android N에서 도입되었다고 이야기하는 프로필 가이드에 기반한 최적화 컴파일을 가능하게 해주는 <a href="https://android.googlesource.com/platform/art/+/500c9be">커밋</a>이다. 이 커밋의 diff를 확인해보면 위에서 언급했었던 <code class="highlighter-rouge">CompilerDriver::SkipCompilation</code> 메소드가 사라진 것도 확인할 수 있다.</p>

<p>일단 이 커밋을 통해 ART에서도 dex2oat 과정에서 프로필 가이드에 기반한 최적화가 가능해졌다. JIT를 수행하는 동안의 프로필 결과를 파싱할 수 있고, 프로필 정보에 존재하지 않는 메소드는 컴파일하지 않는다. 오래된 컴파일 훅은 삭제하며, dex2oat에서 인터프리팅 모드가 추가되었다.</p>

<p>아마 Android N에 추가되었다고 하는 프로필 가이드에 기반한 컴파일은 이 기능을 안정화시킨 것이라고 추측할 수 있을 것이다.</p>

<h2 id="section">마치며</h2>

<p>우리는 ART의 큼직큼직한 커밋들을 통해 처음엔 사용 빈도를 바탕으로 백그라운드에서 다시 컴파일을 하던 부분이 최적화를 거쳐 더 정교한 프로파일링을 바탕으로 JIT 컴파일 기능이 추가되었다라는걸 알 수 있었다. 사실 ART의 더 깊은 부분까지에 대해서는 아직 개인적으로도 이해가 부족하다는 생각이 들지만, 이 글을 통해 ART가 어떻게 발전할 수 있게 되었는지 이해하는데 조금이나마 도움이 되었으면 좋겠다.</p>

<p><strong>참고했었던 자료들</strong></p>

<ul>
  <li><a href="https://android.googlesource.com/platform/art/">platform/art 소스 코드</a></li>
  <li><a href="http://www.slideshare.net/linaroorg/hkg15300-arts-quick-compiler-an-unofficial-overview">ART’s Quick Compiler: An unofficial overview</a></li>
  <li><a href="http://d.hatena.ne.jp/embedded/20140511/p1">안드로이드의 ART는 실행 중에 프로파일링을 통해 백그라운드에서 다시 컴파일을 하는 것 같다.</a></li>
  <li><a href="http://www.slideshare.net/kmt-t/art-47396171">진화하는 ART</a></li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>jit-just-in-time-컴파일러도-들어간-art를-살펴보자</wp:post_id>
            <wp:post_date>2016-05-21 17:30:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>우리는 지금 어디에 있는가?</title>
            <link>http://realignist.me/life/2016/05/12/when-we-are.html</link>
            <pubDate>Thu, 12 May 2016 01:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/life/2016/05/12/when-we-are.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>나의 <a href="http://realignist.me/about/">소개</a>를 보면 알겠지만 나는 여러가지 신경증을 가지고 있다. 이 신경증들로부터 어떻게든 벗어나기 위해 뇌와 심리는 어떻게 동작하는지 알게 되면 조금이라도 더 도움이 될 수 있지 않을까 하는 마음에 혼자서 공부도 하면서 심리치료도 받고 약도 먹고 있다. 이런 과정 속에서 느끼게 된 점은 심리학이라는 학문은 사람의 뇌와 신경이라고 하는 정말 정밀한 과학의 영역과 사람의 마음이라는 매우 추상적인 철학의 영역 사이에 있는, 참 절묘한 위치에 있는 학문이라는 생각이 든다.</p>

<h4 id="section">“우리는 과거에 머물러 있는건 아닐까?”</h4>

<p>개인적인 관심사 중 하나에서 빠질 수 없는건 역시 <strong>“트라우마”</strong>다. 사람은 누구나 트라우마를 한 두개씩은 안고 살아간다. 그것은 정말 평범한 일이지만, 그것을 우리가 어떻게 안고 살아가느냐에 따라서 삶이 달라지는 것 같다.</p>

<p>심리학의 거장인 알프레드 아들러는 과거에 있었던 일이 현재의 일에 영향을 미치는 것에 대해서 부정하고 과거에 있었던 일에 <strong>우리 스스로가 부여한 의미</strong>가 현재의 일에 영향을 미친다고 주장했다. 이는 충분히 일리가 있는 말이지만, 과거에 겪은 ‘특정한 일’에 대한 충격이 크다면 우리는 이성적으로 그 일에 제대로 의미를 부여할 수 없을 것이다. 그리고 그것이 트라우마로 남게 되는 것이라고 생각한다.</p>

<p>내가 정신과 치료를 받기 시작했을 때, 주변에서 시간이 약이라는 이야기를 정말 지겹도록 들었던 것 같다. 그러면 정말 시간은 과연 트라우마에 약이 될 수 있을까? 이 질문에 대해서 꽤 오랫동안 생각했던 것 같은데, 생각해보니 어느 정도는 도움이 되지 않았나 싶은 생각이 들었다. 가끔은, 정말 가끔은 시간이 약일 때가 있지 않을까라는 생각이 들었다.</p>

<p>사람의 기억이라는 것은 시간이 지날수록 점점 옅어진다. 우리가 과거의 기억들을 억지로 헤집고 들춰내고 과거에 무슨 일이 있었는지 억지로 생각하지 않는다면 시간이 지나면 지날수록 기억은 점점 흐려질 것이다. 물론 이게 질병적인 수준의 트라우마라면 심리 치료와 약물 치료를 꾸준히 받는게 제일 중요하겠지만, 내가 하고 싶은 이야기는…</p>

<p>우리는 현재를 살고 있다. 증상이 너무 힘들 때는 약의 도움을 받을 수도 있고, 의지를 하거나 이야기를 들어줄 사람이 필요하다면 상담을 받을 수도 있다. 하지만 아직 생각을 정리하기 힘든 과거의 일이라면 잠시 덮어두고 지금을 살아도 괜찮지 않을까. 시간이 지나 트라우마에 대해 다시 생각할 수 있는 여유가 있을 때 여러 관점에서 다시 바라볼 수 있었으면 좋겠다는 생각이 든다.</p>

<h4 id="section-1">“용서란 어떻게 할 수 있는 것일까?”</h4>

<p>이번에는 사실 나의 질문이기도 하다. 아직 해답이 풀리지 않은 문제이기 때문이다. 왜 상대방이 그런 잘못을 했는지를 이해할 수 있어도 마음 속으로 용서를 할 수 있는 것은 아니라는 것을 깨달았다. 과거에 있었던 일을 그저 있었던 일 자체로 받아들인다고 하더라도 용서는 어떻게 할 수 있는 것일까?</p>

<p>용서에 대해서 사람들은 사람이 할 수 있는 제일 아름다운 행동이면서도 제일 하기 어려운 행동이라고 한다. 나는 무신론자임에도 불구하고 이번에는 한번 종교에서는 어떻게 이야기하고 있는지를 찾아봤다.</p>

<p>성서의 <a href="http://kcm.co.kr/bible/kor/Mat6.html">마태복음</a>을 보면 아래와 같이 적혀있다. 결국 하나님이 용서하신 것과 같이 우리도 용서해야한다는 논리이다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	오늘 우리에게 일용할 양식을 주시옵고 우리가 우리에게 죄 지은 자를 사하여 준 것 같이 우리 죄를 사하여 주시옵고,
	우리를 시험에 들게 하지 마시옵고 다만 악에서 구하시옵소서 나라와 권세와 영광이 아버지께 영원히 있사옵나이다 아멘.
	너희가 사람의 잘못을 용서하면 너희 하늘 아버지께서도 너희 잘못을 용서하시려니와,
	너희가 사람의 잘못을 용서하지 아니하면 너희 아버지께서도 너희 잘못을 용서하지 아니하시리라.
</code></pre>
</div>

<p>불교의 경우는 다음과 같았다. 성철스님의 법문을 참고했다. 결국 용서에 대한 속 시원한 답은 어디서든 모두 얻을 수 없었다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   그런데 사실 불교에서는 ‘용서(容恕)’라는 말 자체가 없습니다. 용서라는 말이 없다고 잘못한 사람과 싸우라는 말은 물론 아닙니다.
   상대를 용서한다는 것은 나는 잘했고 너는 잘못했다, 그러니 잘한 내가 잘못한 너를 용서한다는 이야기인데,
   그것은 상대를 근본적으로 무시하고 하는 말입니다. 상대의 인격에 대한 큰 모욕입니다.
   불교에서는 ‘일체 중생의 불성은 꼭 같다[一切衆生 皆有佛性]’고 주장합니다.
   성불해서 연화대 위에 앉아 계시는 부처님이나 죄를 많이 지어 무간지옥(無間地獄)에 있는 중생이나 자성자리, 실상(實相)은 똑같습니다.
   그래서 아무리 죄를 많이 짓고 아무리 나쁜 사람이라도 겉을 보고 미워하거나 비방하거나 한층 더 나아가서 세속말의 용서는 할 수 없습니다.
   그러면 어떻게 해야 하는가? 아무리 죄를 많이 지었고 나쁜 사람이라도 그 사람을 부처님같이 존경하라는 것입니다.
   이것이 우리 불교의 생명이라 해도 과언이 아닙니다. 부처님을 실례로 들어도 그와 같습니다.
</code></pre>
</div>

<p>아무튼 상대방이 왜 그런 행동을 했는지 여러가지 시각에서 보고 이해하는게 용서의 선행 조건이라는건 알 수 있었다. 하지만 그렇다고 해서 바로 용서할 수 있는게 아니었다. 이런 것도 아까처럼 시간이 약인 일인건가 싶은 생각도 든다.</p>

<h4 id="section-2">마무리로.</h4>

<p>우리는 현재를 살고 있다. 우리가 오버워치의 트레이서가 아니기 때문에 생각이 미래에만 머물러 있거나 과거에 머물러 있지 말고 지금에 집중해서 살 수 있는 삶을 살아야하지 않을까? 물론 그를 위해 필요한 것들이 많지만. 그리고 지금도 트라우마 등으로 힘들어하는 사람들이 부디 악몽과 플래시백으로 고통받지 않고 편안히 지낼 수 있기를…</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>우리는-지금-어디에-있는가</wp:post_id>
            <wp:post_date>2016-05-12 01:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>Tennmak, 가성비를 찾는 사람을 위한 명답</title>
            <link>http://realignist.me/life/2016/04/19/tennmak-shocks.html</link>
            <pubDate>Tue, 19 Apr 2016 08:10:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/life/2016/04/19/tennmak-shocks.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>최근 주변에서 중국의 이어폰 제조사인 텐막의 이어폰을 산 뒤 “충격적이다”라는 이야기를 들었다. 찾아보니 텐막의 모든 제품은 5만원을 넘지 않는 저가형 이어폰이었다. 저가형 이어폰을 듣고 정말 이게 충격적인 수준의 품질인지 궁금했던 나는 텐막의 프로 제품과 알리800을 구매해보았다.</p>

<p>우선 결과부터 이야기하자면 나도 충격을 금할 수 없었다. 트위터엔 몇번이나 “할 말을 잃었습니다…”라는 이야기를 외치면서 페이스북에는 “다씨는! 중국의 오디오 테크놀로지를 무시하지 않겠습니다…”라고 글을 올리기까지 했다. 가격표 뒤에 0이 빠진게 아닐까라는 생각도 들었고, 중국의 오디오 기술을 무시해선 안되겠구나라는 생각도 들었다. 그래서 이번엔 솔직하게 두 제품이 어떤지 이야기해보고자 한다. 오디오 리뷰는 원래 그렇지만 전문적인 측정 장비가 없을 때는 개인의 주관적 특성을 탈 수 밖에 없다. 읽을 때에는 이 점에 부디 주의해줬으면 좋겠다. 텐막의 제품들은 한국에서도 정식 수입되어 <a href="http://tennmak.co.kr">텐막 코리아</a>에서 살 수 있다.</p>

<p>개인적으로는 이어폰이나 헤드폰의 에이징(처음에 딱딱하게 굳어있는 진동판을 풀어주는 행위)이라는걸 별로 생각하지 않는 편이며 특별히 이퀄라이징을 해서 음악을 듣는 편도 아니다. 하지만 텐막 코리아 홈페이지에서는 제품의 에이징을 권장하고 있다. 이 리뷰에서는 제품에 대한 일체의 에이징도 하지 않았음을 밝힌다.</p>

<h4 id="section">심플한 제품의 외관, 오직 케이스와 보증서 뿐.</h4>

<p><img src="http://realignist.me/assets/images/20160419_185009.jpg" alt="" /></p>

<p>보통 텐막의 제품을 중국의 쇼핑몰인 알리 익스프레스를 통해 접할 수도 있지만, 필자는 텐막 코리아를 통해서 주문했다.(알리 익스프레스의 주문들은 보통 배송 기간이 매우 길기 때문에 나는 텐막 코리아에서 구매하는걸 권하는 바이다.) 택배 사이즈가 너무 작아서 도대체 어떻게 구성되었을지 궁금했다. 뜯어보니 위의 사진처럼 정말 딱 케이스와 판매 인증서만 있었다. 분명히 내가 산 이어폰은 저가 이어폰이었는데도 구매 후 1년간 보장이 되는 워런티 카드가 와서 신선했다.</p>

<h4 id="ie800-">과연 텐막의 알리800은 IE800의 복각품인가.</h4>

<p><img src="http://realignist.me/assets/images/20160419_185656.jpg" alt="" /></p>

<p>텐막의 알리800은 젠하이저 IE800의 외관을 그대로 가져왔다. 그래서 알리800은 IE800의 짝퉁이라고 이야기하는 사람도 많다. IE80의 경우 중국에서 OEM으로 제조하면서 IE80의 가품이 알리 익스프레스에서 많이 팔리고 있으며 IE800은 그래서인지 중국에서 제조하지 않고 독일에서 제조하고 있다.</p>

<p>텐막의 알리800은 오직 IE800의 외관만을 가져온 제품이다. IE800의 경우, 젠하이저에서 설계한 7mm의 다이나믹 드라이버를 사용한다. 하지만 텐막의 알리800은 자체 제작한 8mm의 다이나믹 드라이버을 사용하는데 드라이버의 진동판은 티타늄으로 코팅되어있다. 즉, IE800의 외관 구조를 베꼈지만 실제로는 다른 제품이라는 것이다. 외관 구조를 베끼면서까지 제품을 만든 것을 생각하면, 제품의 특징인 유닛 뒷면에 있는 두개의 에어 덕트가 꽤 메리트가 있지 않았을까 생각해본다.</p>

<p><img src="http://realignist.me/assets/images/20160419_185727.jpg" alt="" /></p>

<p>텐막의 알리800은 IE800처럼 이어팁에도 철망이 있는 형태는 아니었다. 폼팁을 분리하면 유닛의 앞 부분을 볼 수 있는데, 위의 사진에서 알 수 있듯 촘촘한 철망으로 되어있는걸 볼 수 있다. 개인적으로 원래 사용하던 소니의 h.ear in 이어폰도 솜같은 재질로 처리되어 아쉬웠는데 IE800의 이런 부분까지 차용한걸 생각하면 텐막의 디테일함에 다시 한번 놀랄 수 밖에 없었다.</p>

<p>아까도 이야기했지만 텐막의 알리800은 IE800의 외관을 베꼈지만, 내부 유닛은 확실히 다르다. 실제로 청감적인 느낌도 달랐는데, 두 기기의 측정치를 보고 싶다면 <a href="http://goldenears.net/board/index.php?mid=GR_Earphones&amp;search_target=title&amp;search_keyword=IE800&amp;document_srl=3516111">골든이어즈의 리뷰</a>와 <a href="http://tennmak.co.kr/product/detail.html?product_no=17&amp;cate_no=44&amp;display_group=1">텐막 코리아의 제품 링크</a>에서 확인해보길 바란다.</p>

<p>청감적인 느낌을 이야기해보자면 정말 고음이 청량한 제품이라고 할 수 있다. 여성 보컬과 드럼의 스네어 음이 굉장히 선명해서 인상적이었다. 또한 만족스러움 공간감을 보였는데 개인적으로는 유닛 뒷쪽에 있는 에어 덕트 덕분이 아닐까 추측해본다. 반면 저음은 실제 그래프에서도 IE800보다 평이하게 보여줬었는데 실제로 들어봤을 때 많이 아쉬웠다. 개인적으로는 이 제품을 팝이나 재즈, 여성 보컬이 있는 곡에 잘 맞을 것 같다고 생각한다. 만약 락이나 일렉트로닉같은 노래를 주로 듣는다면 알리800보단 텐막 프로를 추천하고 싶다.</p>

<p>근데 필자가 원래 사용해오던 오디오 기기는 소니의 h.ear in 이어폰을 제외하곤 다 하이엔드 이상의 기기들이었다. 물론 그런 기기들과 비교하면 많이 부족할 수 밖에 없다. 하지만 약 4만원 정도 되는 가격의 이어폰에서 이런 소리를 듣는건 정말 신선한 충격이었다. 다만 IE800을 표절한 제품이라는 점에서는 충분히 비판할만한 부분이라고 생각한다.</p>

<h4 id="mmcx---">더블 드라이버에 MMCX 커넥터. 텐막 프로</h4>

<p><img src="http://realignist.me/assets/images/20160419_185111.jpg" alt="" /></p>

<p>알리800으로 충격을 먹었지만 텐막 프로를 보지 않을 수는 없었다. 6mm와 9mm, 두 개의 다이나믹 드라이버와 MMCX 커넥터로 케이블과 유닛 간의 분리가 되는 제품이 마찬가지로 내가 납득하기 힘든 가격에 나왔다. 이쪽 유닛도 알리800처럼 철망으로 촘촘히 되어있나 기대했지만 아래 사진처럼 그렇지는 않았다.</p>

<p><img src="http://realignist.me/assets/images/20160419_185309.jpg" alt="" /></p>

<p>그래도 가격을 생각하면 충분히 납득이 되는 부분이다. 이번 제품에서는 케이블에서 텐막의 디테일함을 느낄 수 있었는데, MMCX 케이블인데 약간 안쪽으로 들어가있는 구조로 커넥터 부분이 보이지 않고 커넥터가 분리될 걱정도 덜 수 있다. 게다가 알루미늄 코일로 된 이 케이블은 쉽게 단선되지 않는다고 한다. 물론 단선이 되면 다른 MMCX 케이블을 살 수도 있겠지만 아마 대부분의 케이블이 이 이어폰보다 비쌀 것이다.</p>

<p>청감적인 느낌을 이야기해보자면 밸런스 있는 소리와 함께 저음이 듣기 좋게 가미된 느낌이다. 음악을 들을 때 각 악기의 소리를 선명히 느낄 수 있었다. 이퀄라이저를 사용해서 이리저리 만져본 결과, 개인적으로 저음과 고음을 조금 더 늘려주었을 때 내가 사용하던 소니의 h.ear in 이어폰과 비슷한 느낌을 느낄 수 있었다. 락과 일렉트로닉 음악을 좋아하는 사람에게 추천해주고 싶은데 모든 장르에서 무난하게 사용할 수 있다고 생각한다. 번들로 나오는 폼 팁이 아쉬웠는데 알리800에 있던 스폰지 폼 팁을 사용하니 훨씬 편했던 것 같다. 마찬가지로 다시 가격을 생각하고 어떻게 이 가격에 이런 소리가 나는건지 놀랄 수 밖에 없었다.</p>

<h4 id="section-1">후기</h4>

<p>두 제품을 써보면서 느꼈지만 이 제품은 동일 가격대의 다른 제품들과 비교하기엔 너무 성능이 좋은 기기라는 점이었다. 또한 중국의 오디오 기술을 무시할 수는 없다는걸 느꼈다. 개인적으로는 과연 중국에서 고가의 기기가 나온다면 어떤 사양으로 어떤 소리를 보여줄지 한층 더 궁금해졌다. 만약 이 글을 보고 관심이 생긴다면 가벼운 마음으로 사보길 권한다. 다시 한번 이야기하지만 이 이어폰들의 가격은 배송비를 합쳐도 5만원도 안된다는 점이다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>tennmak-가성비를-찾는-사람을-위한-명답</wp:post_id>
            <wp:post_date>2016-04-19 08:10:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>피카츄의 기묘한 딥러닝 체험</title>
            <link>http://realignist.me/code/2016/02/28/pikachus-bizarre-deeplearning.html</link>
            <pubDate>Sun, 28 Feb 2016 09:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2016/02/28/pikachus-bizarre-deeplearning.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>최근에 나는 프로그래밍을 이용해서 재밌는 것들을 많이 하려고 노력하는 편인데, 프로그래밍을 이용한 영상 편집이 필요하다는 부탁을 듣고 작업을 하면서 딥러닝이 어떤 것인지 아주 조금 체험할 수 있었다. 다만 그 과정이 정말 기괴하고 힘든 삽질들로 가득했기 때문에 조금이나마 기록을 남기고자 한다. 이 글에서는 Ubuntu 14.04.4를 기준으로 설명해보고자 한다. 또한 이 글을 통해 딥러닝을 같이 체험해보고 싶다면 고사양의 Nvidia GPU가 있는 머신에서 작업하길 권장한다. 아니면 Amazon EC2의 GPU 인스턴스도 좋다. (이 글에서는 CUDA를 활용하고 있다. 나는 i7 6700K와 32GB RAM 환경에서 작업했었는데… 그래픽카드에 대해서는 후술하겠다.)</p>

<h4 id="section">뭘 했는데?</h4>

<p>내가 한 것은 뮤직비디오의 편집이었는데 뮤직비디오의 컨셉이 싸이키델릭이었다. 기계 학습을 통해서 기계가 만들어낸 이미지는 정말로 난해했고, 뮤직비디오를 만드는 형님은 이 난해함을 영상에 담고 싶었지만 기존의 영상 편집 기술로는 어려웠다고 한다. 찾아보니까 이러한 것을 <strong>“DeepDream”</strong>이라고 사람들은 부르며 이러한 비디오를 합성할 수 있는 것이 <a href="https://github.com/graphific/DeepDreamVideo">GitHub</a>에 있었다. 사실 이때는 내가 이렇게 미친 삽질들을 할지는 미쳐 알지 못했다.</p>

<h4 id="deepdreamvideo-">DeepDreamVideo는 간단해보였다…</h4>

<p>처음엔 이게 단순하게 영상을 프레임 단위로 나누어서 이미지 파일로 만들고, 이미지 파일들을 모델 이미지와 섞어서 DeepDream을 구현한 뒤, 그 이미지들을 다시 영상으로 합치는 것이라고 생각했다. 그랬기에 적당히 CPU와 GPU가 좋은 컴퓨터 하나만 있으면 금방할 수 있을 것이라고 생각했다. 다만 내가 생각했던 것은 너무 단순했고 이 안에서 DeepDream을 구현하는 과정이 정말로 스펙터클했다.</p>

<p>우선 DeepDreamVideo는 영상을 프레임 단위로 분해하고 프레임들을 다시 영상으로 합치기 위해서 ffmpeg나 avconv, mplayer 등을 필요로 한다. 또한 jpg나 png에 맞는 이미지 라이브러리도 필요로 하는데, png의 경우 pngcrush를 요구했다. 나는 ffmpeg를 사용했는데 pngcrush 없이 아래와 같이 ffmpeg 커맨드만으로도 png로 추출할 수 있었다.(도와준 <a href="http://twitter.com/hibiyasleep">종이</a>에게 고맙다는 인사를 전한다.)</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">ffmpeg -threads 8 -i master_file.mov -vf <span class="nv">fps</span><span class="o">=</span>30 %08d.png</code></pre></figure>

<p>그러면 실제로 DeepDream을 만들어내는 Python 코드를 보면 numpy, protobuf, scikit-image, caffe 등을 필요로 한다. caffe를 제외한 셋은 pip를 통해서 설치 가능하다. 문제는 이 caffe였다.</p>

<h4 id="cuda-caffe-">CUDA, Caffe와의 씨름</h4>

<p>이제 Caffe에 대해서 이야기를 해보려면 CUDA 이야기를 빼놓을 수가 없다. DeepDreamVideo가 사용하고 있는 Caffe는 Berkeley Vision and Learning Center(BVLC)에서 만든 오픈소스 딥러닝 프레임워크다. 이 딥러닝 과정에 GPU 가속을 사용하기 위해서 CUDA 환경이 필요하다. 처음에 CUDA 환경을 구축할 때, 리누스 토발즈가 엔비디아한테 가운데 손가락을 날리면서 “So nVidia, Fu** you”라고 외치는 것이 떠올랐고… 내가 엔비디아 욕을 하지 않길 원했지만 CUDA 가속 때문에 2시간 정도를 날리고 나니까 자연스럽게 입에서 거친 말들이 나왔다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*tIJf0McU91OAqRQOoRJoWg.jpeg" alt="" />
<span class="figcaption_hack">엔비디아를 향한 리누스 토발즈의 욕설은 유명하다. 한때 내 마음도 그와 같았다.</span></p>

<p>내가 CUDA 환경을 구축하고 Caffe를 빌드하는데에는 <a href="https://www.reddit.com/r/deepdream/comments/3cd1yf/howto_install_on_ubuntulinux_mint_including_cuda/">Reddit에 정리된 글</a>을 참고해서 진행했는데, 글이 매우 잘 정리된 편이지만 몇가지 글에서 조심할 점들을 이야기해보겠다. 이것들을 고치고 나서 나는 CUDA 환경을 구축할 수 있었다.</p>

<ol>
  <li>“/etc/modprobe.d/blacklist.conf”를 설정하지 말아라. 나중에 씁쓸한 오류를 맛보게 될 것이다.</li>
  <li>처음에 “sudo su”로 root 유저로 들어가면 “~/”로 하는 것들이 사용자의 유저 디렉토리가 아니라 root 유저 디렉토리에 진행되므로,
나중에 일관성이 깨진다. sudo를 계속 사용하거나 아니면 root 계정에서 진행을 하자. 나는 전자를 추천한다.</li>
  <li>Cuda 7.0을 계속 설치해보려고 했지만 Ubuntu 14.04.4에서는 잘 되지 않았다. 여러번 설치와 삭제를 반복해본 뒤에 나는 Cuda
7.5로 설치를 성공했다.</li>
  <li>Ubuntu 14.04.4 기준 mdm이라는 service는 존재하지 않는다. Cuda(와 엔비디아의 드라이버)를 설치하기 위해서는 X
Window는 꺼져있어야 한다. 그러기 위해서는 “sudo service lightdm stop / start / restart”를 이용하자.</li>
</ol>

<p>Caffe 빌드를 위해서는 위에서 언급한 Reddit의 글대로 진행하면 되는데 나는 CUDNN이나 CPU_ONLY, Intel Composer XE같은 것들의 설정을 하지 않고 바로 빌드를 했다. 다른 점이 있다면 나는 <a href="https://github.com/NVIDIA/caffe">엔비디아에서 Fork한 Caffe</a>를 빌드했다는 점이다. 둘 다 써본 결과, 큰 차이가 없기 때문에 어느
쪽을 사용해도 큰 차이는 없을 것이다.</p>

<p>Google의 DeepDream을 설치할 필요는 없지만, Caffe 내의 모델로 “bvlc_googlenet.caffemodel”는 꼭 설치해야한다.</p>

<h4 id="deepdreamvideo">이제 진짜 DeepDreamVideo를…?</h4>

<p>사실 여기까지 보는 사람들은 별 것 아니라고 생각할 것이지만, 본인은 딥러닝 등에 대한 경험이 전무했고 소위 초고수가 아니기 때문에 4시간을 삽질하면서 구축했기 때문에 매우 험난하고 지친 과정이었다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*BtpZhonatJN9AnSxjpssdg.png" alt="" />
<span class="figcaption_hack">나는 그분처럼 전체 글을 봐도 내가 어떻게 환경을 구축해야할지 감이 잘 오지 않았다.</span></p>

<p>동영상을 프레임으로 쪼개는 작업은 이미 끝났고, python을 이용해서 아래와 같이 실행을 했다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">python dreaming_time.py -it png -i results -o output_”<span class="nv">$1</span><span class="s2">" -gi /media/user/image-dreamer/models/”</span><span class="nv">$1</span><span class="s2">"</span>.jpg —-gpu 0 -b random -t ~/caffe/models/bvlc_googlenet/ -m bvlc_googlenet.caffemodel</code></pre></figure>

<p>“어? 아… 안 되잖아? 이런 일이 일어날 것 같은 조짐을 느꼈지.” 나는 처음에 GTX960을 이용해서 작업을 진행하려고 했었다. 동영상 파일은 3GB가 넘었고, 프레임들이 저장된 폴더는 13GB가 넘었었다. 2GB의 그래픽 메모리를 가지고 있었던 GTX960은 CUDA에서 Out Of Memory를 외치며 죽어버렸고 나는 이것을 단순히 Caffe에서의 batch_size 문제라고 생각을 했지만… 하드웨어의 한계는 명확했다. 일단 작업하던 컴퓨터를 열고, GTX960을 뽑고 작업하던 스튜디오에서 제일 좋은 성능의 GTX980Ti를 박았다. 당연히 파워를 그대로 썼다간 바로 뻗을거라고 생각해서 스튜디오에 남아있던 1300W짜리 파워를 연결했다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*mik7GgJKDb8N7-JfMHeWew.jpeg" alt="" />
<span class="figcaption_hack">아무도 ITX 보드에 GTX980Ti를 박을거라고 생각도 못했을걸?</span></p>

<p>그러고보니 작업용 컴퓨터를 분해하면서 M.2 SSD가 어디에 있는지 한참을 헤맸는데 기가바이트 GA-Z170M-GAMING 5 기준으로는 보드 아랫면에 있었다. 솔직히 좀 충격이었다. 2816 CUDA Core에 6GB 그래픽 메모리가 담긴 크고 아름다운 GTX980Ti를 넣자 그제야 DeepDreamVideo는 멀쩡히 작동하기 시작했다.</p>

<h4 id="section-1">마지막 최적화를 향한 나름대로의 발악</h4>

<p>전체 뮤직비디오 영상을 프레임으로 쪼개니까 약 8000~9000개의 png 파일로 나뉘었고 이걸 하나하나 DeepDream하게 뽑아내는 작업을 했다. 1 프레임당 3초 정도의 시간이 소요됬으며 이렇게 진행하면 약 7~8시간이 소요되었을 것이라고 나왔다. 이건 아니라고 생각해서 당장 그래픽카드를 오버클럭했는데, Asus의 ROG GTX980Ti Platinum은 애초에 오버클럭용으로 나왔기 때문에 뭔가 걱정은 들지 않았다. 아래 코드의 첫번째 줄과 같이 설정을 해주고 재부팅을 한 뒤 두번째 줄을 실행하자.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">sudo nvidia-xconfig --cool-bits<span class="o">=</span>28
nvidia-settings</code></pre></figure>

<p>여러가지 정책들을 통해 GPU Fan 소리는 60%로 고정하고, 그래픽 클럭은 100~150MHz의 클럭을 올렸고 그래픽 메모리 클럭은 1000MHz 정도 올렸다. 그럼에도 불구하고 실행 속도가 특별히 개선되거나 하는 일은 없었다. 뮤직비디오를 만드신 형님이 DeepDream을 적용할 구간만 따로 편집해서 다시 주셔서 프레임은 3000~4000개 전후로 작업할 수 있었다.</p>

<p>사실 실제로 돌려보고 나니까 알게된 점은 이미지를 그래픽 메모리에 담아야 해서 그래픽 메모리의 점유율이 높았지 특별히 GPU나 CPU의 연산을 많이 사용하지 않았다. (GPU의 경우 GTX980Ti라서 크게 부담스럽지 않았을 수도 있다.) 다만 하나를 실행하니까 그래픽 메모리 5.2GB를 한번에 Python 프로세스가 차지했을 정도였기 때문에 동시에 여러 딥러닝 프로세스를 돌릴 수는 없었다.</p>

<h4 id="section-2">후기와 참조 링크</h4>

<p>처음으로 딥러닝을 만져본 후기는 정말 하드웨어빨이 중요하다는 것이었다. 또 관련된 논문을 읽어본 결과 아직 나는 이게 내부에서 어떻게 동작하는지 명확하게 알지도 못하는 정도라는걸 알았고 더 많이 공부하고자 하는 자극이 되었다. 나는 아래 링크들을 많이 참조했으며, 일부 개인적으로 좀 쓰기 편하게 DeepDreamVideo를 수정했다. 그 소스코드는 몇 일 정도 렌더링 작업이 끝나면 GitHub에 문서와 함께 공유하고자 한다.</p>

<ul>
  <li><a href="https://github.com/graphific/DeepDreamVideo">DeepDreamVideo</a></li>
  <li><a href="https://github.com/Dhar/image-dreamer">image-dreamer</a></li>
  <li><a href="https://github.com/NVIDIA/caffe">NVIDIA/caffe</a></li>
  <li><a href="https://www.reddit.com/r/deepdream/comments/3cawxb/what_are_deepdream_images_how_do_i_make_my_own/">DeepDream Dependency Guide</a></li>
  <li><a href="https://www.reddit.com/r/deepdream/comments/3cd1yf/howto_install_on_ubuntulinux_mint_including_cuda/">Ubuntu CUDA, Caffe Guide</a></li>
  <li><a href="https://developer.nvidia.com/cuda-downloads">CUDA Download</a></li>
</ul>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>피카츄의-기묘한-딥러닝-체험</wp:post_id>
            <wp:post_date>2016-02-28 09:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>2016년의 목표 : “생존하기”</title>
            <link>http://realignist.me/life/2016/01/19/life-of-2016.html</link>
            <pubDate>Tue, 19 Jan 2016 09:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/life/2016/01/19/life-of-2016.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>지난 해를 돌아보고 새해를 준비하는 이런 글은 연말이나 연초에 쓰는게 맞지만 사정이 있어서 1월이 절반이나 지난 지금에야 정리할 수 있게
되었다. <em>(우리가 그토록 이야기하고 있는 병신년은 음력이다보니까 설날부터 시작한다.)</em></p>

<h4 id="section">병원비가 이 정도면… 여행을 한번 가는데…</h4>

<p>연말정산때문에 의료비 내역을 조회해보니 2015년 1년간 우울증과 공황장애로 가는 병원과 약국으로 100만원 넘게 썼다. 이 돈이면 일본을 한번 갔다 올 수 있을 정도이고, 내가 듣고 싶은 앨범은 40장 정도는 살 수 있을 것이다. 작년… 스트레스를 받으니까 마음이 무너지고, 마음이 무너지니까 생활에 질서가 없어지고 몸도 같이 망가진다는걸 몸으로 직접 배웠던 것 같다.</p>

<p>그래서 올해의 목표는 “<strong>생존</strong>”이라고 결정했다. 건강을 되찾는건 계속 몇년째 이야기했지만, 무언가를 하기 위해선 체력이 필요하다. 그래서 올해는 그 체력을 만들어 살아남아야 할 것 같다.</p>

<hr />

<h4 id="step-1------">Step 1. “큰 바다 위에 있는 통통배” 작전</h4>

<p>나는 공황장애나 우울장애가 있다보니 한번 스트레스를 받기 시작하면 헤어나올 수가 없다. 정신과 선생님께서는 지금 내가 일을 크게 하고 있지 않는 상태이니까 “큰 바다 위에 떠있는 통통배처럼 최대한 아무것도 하지 말고 있는게 좋을 것 같다.”라는 말을 들었고 작년 년말부터 그렇게 있었던 것
같다.</p>

<p>특별한 일이 없으면 나가지도 않고, 사람들이 많은 곳은 자연스럽게 피하고, 집에서 은둔형 외톨이처럼 있기도 하고. 그때는 증상이 심했었으니까 이렇게 집 안에서만 지내면서 책만 읽어도 정신적으로는 많이 편해질 수 있었다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*BNo_kwJ3eqSjP9M72BXzjg.jpeg" alt="" />
<span class="figcaption_hack">바다 위에 있는 한 돛단배</span></p>

<h4 id="step-2---">Step 2. 생활의 질서를 주입하자.</h4>

<p>작년 연말에서 올해 연초로 오면서 증상이 정말 눈에 띄게 좋아졌다. 나는 지금 아르바이트거리 외에는 특별히 일을 하고 있지 않다. 학교를 다니거나 회사를 다니거나 하는 것과 같이 생활에 틀이 없으니까 질서도 무너지게 된다.</p>

<p>밤과 낮이 제대로 존재하지도 않고, 마음 내키는대로 배고프면 밥을 먹고, 졸려서 언제든 자고 싶으면 자는. 이렇게 살면 안되겠다는 생각이 진지하게 들었다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*l5WmQKMT93LTJ7MRyJCJCA.jpeg" alt="" />
<span class="figcaption_hack">분명 이 사진은 나에게만 해당되는게 아냐…</span></p>

<p>꼭 초등학생이 방학때 일과 만들듯 “언제부터 언제까진 이거해야지~”라고 정하지는 않지만, 가급적 10시까지는 일어나고 2시에는 자려고 한다. 몇일간 도전해보면서 어떻게하면 좀 괜찮을지 계속 생각하면서 수정해나갈 것 같다.</p>

<h4 id="step-3------">Step 3. 빨피 탈출은 포션이 아니라 운동으로 하자.</h4>

<p>생활 규칙을 맞추면서 잘 쉬어도 체력을 쌓지 않으면 남들처럼 무언가를 할 수 없다. 즉 생존하기 위한 체력이 부족한 상황이다. 체력에 대한 개념이 있는 게임에서 체력이 조금밖에 남지 않아서 빨갛게 보이는걸 빨피라고 한다. 즉 지금 나는 빨피이다. 게임 세계라면 밥을 먹거나 가만히 있거나 포션을 마시면 되지만 현실에서 게임처럼 포션을 먹으면 죽는다.</p>

<p><img src="https://cdn-images-1.medium.com/max/1600/1*p5gAQZpC_kr0BylQIf9SCw.jpeg" alt="" />
<span class="figcaption_hack">현실의 포션은 오히려 도움이 되질 않는다.</span></p>

<p>결론은 급할 때 카페인을 찾거나 약을 먹어서 되는게 아니라 <strong>규칙적인 삶에서 규칙적인 운동을 해야한다</strong>는 것이다. 그리고 사실 이게 제일 어려운 것 같다.</p>

<hr />

<p>올해에는 제대로 생존하기 위해 살아보려고 한다. 무엇을 하더라도 체력이 없으면 할 수 없다. 건강하게 탈 없는 한 해가 됬으면 좋겠다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>2016년의-목표-생존하기</wp:post_id>
            <wp:post_date>2016-01-19 09:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[독후감] “미움받을 용기”를 읽고서</title>
            <link>http://realignist.me/book/2015/12/16/courage-to-be-disliked.html</link>
            <pubDate>Wed, 16 Dec 2015 09:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/book/2015/12/16/courage-to-be-disliked.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<p>글에 앞서서 이상한모임의 <a href="http://1225.weirdx.io/">독후감 Advent Calendar</a> 덕분에 계속 미루던 책 읽기도 하고 읽고 난 후기를 이렇게 글로도 쓸 수 있게 된 것 같아서 감사하다는 마음이 먼저 들고 이런 기회를 만들어주신 이모님과 이상한모임의 다른 분들께 감사하다는 말씀을 먼저 드리고 싶습니다. :)</p>

<p>이 글은 <strong><a href="http://ridibooks.com/v2/Detail?id=2148000002">월간이모 1월호</a></strong>에서 볼 수 있습니다. 월간이모에서는 chiyodad님이 글을 편집해주셔서, 훨씬 편하게 읽으실 수 있을겁니다. 여러분은 그러니 여기서 읽는 것보다는 월간이모로 보시는게 낫습니다. 그리고 2월호도 지르시는겁니다.</p>

<h3 id="section">어떻게 책을 선택했을까?</h3>
<p>사실 저는 공황장애와 불면증 등으로 정신과 진료를 받고 있고, 정신과나 저와 이야기하시는 주변 분들께서 문학 서적이나 책들을 읽어보는건 어떠냐는 권유를 받게 되었습니다. 반성하자면 그간 제가 어렸을 때부터 책은 많이 읽었지만… 어렸을 때 읽은 책은 과학 책이었고, 컴퓨터에 꽂혀 프로그래밍을 배우기 시작하고서는 컴퓨터 기술 서적만 읽었기 때문에 다른 분야의 책들과 문학 작품들을 접하자는걸 조금 늦게 깨달았습니다. 다만 저는 사람들에게 미움받을 용기가 없었고, 누구나 읽을 수 있는 인문 심리학쪽 책을 찾아보자라는 마음에 이 책을 고르게 되었습니다.</p>

<h3 id="section-1">이 책은 누구에게 궁합이 안 맞을까?</h3>
<p>이 책을 읽고 나서 저는 이 책이 정말 좋지만 이 책을 읽은 것에 대해 약간 후회하고 있습니다. 현재 제가 병원에서는 “마치 아무런 자극 없이 파도를 타는 바다 위에 떠있는 배”가 되어 아무런 자극을 주지 않고 되도록이면 사람이 많은 곳도 피하고 감정에 대한 생각을 피하는 상태를 만드는게 좋다고 이야기를 들었습니다. 다만 이 책을 읽고서 계속 자신의 상황과 이 책을 비교하며 나는 어떠한 의미를 부여했는가, 내가 지금까지의 인간 관계에서는 어떠했으며… 수많은 생각들을 하게 되었습니다. 그래서 이 책은 정말 좋은 책이지만 <strong>생각이 많으면서도 우울한 사람들</strong>에겐 오히려 생각에만 빠져 더 우울한 생각을 하게 될 수 있다고 느꼈습니다. 그런 사람들에게는 잠시 이 책을 권장하고 싶지 않습니다.</p>

<h3 id="section-2">어떤 내용이길래 좋다고 생각했을까?</h3>

<p>그럼에도 불구하고 전 이 책은 (거의 대부분의 사람들에게) 좋다고 느꼈습니다. 우리는 인간이고 사회적인 동물입니다. 사회에서 살면서 수많은 사람들이 서로 관계를 갖고, 그 인간 관계 속에서 우리는 상처를 받고 혹은 상처를 주게 됩니다. 아마 이 책을 찾는 사람들도 다 인간 관계에 대해서 고민을 가지고 있는 사람들(그게 우리 모두일 수도 있습니다.)일거라고 생각합니다.</p>

<p>이 책의 구조는 철학자와 청년의 이야기로 되어있습니다. 청년이 “세계는 단순하며, 인간은 오늘이라도 당장 행복해질 수 있다”라고 주장하는 철학자를 찾아가서 반박하면서 아들러 심리학에서 주장하는 것들을 배워나가는게 이 책의 내용입니다. 그 대화 속에서 우리는 우리가 사람들과 더불어 어떻게 살아가면 좋은지를 배울 수 있다고 생각합니다.</p>

<h3 id="section-3">“아들러 심리학이란 뭘까?”라는 궁금증</h3>

<p>이 책이 아들러 심리학, 아들러의 사상을 대화로 풀어낸 것이라고 하지만 이 책을 읽고 나서 아들러 심리학에 더 알아보고 프로이트와 융은 어떠한 심리학을 펼쳤는지 더 궁금해졌습니다. 사실 전 심리학에 대해선 잘 몰랐지만 프로이트와 융은 들어본 적이 있습니다. 아마 아들러를 들어본 사람은 드물어도 프로이트와 융은 한번쯤 들어본 적이 있을 것 같다고 생각합니다.</p>

<p>항상 우리는 원인이 있으면 결과가 있다라고 생각을 합니다. 프로이트는 트라우마 이론을 주장했다고 합니다. 과거에 입은 마음의 상처가 현재 일어나는 불행의 원인이 된다고 생각을 하는게 그 트라우마 이론이고 실제로 많은 사람들이 당연한 것처럼 생각하는걸 아들러는 부정했습니다. 아들러는 <strong>“경험에 의해 결정되는 것이 아니라, 경험에 부여한 의미에 따라서 자신을 결정하는 것”</strong>(책의 원문입니다.)이라고 주장했습니다. 즉 불행한 마음은 과거의 경험으로 만들어지는게 아니라 그 경험에 부여한 의미로 인하여 불행해진다는 것입니다. 그 말은 의미를 바꾸면 불행한 것이 행복해질수도 있다는게 됩니다.</p>

<p>사실 아직도 제 내적으로는 이 이론을 제 상황에 겹쳐서 여러가지 생각을 하고 있습니다. 처음엔 이것에 대해 반신반의했고 부정하기도 했고… 책의 전체를 읽은 지금은 이 이야기가 굉장히 흥미로운 이야기라고 생각합니다. 이 책을 읽고 나서 아들러라는 사람에 대해서, 또 다른 의견이었던 프로이트와 융에 대해서도 관심이 더 가기 시작했습니다.</p>

<h3 id="section-4">부정하다가 뒤집힐 것만 같았던 책에서 공감을 한 부분</h3>

<p>이 책을 읽으면서 저도 그렇고 수많은 사람들이 청년과 비슷할 것 같다는 생각이 듭니다. 물론 사람마다 다를 수도 있겠지만요. 하지만 인간 관계에 있어서는 꽤 공감한 것 같습니다.</p>

<p>어떠한 사람을 싫어하게 되면 그 사람이 어떤 행동을 해도 싫고 미울 때가 있습니다. 그럴 때 우리는 아예 정말 싫은 부분만 보게 되고, 좋은 것을 봐도 좋게 보이지 않게 됩니다. 그게 경험에 의해서 결정된게 아니라 부여한 의미에 따라서 달리 보인다는 것입니다.</p>

<p>또한 아들러는 모든 인간 관계(심지어는 부모 자식과 상사와 부하 직원까지도)에 대해서 평등함을 주장했습니다. 그것을 바탕으로 타인의 과제를 버리라고 합니다. 결국 자신의 과제가 어디까지임을 알고 타인의 과제에 침범하지 않으려고 하는 것에 대해서는 사실 이 책을 읽기 전부터 생각해왔던 부분이라 놀랍기도 했고 공감하기도 했습니다.</p>

<h3 id="section-5">“나는 어떻게 바뀌었는가?”</h3>

<p>사실 이 책을 읽는다고 해서 하루만에 사람이 변할 수는 없습니다. 물론 이 책이 많은 생각들을 하게 해주고 있습니다만 점점 부정적이던 사고가 긍정적으로 바뀌고 있다는 점에서 굉장히 놀랍고, “인생을 살아가는 의미가 무엇일까?”라는 질문에 대해서 아무한테도 들을 수 없는 대답을 들었습니다.</p>

<p>아마 제가 여유가 된다면, 또 병원에서 혼나지 않는다면 많은 심리학(주로 아들러의 사상에 대한) 책을 다시 찾지 않을까 생각됩니다. 제가 심리학 전체에 대해서 계속 관심을 두게된 계기가 되었고, 약간 (아직 너무 어리지만) 살면서 느꼈던 고민이 해소된 것 같다고 생각합니다. 두서 없게 글을 못 쓴 것 같아서 죄송하고 또 여기까지 읽어주셔서 감사합니다. 정말 책 맨 뒤에 홍보 문구처럼 100권의 자기계발서보다 이 책이 훨씬 낫고, 처음에는 부정할 수도 있지만 끝까지 읽어보면 생각이 깊어질 수 있지 않을까 생각합니다.</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>독후감-미움받을-용기-를-읽고서</wp:post_id>
            <wp:post_date>2015-12-16 09:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
        <item>
            <title>[번역] Android 개발을 수주해서 Kotlin을 제대로 써봤더니 최고였다.</title>
            <link>http://realignist.me/code/2015/10/17/translated-kotlin-was-awesome.html</link>
            <pubDate>Sat, 17 Oct 2015 09:00:00 +0900</pubDate>
            <dc:creator>haze-lee</dc:creator>
            <guid isPermaLink="false">http://realignist.me/code/2015/10/17/translated-kotlin-was-awesome.html</guid>
            <description/>
            <content:encoded>
                <![CDATA[<h2 id="section">글에 앞서</h2>

<p>이 글은 일본의 omochimetaru님이 Qiita에 올린 <a href="http://qiita.com/omochimetaru/items/98e015b0b694dd97f323">Android 개발을 수주해서 Kotlin을 제대로 써봤더니 최고였다.</a>라는 글을 번역해서 만들었습니다. 번역을 흔쾌히 허락해주신 omochimetaru님께 감사하다는 말씀 드립니다. 또한 글에서 한국에서는 쓰이지 않는 표현들 등에 대해서는 의역이 섞여있습니다. 이 점 양해 부탁드립니다. 늦은 시간까지 오역을 찾고 번역의 질을 높이는데 많은 도움을 주시고 오히려 저보다 많이 고생해주신 이상한모임의 pluulove님, chiyodad님, lemonade님께도 감사하다는 말씀 드립니다. 읽어주셔서 감사합니다.</p>

<h2 id="kotlin---">Kotlin을 실무 프로젝트에서 사용했습니다.</h2>

<p>며칠 전, 제가 소속된 <a href="http://qoncept.co.jp/">Qoncept</a>에서 <a href="http://www.real-toso.jp/">“리얼 술래잡기”x후지큐 하이랜드 거대 유원지에서부터의 도주</a>를 개발했고 출시했습니다.</p>

<p>후지큐 하이랜드에서 실제 술래잡기를 하는데, 일반 손님들이 스마트폰으로 전용 애플리케이션을 사용하며 클리어하는 것을 목표로 하는 기획이었습니다. 유원지에는 도깨비 역할의 스태프와 게임 진행에 관련된 시설이 있습니다. 그것들과 스마트폰이 iBeacon(Bluetooth LE)을 사용하여 연동하며 데미지를 입는거나, 아이템을 쓰거나, 퀴즈를 푸는 것 등을 할 수 있습니다.</p>

<p>Qoncept의 개발 범위는 iOS 앱(과 애플워치용 앱), 안드로이드 앱, 서버사이드였습니다.</p>

<p>수주가 확정된 시점에서 남은 개발 기간과 개발자 인원에 비해 전체 개발 범위가 꽤 컸기 때문에 어떻게하면 기간 내에 맞출 수 있을까 검토하였습니다. 그 당시에는 iOS는 Swift를 이용해서 Objective-C보다 쾌적한 개발이 가능해졌었지만 Android에서의 Java를 이용한 개발에는 부담감을 가지고 있었습니다. 그래서 생각해낸 것이 Kotlin이었습니다. 이전부터 이따금씩 들었던지라 어쩐지 좋은 언어 같다는 인식이 있었습니다. Kotlin을 쓰려면 지금이 적기라고 생각하며 공식 사이트의 문서를 단숨에 읽어보았습니다. 이거라면 할 수 있겠다고 판단해서, <strong>iOS 앱은 Swift로 개발하고 동시에 Android에는 Kotlin으로 이식하여 구현하는 것</strong>을 방침으로 삼았습니다.</p>

<p>최종적으로는 스케쥴에도 정확히 맞출 수 있었고, 앱도 안정적이었습니다. 게다가 <a href="https://twitter.com/real_toso">손님들로부터의 평가</a>도 좋았기 때문에 행복하게 마무리 되었다 생각합니다.</p>

<h3 id="kotlin--">Kotlin 진짜 최고</h3>

<p>서문이 길어졌지만, 앞서 이야기했던 것과 같이 Kotlin으로 제대로 개발해봤더니 Kotlin이 최고라는 것을 만끽할 수 있었습니다. (iOS 앱은 다른 분이 개발하셨고, Android 앱으로의 이식은 제가 담당했습니다.)
이런 마음이 더욱 부풀어 올라서, Kotlin 개발자가 늘어나 널리 보급되어 앞으로도 Kotlin이 진화하고 보완될 수 있으면 좋겠다는 생각으로 Kotlin을 전파하기 위해 이번 글을 쓰게 되었습니다.</p>

<p>아래에서는 Kotlin을 주로 Android 개발에, Swift로부터의 이식, 실무에서의 사용을 중점적으로 해서 소개하고자 합니다.</p>

<h4 id="section-1">버전</h4>

<p>실제 프로젝트 당시에는 M11 버전으로 구현했습니다.
글을 쓴 시점에서 M14 버전이 나왔으며, 알아차린 범위 내에서 M14 버전에 맞는 내용으로 글을 쓰고 있습니다.</p>

<h2 id="section-2">언어 주변 환경</h2>

<p>언어의 사양을 보기 전에 우선, Kotlin이라는 언어의 주변 환경에 대해 먼저 써보겠습니다.</p>

<h3 id="section-3">후원하는 기업은 어떤 기업인가?</h3>

<p>취미로 개발하는 것과는 달리 실무 개발의 경우 유명하지 않은 언어는 개발이 중단되거나 나중에 언어가 없어지는 위험 부담이 있습니다. 이 점에서 Kotlin은 대중적으로 인지도는 떨어지지만 오픈 소스로 만들어지고 있기 때문에, 갑자기 컴파일러 같은 것들을 받을 수 없게 되는 일은 없을 것으로 여겨집니다.</p>

<p>또한, 개발을 주도하고 있는 업체는 Jetbrains입니다. Jetbrains는 IntelliJ IDEA라고 하는 IDE를 개발하고 판매하는 회사로 유명합니다. Java IDE를 개발하고 있는 수준이기 때문에, 컴파일러와 관련된 기술력이나 프로그래밍 언어에 대한 이해는 상당할 것이라고 생각합니다. Android의 개발 환경이 Eclipse + ADT에서 Android Studio로 전환된지 오래지만, 이 Android Studio는 IntelliJ를 Android 개발을 위하여 고친 버전입니다. 구글이 이렇게 개발 환경을 변경한 것도, Jetbrains에 대한 신뢰를 높이는데 일조하고 있습니다.</p>

<h3 id="section-4">도입이 간단하다.</h3>

<p>새로운 언어를 도입하고자 할 때는 개발 환경 구축에 문제가 생겨 시간이 오래 걸리고, 제대로 된 개발 환경이 갖춰져 있지 않을 때 오히려 언어 자체의 개발 생산성을 개발 환경이 상쇄할 수 있는 우려가 있습니다.</p>

<p>Kotlin은 이 부분이 재미있습니다. 우선 IDE에 연동하기 위한 IntelliJ(Android Studio)용 플러그인을 Jetbrains에서 제공하고 있습니다. 같은 회사에서 IDE와 언어를 만들기 떄문에 각종 지원이 확실합니다. Swift + XCode에서는 할 수 없는 Refactor rename 등의 기능도 기본적으로 제공하고 있습니다.</p>

<p>플러그인은 <code class="highlighter-rouge">Android Studio &gt; Preferences &gt; Plugins &gt; Install Jetbrains Plugin &gt; Kotlin</code>에서 설치할 수 있습니다. 새로운 버전의 플러그인이 나왔을 때는 Android Studio가 알려주기 때문에 간단하게 업데이트할 수 있습니다.</p>

<p>프로젝트 빌드에 도입하는 것 또한 간단합니다.</p>

<p><code class="highlighter-rouge">Android Studio &gt; Tools &gt; Kotlin &gt; Configure Kotlin in Project</code>를 클릭하면 다이얼로그가 나와서, OK 버튼을 누르면 자동으로 설치합니다. 그러면 애플리케이션 모듈의 gradle 파일이 아래처럼 바뀝니다.</p>

<h5 id="kotlin---1">Kotlin 도입 전</h5>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.application'</span>

<span class="n">android</span> <span class="o">{</span>
    <span class="n">compileSdkVersion</span> <span class="mi">22</span>
    <span class="n">buildToolsVersion</span> <span class="s2">"22.0.1"</span>

    <span class="n">defaultConfig</span> <span class="o">{</span>
        <span class="n">applicationId</span> <span class="s2">"jp.co.qoncept.apptest"</span>
        <span class="n">minSdkVersion</span> <span class="mi">18</span>
        <span class="n">targetSdkVersion</span> <span class="mi">22</span>
        <span class="n">versionCode</span> <span class="mi">1</span>
        <span class="n">versionName</span> <span class="s2">"1.0"</span>
    <span class="o">}</span>
    <span class="n">buildTypes</span> <span class="o">{</span>
        <span class="n">release</span> <span class="o">{</span>
            <span class="n">minifyEnabled</span> <span class="kc">false</span>
            <span class="n">proguardFiles</span> <span class="nf">getDefaultProguardFile</span><span class="o">(</span><span class="s1">'proguard-android.txt'</span><span class="o">),</span> <span class="s1">'proguard-rules.pro'</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span> <span class="nf">fileTree</span><span class="o">(</span><span class="nl">dir:</span> <span class="s1">'libs'</span><span class="o">,</span> <span class="nl">include:</span> <span class="o">[</span><span class="s1">'*.jar'</span><span class="o">])</span>
    <span class="n">compile</span> <span class="s1">'com.android.support:appcompat-v7:22.2.0'</span>
<span class="o">}</span></code></pre></figure>

<h5 id="kotlin---2">Kotlin 도입 후</h5>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'com.android.application'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'kotlin-android'</span>

<span class="n">android</span> <span class="o">{</span>
    <span class="n">compileSdkVersion</span> <span class="mi">22</span>
    <span class="n">buildToolsVersion</span> <span class="s2">"22.0.1"</span>

    <span class="n">defaultConfig</span> <span class="o">{</span>
        <span class="n">applicationId</span> <span class="s2">"jp.co.qoncept.apptest"</span>
        <span class="n">minSdkVersion</span> <span class="mi">18</span>
        <span class="n">targetSdkVersion</span> <span class="mi">22</span>
        <span class="n">versionCode</span> <span class="mi">1</span>
        <span class="n">versionName</span> <span class="s2">"1.0"</span>
    <span class="o">}</span>
    <span class="n">buildTypes</span> <span class="o">{</span>
        <span class="n">release</span> <span class="o">{</span>
            <span class="n">minifyEnabled</span> <span class="kc">false</span>
            <span class="n">proguardFiles</span> <span class="nf">getDefaultProguardFile</span><span class="o">(</span><span class="s1">'proguard-android.txt'</span><span class="o">),</span> <span class="s1">'proguard-rules.pro'</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">sourceSets</span> <span class="o">{</span>
        <span class="n">main</span><span class="o">.</span><span class="na">java</span><span class="o">.</span><span class="na">srcDirs</span> <span class="o">+=</span> <span class="s1">'src/main/kotlin'</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span> <span class="nf">fileTree</span><span class="o">(</span><span class="nl">dir:</span> <span class="s1">'libs'</span><span class="o">,</span> <span class="nl">include:</span> <span class="o">[</span><span class="s1">'*.jar'</span><span class="o">])</span>
    <span class="n">compile</span> <span class="s1">'com.android.support:appcompat-v7:22.2.0'</span>
    <span class="n">compile</span> <span class="s2">"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"</span>
<span class="o">}</span>

<span class="n">buildscript</span> <span class="o">{</span>
    <span class="n">ext</span><span class="o">.</span><span class="na">kotlin_version</span> <span class="o">=</span> <span class="s1">'0.13.1514'</span>
    <span class="n">repositories</span> <span class="o">{</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="n">dependencies</span> <span class="o">{</span>
        <span class="n">classpath</span> <span class="s2">"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">repositories</span> <span class="o">{</span>
    <span class="n">mavenCentral</span><span class="o">()</span>
<span class="o">}</span></code></pre></figure>

<p>나머지는 빌드해주면, Gradle 스크립트가 Kotlin 컴파일러의 다운로드부터 환경 설정까지 자동으로 전부 알아서 해줍니다. 새로운 버전의 Kotlin이 나왔다면 <code class="highlighter-rouge">ext.kotlin_version</code> 부분을 고쳐주면 됩니다.</p>

<h3 id="java---">Java와의 연계 기능이 강력하다.</h3>

<p>개발 언어를 변경하는 경우 지금까지 써오던 언어와의 동시 사용이 어렵거나, 원활하지 않을 경우 기존 프로젝트에 추가로 도입할 수도 없으며 과거의 코드 리소스가 낭비되고, 만에 하나 문제가 발생하는 경우를 피할 수가 없습니다.</p>

<p>그 점에서 볼 때 Kotlin은 Java와의 연계 능력이 정말로 강력합니다. Scala나 Groovy와 마찬가지로 Java 바이트코드로 컴파일되어서, JVM 위에서 구동될 수 있습니다.</p>

<p>언어 사양에서 우선 Java와의 연계가 중요시되고 있으며, 기존 Java 기반 프로젝트에 Kotlin 소스를 섞어서 사용할 수 있도록 되어있습니다. 또, Kotlin에서 자연스럽게 Java의 클래스나 메소드를 호출할 수 있습니다. 공식 사이트에서도 <a href="http://kotlinlang.org/">100% interoperable with Java</a>라고 나와있습니다. Kotlin을 잘 쓰지 못하더라도, 그 부분만 기존 Java 소스 코드로 쓰는 것 또한 가능합니다.</p>

<h2 id="section-5">언어 소개</h2>

<h3 id="section-6">타입 추론을 지원하는 정적 타이핑</h3>

<p>Kotlin은 타입 추론을 지원하는 정적 타이핑 언어입니다. Swift도 그렇지만, Java하고는 다릅니다. 타입 추론은 기본이죠.</p>

<h3 id="section-7">외형</h3>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"Hello, world!"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>세미콜론 없는 스타일, 코드 블록은 중괄호로 여닫는 스타일, 형태 표기는 Pascal 스타일(변수, 콜론, 자료형의 순서)을 볼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">var</span> <span class="py">sum</span> <span class="p">=</span> <span class="m">0</span>

<span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">).</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}.</span><span class="n">forEach</span> <span class="p">{</span>
  <span class="n">sum</span> <span class="p">+=</span> <span class="n">it</span>
<span class="p">}</span>

<span class="n">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span></code></pre></figure>

<p>클로져의 경우 중괄호<code class="highlighter-rouge"><span class="p">{}</span></code>만 쓰기 때문에 마지막 인자의 클로져를 함수 호출 뒤에 쓰고, 그 때 인자가 없으면 소괄호<code class="highlighter-rouge">()</code>를 생략할 수 있습니다.</p>

<p>이쪽의 구문 사양이 Swift와 동일하기 때문에, 이식 작업이 편해집니다.</p>

<h3 id="optional-nullable">Optional (Nullable)</h3>

<p>자료형으로 null을 참조할 수 있는 자료형과 없는 자료형이 구분됩니다. 타입을 검사하고 내용이 null인지 아닌지를 확인하면 그 시점에서 내용의 자료형으로 형변환됩니다. 일반적으로 이런 기능들을 제공할 떄 Optional이라고 하는데 Kotlin에서는 이 기능을 Nullable이라고 합니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">getLengthOfString</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">getLengthOfStringOpt</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getLengthOfString</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="m">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">getLengthOfString</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">getLengthOfStringOpt</span><span class="p">(</span><span class="s">"world"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">getLengthOfStringOpt</span><span class="p">(</span><span class="k">null</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"$a, $b, $c"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Nullable 자료형은 자료형의 오른쪽에 물음표<code class="highlighter-rouge">?</code>를 붙여 표기합니다. Swift의 Optional과 같아서 기쁩니다. Java의 언어 기능에 Optional은 존재하지 않습니다. 아마 NullPointerException으로 죽겠죠.</p>

<h4 id="section-8">약간 특이한 부분</h4>

<p>Nullable의 Nullable을 만들 수가 없습니다. 그냥 Nullable이 되어버립니다.
Swift에서 Optional의 Optional이 나올 때 어떻게 이식할지 고민하게 됩니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">?):</span> <span class="n">Int</span><span class="p">??</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">desc</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">??)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">"None"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">"Some(None)"</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">"Some(Some($a))"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">??</span> <span class="p">=</span> <span class="n">wrap</span><span class="p">(</span><span class="k">null</span><span class="p">)</span>
    <span class="n">desc</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// Some(None)이 나와야하지만, None이 되어버린다.
</span><span class="p">}</span></code></pre></figure>

<h3 id="smart-casts">플로우 기반 형변환 (Smart Casts)</h3>

<p>if 문에서 null인지를 체크하거나, is 연산자를 통해 타입을 검사하면 Kotlin에서는 그것을 고려해서 자동으로 형변환됩니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">open</span> <span class="kd">class</span> <span class="kt">Animal</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="kt">Cat</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fun</span> <span class="nf">nyaa</span><span class="p">()</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="s">"nyaa"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">Dog</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fun</span> <span class="nf">wan</span><span class="p">()</span> <span class="p">{</span> <span class="nf">println</span><span class="p">(</span><span class="s">"wan"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">fun</span> <span class="nf">speak</span><span class="p">(</span><span class="nv">animal</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">animal</span> <span class="k">is</span> <span class="kt">Cat</span><span class="p">)</span> <span class="p">{</span> <span class="n">animal</span><span class="o">.</span><span class="nf">nyaa</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">animal</span> <span class="k">is</span> <span class="kt">Dog</span><span class="p">)</span> <span class="p">{</span> <span class="n">animal</span><span class="o">.</span><span class="nf">wan</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">fun</span> <span class="nf">speak2</span><span class="p">(</span><span class="nv">animal</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">animal</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"null"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nf">speak</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">fun</span> <span class="nf">main</span><span class="p">(</span><span class="nv">args</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="kt">Cat</span><span class="p">())</span> <span class="c1">// nyaa라고 나옴</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="kt">Dog</span><span class="p">())</span> <span class="c1">// wan이라고 나옴</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="n">null</span><span class="p">)</span> <span class="c1">// null이라고 나옴</span>
<span class="p">}</span></code></pre></figure>

<p>speak2의 앞 부분에서 null 인지를 체크하고 return 하고 있으므로 if 이후 <code class="highlighter-rouge">Animal?</code>이 아니라 <code class="highlighter-rouge">Animal</code> 자료형으로 변했으며, speak가 호출될 수 있습니다. speak의 if문의 분기에서 is를 이용한 체크를 통해 서브클래스인 <code class="highlighter-rouge">Cat</code>이나 <code class="highlighter-rouge">Dog</code>로 변해있으며 전용 메소드를 호출할 수 있습니다.</p>

<p>동일한 코드에 대한 Swift 버전은 아래와 같습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Animal</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="kt">Cat</span><span class="p">:</span> <span class="kt">Animal</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">nyaa</span><span class="p">()</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"nyaa"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">Dog</span><span class="p">:</span> <span class="kt">Animal</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">wan</span><span class="p">()</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"wan"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">speak</span><span class="p">(</span><span class="nv">animal</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">animal</span> <span class="o">=</span> <span class="n">animal</span> <span class="k">as?</span> <span class="kt">Cat</span> <span class="p">{</span> <span class="n">animal</span><span class="o">.</span><span class="nf">nyaa</span><span class="p">()</span> <span class="p">}</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">animal</span> <span class="o">=</span> <span class="n">animal</span> <span class="k">as?</span> <span class="kt">Dog</span> <span class="p">{</span> <span class="n">animal</span><span class="o">.</span><span class="nf">wan</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">speak2</span><span class="p">(</span><span class="nv">animal</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">animal</span> <span class="o">=</span> <span class="n">animal</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"null"</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nf">speak</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="kt">Cat</span><span class="p">())</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="kt">Dog</span><span class="p">())</span>
    <span class="nf">speak2</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>speak2에서는 이를 위해 일부러 guard 문이라는 것을 사용하지 않으면 안됩니다. speak, speak2 둘 다 <code class="highlighter-rouge">let animal = </code>을 쓰는 것이 중복됩니다. if 괄호를 생략할 수 있는 것은 좋네요.</p>

<p>Java에서는 아마 아래와 같이 되겠죠.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">nyaa</span><span class="o">()</span> <span class="o">{</span> <span class="n">Ideone</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"nyaa"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">wan</span><span class="o">()</span> <span class="o">{</span> <span class="n">Ideone</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"wan"</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Ideone</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">(</span><span class="n">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">animal</span> <span class="k">instanceof</span> <span class="n">Cat</span><span class="o">){</span>
            <span class="n">Cat</span> <span class="n">cat</span> <span class="o">=</span> <span class="o">(</span><span class="n">Cat</span><span class="o">)</span><span class="n">animal</span><span class="o">;</span>
            <span class="n">cat</span><span class="o">.</span><span class="na">nyaa</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">animal</span> <span class="k">instanceof</span> <span class="n">Dog</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="o">(</span><span class="n">Dog</span><span class="o">)</span><span class="n">animal</span><span class="o">;</span>
            <span class="n">dog</span><span class="o">.</span><span class="na">wan</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">speak2</span><span class="o">(</span><span class="n">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">animal</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="s">"null"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">speak</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Exception</span> <span class="o">{</span>
        <span class="n">speak2</span><span class="o">(</span><span class="k">new</span> <span class="n">Cat</span><span class="o">());</span>
        <span class="n">speak2</span><span class="o">(</span><span class="k">new</span> <span class="n">Dog</span><span class="o">());</span>
        <span class="n">speak2</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>null 체크에 관련해서는 그저 코드가 올바르길 기도하고 실행하는 수밖에 없습니다. 그리고 speak의 내용은 <code class="highlighter-rouge">Cat</code>과 <code class="highlighter-rouge">Dog</code>가 각각 세 번씩 나옵니다. (형변환용 메소드를 만든다면 2번 + null 체크로 줄일 수는 있겠지만요.)</p>

<h3 id="unsafe-cast">Unsafe cast</h3>

<p>Nullable이 null일 땐 충돌이 나는 내용의 추출과 타입이 다를 경우에는 충돌하는 형변환이 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">?,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Animal</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">c</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">a</span><span class="o">!!</span> <span class="c1">// null이라면 Exception
</span>    <span class="kd">val</span> <span class="py">d</span><span class="p">:</span> <span class="n">Cat</span><span class="p">?</span> <span class="p">=</span> <span class="n">b</span> <span class="k">as</span><span class="p">?</span> <span class="n">Cat</span> <span class="c1">// Cat이 아니라면 null
</span>    <span class="kd">val</span> <span class="py">e</span><span class="p">:</span> <span class="n">Cat</span> <span class="p">=</span> <span class="n">b</span> <span class="k">as</span> <span class="n">Cat</span> <span class="c1">// Cat이 아니라면 Exception
</span><span class="p">}</span></code></pre></figure>

<p>Swift에서는 아래와 같이 작성할 수 있겠죠.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">hoge</span><span class="p">(</span><span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?,</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Animal</span><span class="p">?)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">c</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">!</span> <span class="c1">// nil이라면 Exception</span>
    <span class="k">let</span> <span class="nv">d</span><span class="p">:</span> <span class="kt">Cat</span><span class="p">?</span> <span class="o">=</span> <span class="n">b</span> <span class="k">as?</span> <span class="kt">Cat</span> <span class="c1">// Cat이 아니라면 nil</span>
    <span class="k">let</span> <span class="nv">e</span><span class="p">:</span> <span class="kt">Cat</span> <span class="o">=</span> <span class="n">b</span> <span class="k">as!</span> <span class="kt">Cat</span> <span class="c1">// Cat이 아니라면 Exception</span>
<span class="p">}</span></code></pre></figure>

<p>Kotlin에서는 두개의 느낌표<code class="highlighter-rouge">!</code>로 처리합니다. Swift에서는 한개죠.
위험한 as에서는 Swift에서는 느낌표가 붙어있습니다.</p>

<h3 id="optional--">Optional의 메소드 호출</h3>

<p>Kotlin에서는 Optional로 둘러쌓인 값의 메소드를 호출할 때, 값이 있다면 메소드를 호출할 수 있고 null일 경우에는 null값이 필요할 때, if문에서의 타입 체크를 하지 않고도 다음과 같이 작성할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="n">user</span><span class="o">?.</span><span class="n">name</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"name=$name"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Elvis 연산자를 사용하면 null인 경우 기본값을 지정할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">user</span><span class="o">?.</span><span class="n">name</span> <span class="o">?:</span> <span class="s">"no name"</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"name=$name"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Swift에서도 물음표 + 점<code class="highlighter-rouge">?.</code>으로 쓰이는 메소드 호출이 있습니다. 또한 elvis 연산자에 대해서는 Swift에서는 물음표 두개<code class="highlighter-rouge">??</code>입니다.
비슷해보이는 두 언어지만, 물음표 + 점<code class="highlighter-rouge">?.</code>을 연속해서 사용할 때에는 구문 트리가 달라집니다.
사용자 이름의 문자 수를 가져오는 경우를 생각해보세요.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">"tanaka"</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">?)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="n">user</span><span class="o">?.</span><span class="n">name</span><span class="o">?.</span><span class="n">length</span><span class="p">())</span>
<span class="p">}</span></code></pre></figure>

<p>Kotlin에서는 <code class="highlighter-rouge">?.</code>가 두번 나옵니다. 이것은 다음과 같이 해석할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="p">(</span> <span class="n">user</span><span class="o">?.</span><span class="n">name</span> <span class="p">)</span><span class="o">?.</span><span class="n">length</span><span class="p">()</span></code></pre></figure>

<p><code class="highlighter-rouge">?.</code>을 쓰지 않는 경우에는 아래와 같이 쓸 수 있겠습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">null</span> <span class="p">}</span>
<span class="kd">val</span> <span class="py">length</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">name</span><span class="p">.</span><span class="n">length</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">null</span> <span class="p">}</span></code></pre></figure>

<p>마찬가지를 Swift에서는 아래와 같이 표현할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"tanaka"</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hoge</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">?)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">user</span><span class="p">?</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>name 뒤에 <code class="highlighter-rouge">?.</code>가 Swift에서는 <code class="highlighter-rouge">.</code>로 나와있습니다. 이것은 아래와 같이 해석되기 때문입니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">user</span><span class="p">?</span><span class="o">.</span><span class="p">(</span> <span class="n">name</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span> <span class="p">)</span></code></pre></figure>

<p>하지만, 이 괄호는 개념을 설명하기 위해서 임의로 만든 것이며 Swift로는 올바른 문법이 아닙니다. 고쳐서 쓴다면 아래와 같습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">if</span> <span class="k">let</span> <span class="nv">user</span> <span class="o">=</span> <span class="n">user</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">characters</span><span class="o">.</span><span class="n">count</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span></code></pre></figure>

<p>정리하면 다음과 같습니다. Kotlin의 경우 <code class="highlighter-rouge">?.</code>을 다음 번만의 키워드만 처리하고 그 결과를 다음에도 사용합니다. Swift의 경우에는 <code class="highlighter-rouge">?.</code>을 오른쪽 모두를 묶어버리며 None일 경우 오른쪽 모두를 스킵합니다. 이 차이는 똑같은 외형의 코드가 전혀 다른 의미를 가지게 된다는 뜻이므로 이식하는데는 주의할 필요가 있습니다.</p>

<p>개인적으로는 Kotlin의 사양이 더 직관적이고 좋았습니다. 처음 Swift로 개발했을 때 Kotlin의 사양을 상상하고 작업하다가 에러가 나서 당황했던 적이 있었습니다.</p>

<p>Java의 경우에는 첫 번째 인자로 리시버를 두 번째 인자로 오퍼레이터를 갖는 콜백 함수를 만들고 <code class="highlighter-rouge">?.</code> 동작을 에뮬레이트하는 것이 좋겠죠. if문을 쓰면 리시버의 식을 두 번 쓰지 않으면 안되기 때문입니다.</p>

<h3 id="optional---">메소드 호출은 아니지만, Optional에 체인 가능한 것들</h3>

<p>위에서 쓴 <code class="highlighter-rouge">?.</code>을 사용하면 Optional이어도 귀찮지 않게 코드를 짤 수 있습니다만 아래와 같이 <code class="highlighter-rouge">?.</code>로는 쓸 수 없지만 null이 아닌 경우 처리를 계속하고 싶은 케이스가 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">val</span> <span class="py">result</span><span class="p">:</span> <span class="n">Boolean</span>

<span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="p">=</span> <span class="n">write</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">result</span> <span class="p">=</span> <span class="k">false</span>
<span class="p">}</span></code></pre></figure>

<p>이런 케이스에서는 Kotlin에서는 다음과 같이 쓰는 것이 가능합니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">val</span> <span class="py">result</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="n">user</span><span class="o">?.</span><span class="n">let</span> <span class="p">{</span> <span class="n">write</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="o">?:</span> <span class="k">false</span></code></pre></figure>

<p>let의 정의와 구현은 다음과 같이 되어있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="k">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">let</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">R</span><span class="p">):</span> <span class="n">R</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="k">this</span><span class="p">)</span></code></pre></figure>

<p>이것은 모든 타입 T에서 정의된 확장 메소드로 인자로 클로져를 하나 가지고 있습니다. 그리고 그 클로져에 메소드의 리시버가 전달되어 불러질 것이고 그 자체가 let 자체의 값이 됩니다.</p>

<p>위의 예시에는 <code class="highlighter-rouge">?.</code>가 있으므로 let이 실행되는 것은 <code class="highlighter-rouge">User?</code>가 null이 아닌 경우입니다. it은 클로져의 암시적인 인자이므로 it은 <code class="highlighter-rouge">User</code>가 되는 것입니다. 그리고 write의 반환 값은 let의 반환 값이므로 기대했던대로 동작할 것입니다.</p>

<p>Swift의 경우에는 Optional 자체에 정의된 <code class="highlighter-rouge">flatMap</code> 메소드를 쓸 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="nf">write</span><span class="p">(</span><span class="nv">$0</span><span class="p">)</span> <span class="p">}</span> <span class="p">??</span> <span class="kc">false</span></code></pre></figure>

<p>이 경우에는 Optional 자체의 메소드임에도 불구하고 <code class="highlighter-rouge">?.</code>가 아닌 <code class="highlighter-rouge">.</code>이 됩니다.</p>

<h3 id="section-9">기본적인 콜백 함수</h3>

<p>기본적인 콜백 함수가 쓸 수 있습니다. 클로져가 <code class="highlighter-rouge"><span class="p">{}</span></code>로 표현되기 때문에 쉽게 쓸 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="p">(</span><span class="m">0</span><span class="o">..</span><span class="m">10</span><span class="p">)</span>
        <span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}</span>
        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}</span>
        <span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="p">-&gt;</span> 
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="p">!=</span> <span class="s">""</span><span class="p">)</span> <span class="n">s</span> <span class="p">+</span> <span class="s">"_"</span>  <span class="k">else</span> <span class="s">""</span><span class="p">)</span> <span class="p">+</span> <span class="n">i</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// 0_4_16_36_64_100가 나온다.
</span><span class="p">}</span></code></pre></figure>

<p>Swift도 비슷한 느낌으로 작성할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">...</span><span class="mi">10</span><span class="p">)</span>
    <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
    <span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">$0</span> <span class="o">!=</span> <span class="s">""</span> <span class="p">?</span> <span class="nv">$0</span> <span class="o">+</span> <span class="s">"_"</span> <span class="p">:</span> <span class="s">""</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="kt">String</span><span class="p">(</span><span class="nv">$1</span><span class="p">)</span>
    <span class="p">}</span>

<span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// 0_4_16_36_64_100가 나온다.</span></code></pre></figure>

<p>Java라면 이렇게 나오겠죠.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">rangeClosed</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
    <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> 
        <span class="o">(!</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">)</span> <span class="o">?</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">:</span> <span class="s">""</span><span class="o">)</span> <span class="o">+</span> <span class="n">i</span>
    <span class="o">,</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span><span class="o">);</span>

<span class="n">print</span><span class="o">(</span><span class="n">a</span><span class="o">);</span></code></pre></figure>

<p>Kotlin은 Swift의 클로져 리터럴과 함수를 호출할 때의 표기법이 비슷합니다. Swift 버전의 reduce의 내부는 한 줄로 쓰고 싶었습니다만 타입 추론에 타임아웃이 걸려서 컴파일하지 못했기 때문에 let으로 나눴습니다. Kotlin에서는 클로져의 암시적 인자는 인자가 1개일 때만 <code class="highlighter-rouge">it</code>을 쓸 수 있습니다. 복수일 때는 인자명이 필요합니다. Swift에서는 <code class="highlighter-rouge">$0</code>, <code class="highlighter-rouge">$1</code>, <code class="highlighter-rouge">$2</code>… 이런 식으로 쓰입니다. 또 Kotlin에서는 삼항연산자가 없지만 if문을 이용해서 쓸 수 있습니다.</p>

<h3 id="section-10">문자열 안에서의 변수 접근</h3>

<p>Kotlin에서는 문자열 안에서 <code class="highlighter-rouge">$</code>로 변수를, <code class="highlighter-rouge">${}</code>로 식을 호출할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"i is $i, user name is ${user.name}"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">$i</code> 부분이 변수가, <code class="highlighter-rouge">${user.name}</code> 부분이 식을 표시합니다. Swift에서는 <code class="highlighter-rouge">\()</code>로 쓸 수 있죠.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">hoge</span><span class="p">(</span><span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">user</span><span class="p">:</span> <span class="kt">User</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"i is </span><span class="se">\(</span><span class="n">i</span><span class="se">)</span><span class="s">, user name is </span><span class="se">\(</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Java에서는 이런 기능에 대한 문법이 없으니 아래와 같이 되겠죠.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">hoge</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"i is "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">", user name is "</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">hoge2</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">printf</span><span class="o">(</span><span class="s">"i is %d, user name is %s"</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">user</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<h3 id="java---sam-">Java의 단일 추상 메소드(SAM) 변환</h3>

<p>Java에서는 Java8이 나오면서 람다식과 단일 추상 메소드를 가지는 함수형 인터페이스라는 큰 기능이 추가되었습니다. 이것은 단일 메소드를 가지고 있는 인터페이스에서 람다식을 쓸 수 있게 됬다는 것을 의미합니다.</p>

<p>예를 들면, 아래가 Java7의 코드입니다. 안드로이드에서 자주 볼 수 있는 버튼의 클릭 핸들러를 설정하는 코드입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">button</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">View</span><span class="o">.</span><span class="na">OnClickListener</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"clicked"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>이게 Java8이라면 다음과 같이 표현할 수 있게 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">button</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="n">view</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"clicked"</span><span class="o">);</span>
<span class="o">});</span></code></pre></figure>

<p>이는 Java8에서 람다식을 도입함에 있어 Java7 이전에 있었던 코드의 낭비하거나 수정하지 않고도 람다식을 이용해 보다 쾌적하게 쓸 수 있게 되었습니다.</p>

<p>이렇게 람다식으로 자동 변환될 수 있는 인터페이스는 단일 메소드여야만 합니다.
그래서 이것을 단일 추상 메소드(Single Abstract Method), 줄여서 SAM이라고 칭하며 이 변환을 SAM 변환이라고 합니다.</p>

<p>Kotlin에서는 Java8과 마찬가지로 이 기능을 탑재하고 있습니다. 이 기능은 Java와 연계해서 Java 라이브러리를 사용하는데 없으면 안되는 중요한 기능 중 하나입니다.</p>

<h5 id="section-11">역주</h5>

<p>‘SAM 변환’이라는 말이 낯설게 느껴질 수 있는데, 이는 한국에서 잘 쓰이지 않기 때문입니다. 위에서 설명한 단일 추상 메소드를 가지고 있는 인터페이스에 대해 람다식을 쓸 수 있는 기능은 Java8의 중요한 신기능입니다. Kotlin에서는 이 기능을 Java8 이전인 Java6, 7에서도 쓸 수 있습니다. 이는 Android가 아직 Java8을 공식적으로 지원하지 않기 때문에 Kotlin이 주목을 받는 이유 중 하나이기도 합니다. Android를 Java로 개발할 때에는 대안으로 RetroLambda라고 하는, 컴파일 시 바이트코드를 수정해서 쓸 수 있게 하는 라이브러리가 존재합니다.</p>

<p>위에 예시는 Kotlin에서는 아래와 같이 쓸 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="n">button</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span> <span class="n">view</span> <span class="p">-&gt;</span>
    <span class="n">println</span><span class="p">(</span><span class="s">"clicked"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>쓰기 쉬워 좋네요. 위의 예에서는 인수가 클로져 한개일 뿐이라 함수 호출 괄호<code class="highlighter-rouge">()</code>를 생략했습니다.</p>

<h3 id="section-12">확장 메소드</h3>

<p>Kotlin에서는 기존 클래스에 대해 메소드를 추가해 확장하는 것이 가능합니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">Int</span><span class="p">.</span><span class="n">square</span><span class="p">():</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">this</span> <span class="p">*</span> <span class="k">this</span>
<span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">evens</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">withIndex</span><span class="p">().</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">index</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>
<span class="k">fun</span> <span class="nf">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;.</span><span class="n">squareEvens</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">evens</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="m">3</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">square</span><span class="p">())</span> <span class="c1">// 9라고 출력
</span>
    <span class="kd">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"d"</span><span class="p">,</span> <span class="s">"e"</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">evens</span><span class="p">())</span> <span class="c1">// [a, c, e]라고 출력
</span>
    <span class="kd">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">,</span> <span class="m">50</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">squareEvens</span><span class="p">())</span> <span class="c1">// [100, 900, 2500]라고 출력
</span><span class="p">}</span></code></pre></figure>

<p>제너릭 자료형의 확장 메소드에 관해서는 T 모두에 대한 것과 특정 T에 대한 정의가 가능합니다. 함수의 본문은 <code class="highlighter-rouge">=</code> 스타일로 써봤습니다.</p>

<p>Swift에서는 다음과 같이 쓸 수 있겠습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">IntegerType</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">square</span><span class="p">()</span><span class="o">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">self</span> <span class="o">*</span> <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">evens</span><span class="p">()</span><span class="o">-&gt;</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">enumerate</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">index</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">element</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="kt">Array</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">IntegerType</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">squareEvens</span><span class="p">()</span><span class="o">-&gt;</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">evens</span><span class="p">()</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="nf">square</span><span class="p">()</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="nf">square</span><span class="p">())</span> <span class="c1">// 9라고 출력</span>

    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="p">[</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"d"</span><span class="p">,</span> <span class="s">"e"</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="nf">evens</span><span class="p">())</span> <span class="c1">// ["a", "c", "e"]라고 출력</span>

    <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="nf">squareEvens</span><span class="p">())</span> <span class="c1">// [100, 900, 2500]라고 출력</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>Element에 대한 제약은 프로토콜에 필요가 있으므로 <code class="highlighter-rouge">Int</code>로 쓸 수 없어서 그 대신 <code class="highlighter-rouge">IntegerType</code>으로 되어있습니다. 이유를 잘 모르겠습니다.</p>

<p>Kotlin도 Swift도 둘 다 프로퍼티를 추가하는 것이 가능합니다. 이식했을 때는 <code class="highlighter-rouge">withIndex</code>와 <code class="highlighter-rouge">enumerate</code>가 대응되어서 기뻤습니다.</p>

<p>Java에는 확장 메소드라는 개념이 없기 때문에 첫 번째 인수에 this를 가지는 정적 메소드로 구현해야되겠죠.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">intSquare</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">listEvens</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">())</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">intListSquareEvens</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">listEvens</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">intSquare</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Exception</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="n">print</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">intSquare</span><span class="o">(</span><span class="n">a</span><span class="o">));</span> <span class="c1">// 9라고 출력</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">listEvens</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">,</span> <span class="s">"e"</span><span class="o">));</span>
        <span class="n">print</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span> <span class="c1">// [a, c, e]라고 출력</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">intListSquareEvens</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">50</span><span class="o">));</span>
        <span class="n">print</span><span class="o">(</span><span class="s">""</span> <span class="o">+</span> <span class="n">c</span><span class="o">);</span> <span class="c1">// [100, 900, 2500]라고 출력</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 방식이 괴로운 것은 충돌을 피하고자 메소드 이름에 접두사가 필요하다는 점과 호출할 때 <code class="highlighter-rouge">f(g(h(x)))</code>라는 형식이 되므로 나중에 적용하는 함수일수록 앞에 오는 등의 문제가 있습니다. 특히 이식을 할 때에는 원래 메소드 체인의 형태로 되어있다면 기술 순서가 완전히 거꾸로 되어버리기 때문에 매우 번거로운 작업이 됩니다. 개인적으로는 이 부분이 가독성도 떨어트린다고 생각합니다.</p>

<p>또, 이 코드는 <code class="highlighter-rouge">withIndex</code>에 대응하는 방법을 몰랐기 때문에 얼버무려 쓴 코드입니다.</p>

<h3 id="section-13">오퍼레이터 오버로드</h3>

<p>Kotlin에서는 오퍼레이터 오버로드라는 기능이 존재합니다. 하지만 직접 메소드 이름에 연산자를 표기하는 Swift와 C++과는 달리 Kotlin에서는 미리 정해진 연산자에 해당하는 이름의 메소드를 operator 키워드와 함께 구현합니다. 스스로 연산자를 추가할 수는 없지만 인수가 하나인 메소드를 삽입할 수 있는 기능이 있으므로 키워드로 연산자를 추가하는 것은 할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">data class</span> <span class="nc">Vector2</span><span class="p">(</span><span class="kd">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="kd">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">operator</span> <span class="k">fun</span> <span class="nf">plus</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">Vector2</span><span class="p">):</span> <span class="n">Vector2</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">+</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>
    <span class="k">fun</span> <span class="nf">dot</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">Vector2</span><span class="p">):</span> <span class="n">Double</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="n">o</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">y</span> <span class="p">*</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="s">"($x, $y)"</span>
<span class="p">}</span>

<span class="k">operator</span> <span class="k">fun</span> <span class="nf">Double</span><span class="p">.</span><span class="n">times</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">Vector2</span><span class="p">):</span> <span class="n">Vector2</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="k">this</span> <span class="p">*</span> <span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="k">this</span> <span class="p">*</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">1.0</span><span class="p">,</span> <span class="m">2.0</span><span class="p">)</span> <span class="p">+</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">3.0</span><span class="p">,</span> <span class="m">4.0</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// (4.0, 6.0)라고 출력
</span>
    <span class="kd">val</span> <span class="py">b</span> <span class="p">=</span> <span class="m">3.0</span> <span class="p">*</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0.0</span><span class="p">,</span> <span class="m">1.0</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">// (0.0, 3.0)라고 출력
</span>
    <span class="kd">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">2.0</span><span class="p">,</span> <span class="m">0.0</span><span class="p">)</span> <span class="n">dot</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">2.0</span><span class="p">,</span> <span class="m">3.0</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">// 4.0라고 출력
</span><span class="p">}</span></code></pre></figure>

<p>덧셈은 메소드로 곱셈은 Double 자료형의 확장 메소드로 썼습니다. <code class="highlighter-rouge">dot</code>은 보통의 방법입니다만 중간에 저렇게 사용할 수 있습니다.
데이터 클래스와 기본 생성자의 기능도 쓰고 있습니다.</p>

<p>Swift로도 써봤습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Vector2</span><span class="p">:</span> <span class="kt">CustomStringConvertible</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="k">let</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Double</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">x</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="n">_</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">"(</span><span class="se">\(</span><span class="n">x</span><span class="se">)</span><span class="s">, </span><span class="se">\(</span><span class="n">y</span><span class="se">)</span><span class="s">)"</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="o">+</span><span class="p">(</span><span class="nv">l</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">,</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">)</span><span class="o">-&gt;</span> <span class="kt">Vector2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Vector2</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="o">*</span><span class="p">(</span><span class="nv">l</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">)</span><span class="o">-&gt;</span> <span class="kt">Vector2</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Vector2</span><span class="p">(</span><span class="n">l</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">infix</span> <span class="k">operator</span> <span class="err">●</span> <span class="p">{</span> 
    <span class="k">associativity</span> <span class="k">left</span>
    <span class="k">precedence</span> <span class="mi">140</span> 
<span class="p">}</span>

<span class="kd">func</span> <span class="err">●</span><span class="p">(</span><span class="nv">l</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">,</span> <span class="nv">r</span><span class="p">:</span> <span class="kt">Vector2</span><span class="p">)</span><span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">l</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">r</span><span class="o">.</span><span class="n">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// (4.0, 6.0)라고 출력</span>

    <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">// (0.0, 3.0)라고 출력</span>

    <span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="err">●</span> <span class="kt">Vector2</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">// 4.0라고 출력</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>●은 유니코드 문자입니다. 이번 예시에서는 Swift의 기능을 이용해 이 마크를 연산자로 정의했습니다.</p>

<p>Kotlin은 연산자를 만드는 것은 불가능하기 때문에 Swift에서 정의된 독자 연산자의 이식은 메소드로 합니다.
하지만, 연산자 우선 순위까지 이식할 수 없기 때문에 소괄호<code class="highlighter-rouge">()</code>를 붙여 나갈 필요가 있겠죠.</p>

<p>Java에서는 이런 기능을 쓸 수 없기 때문에 확장 메소드와 마찬가지로 이식할 때 매우 불편합니다.</p>

<h3 id="section-14">프로퍼티</h3>

<p>Kotlin의 필드같은 것들은 모두 프로퍼티입니다.
상수는 val, 변수는 var로 정의하며, val에는 getter를, var에는 getter와 setter를 정의할 수 있습니다.
getter와 setter를 구현하기 위한 지원 필드가 자동으로 정의되며 field라고 하는 키워드로 액세스할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">Int</span>
    <span class="kd">var</span> <span class="py">familyName</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">"야마다"</span>
    <span class="kd">var</span> <span class="py">firstName</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">"타로"</span>

    <span class="kd">val</span> <span class="py">fullName</span><span class="p">:</span> <span class="n">String</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="s">"$familyName $firstName"</span>
    <span class="kd">var</span> <span class="py">died</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">field</span> <span class="p">}</span>
        <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">field</span> <span class="p">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">println</span><span class="p">(</span><span class="s">"${fullName}는 죽어버렸다..."</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">id</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">id</span> <span class="p">=</span> <span class="n">id</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">u</span> <span class="p">=</span> <span class="n">User</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
    <span class="n">u</span><span class="p">.</span><span class="n">familyName</span> <span class="p">=</span> <span class="s">"사이토"</span>
    <span class="n">u</span><span class="p">.</span><span class="n">died</span> <span class="p">=</span> <span class="k">true</span> <span class="c1">// 사이토 타로는 죽어버렸다... 라고 표시됩니다.
</span><span class="p">}</span></code></pre></figure>

<p>위의 예에서 <code class="highlighter-rouge">id</code>는 상수이기 때문에 getter가 자동 생성되었고, <code class="highlighter-rouge">familyName</code>, <code class="highlighter-rouge">firstName</code>은 변수이기 때문에 getter와 setter가 자동으로 생성된 것을 볼 수 있습니다.
<code class="highlighter-rouge">fullName</code>은 getter를 직접 만들어서 다른 프로퍼티로부터 동적으로 가져올 수 있도록 했습니다. <code class="highlighter-rouge">died</code>는 getter와 setter를 직접 만들어서 지원 필드를 사용했습니다.</p>

<p>Swift에서도 필드와 같은 것은 프로퍼티입니다. getter, setter 뿐만이 아니라 <code class="highlighter-rouge">willSet</code>과 <code class="highlighter-rouge">didSet</code>같은 것들도 정의할 수 있습니다. 하지만 Kotlin처럼 지원 필드는 자동으로 정의되지 않습니다.</p>

<p>Kotlin에서는 <code class="highlighter-rouge">didSet</code>과 같은 언어 기능은 존재하지 않기 때문에 이식은 setter에서 에뮬레이트하는 방식을 이용합니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">var</span> <span class="nv">familyName</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"yamada"</span>
    <span class="k">var</span> <span class="nv">firstName</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"taro"</span>

    <span class="k">var</span> <span class="nv">fullName</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">familyName</span><span class="se">)</span><span class="s"> </span><span class="se">\(</span><span class="n">firstName</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">var</span> <span class="nv">died</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">died</span> <span class="p">{</span>
                <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">fullName</span><span class="se">)</span><span class="s">는 죽어버렸다..."</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">id</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">u</span> <span class="o">=</span> <span class="kt">User</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">u</span><span class="o">.</span><span class="n">familyName</span> <span class="o">=</span> <span class="s">"saito"</span>
    <span class="n">u</span><span class="o">.</span><span class="n">died</span> <span class="o">=</span> <span class="kc">true</span> <span class="c1">// saito taro는 죽어버렸다... 라고 표시됩니다.</span>
<span class="p">}</span>

<span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>Java에서는 필드와 프로퍼티는 명확하게 구분되어있으며 메소드로 직접 getter과 setter를 구현한 것을 프로퍼티라고 부릅니다.</p>

<p>이 부분이 이식할 때 귀찮은 일이 되어버립니다. Swift로 쓰인 다음 클래스가 있다고 생각해봅시다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">died</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hoge</span><span class="p">(</span><span class="nv">u</span><span class="p">:</span> <span class="kt">User</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">u</span><span class="o">.</span><span class="n">died</span> <span class="o">=</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></figure>

<p>이것을 Java의 필드로 이식해보겠습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">died</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">hoge</span><span class="o">(</span><span class="n">User</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">u</span><span class="o">.</span><span class="na">died</span> <span class="o">=</span> <span class="kc">true</span>
<span class="o">}</span></code></pre></figure>

<p>그 뒤에 Swift 코드가 이렇게 변했다고 칩시다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">User</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">died</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="k">didSet</span> <span class="p">{</span>
        <span class="nf">println</span><span class="p">(</span><span class="s">"죽어버렸다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>이런 경우 Java에서는 다음과 같이 수정해야합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">died</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="nf">getDied</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">died</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">setDied</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">died</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"죽어버렸다!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">hoge</span><span class="o">(</span><span class="n">User</span> <span class="n">u</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">u</span><span class="o">.</span><span class="na">setDied</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>getter와 setter를 직접 구현해야 하는 것은 둘째치고, 필드에 대입하고 있는 부분을 setter를 호출할 때 구현해야 할 필요가 있습니다.</p>

<p>이것은 여러 부분에 있습니다만 원래 이식하는 곳에서는 diff가 발생하지 않기 때문에 놓칠 위험이 큽니다. 간과해버렸다간 버그가 나며 심지어 컴파일했을 때 알 수도 없습니다.</p>

<p>만약 10번 있는 대입에 한 곳만의 지원을 잊어버린다면 이건 매우 귀찮은 버그가 될 것입니다. 그러므로 프로퍼티가 있는 언어에서 이식한다면 프로퍼티가 있는 언어로 이식하는게 바람직합니다.</p>

<h3 id="java----1">Java 프로퍼티 접근자의 프로퍼티화</h3>

<p>Java에서 필드 <code class="highlighter-rouge">name</code>에 대해 <code class="highlighter-rouge">name</code>이라는 프로퍼티를 만들 때는 getter로 <code class="highlighter-rouge">String getName ()</code>과 setter로 <code class="highlighter-rouge">void setName(String name)</code>을 정의합니다.
그리고 호출 시, 아래와 같이 함수 호출의 형태를 취합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 읽기</span>
<span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
<span class="c1">// 쓰기</span>
<span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">newName</span><span class="o">);</span></code></pre></figure>

<p>하지만 Kotlin의 경우에는 프로퍼티 <code class="highlighter-rouge">name</code>에 대해서 호출할 때 함수의 형태를 띄지 않습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="c1">// 읽기
</span><span class="kd">val</span> <span class="py">name</span> <span class="p">=</span> <span class="n">user</span><span class="p">.</span><span class="n">name</span>
<span class="c1">// 쓰기
</span><span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">newName</span></code></pre></figure>

<p>함수 호출의 형태는 아닙니다만 name에 대한 getter와 setter가 동작하게 됩니다.</p>

<p>Kotlin에서 Java 메소드를 호출할 때 이러한 <code class="highlighter-rouge">getXxxx()</code>와 <code class="highlighter-rouge">setXxxx(value)</code>를 Kotlin의 프로퍼티 <code class="highlighter-rouge">xxxx</code>를 취급할 때 엑세스할 수 있습니다.
예를 들어, 아래코드는 안드로이드에서 버튼을 보이지 않게 만드는 코드입니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="n">button</span><span class="p">.</span><span class="n">visibility</span> <span class="p">=</span> <span class="n">View</span><span class="p">.</span><span class="n">INVISIBLE</span></code></pre></figure>

<p>Android SDK는 Java로 작성되었으므로 원래는 <code class="highlighter-rouge">setVisibility()</code>를 호출하는게 맞지만, Kotlin에서는 마치 <code class="highlighter-rouge">visibility</code>라는 프로퍼티에 접근하는 것처럼 사용할 수 있습니다.</p>

<h3 id="delegated-property">Delegated Property</h3>

<p>Delegated Property는 Kotlin의 재미있는 기능입니다. 프로퍼티의 getter와 setter의 구현을 다른 객체에 넘기는 것이 가능합니다.</p>

<h4 id="lazy">Lazy</h4>

<p>예로 Lazy를 들어보겠습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">val</span> <span class="py">fullName</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">lazy</span> <span class="p">{</span>
    <span class="n">familyName</span> <span class="p">+</span> <span class="s">" "</span> <span class="p">+</span> <span class="n">firstName</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">fullName</code>은 상수이지만, 처음 getter가 호출되었을 때 lazy에 전달하는 클로져가 실행되고 그 결과가 반환됩니다. 두번째 이후부터 getter 호출에서는 첫번째 결과가 저장됩니다. 만약 이것을 Java로 구현하고자 할 때는, getter에서 if문을 작성해야만 합니다. 이러한 일반적으로 중복되는 코드를 쓸 필요가 없습니다.</p>

<p>Swift에서도 <code class="highlighter-rouge">lazy</code>라는 키워드가 있고 동일한 기능을 제공하는 언어 기능이 있습니다. 그러나 Kotlin이 흥미로운 점은 lazy가 특별한 언어 기능이 아니라 <code class="highlighter-rouge">by</code>만이 언어 기능으로, lazy는 그저 <a href="http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html">클로져를 인수로 취하는 표준 라이브러리 함수</a>인 것입니다. 이 함수가 반환하는 객체가 실제 프로퍼티의 getter와 setter를 처리합니다.</p>

<h4 id="notnull">notNull</h4>

<p><strong>이 문단은 오래되었습니다. M13에서부터는 lateinit을 사용하는 편이 더 좋다고 생각됩니다.</strong></p>

<p>또 한 가지, 흥미로운 델리게이트를 소개해보곘습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">notNull</span><span class="p">()</span></code></pre></figure>

<p>이것은 한번 설정되지 않은 상태에서 getter가 호출될 경우 예외가 생겨 크래시가 납니다. 한번 설정된 이후에는 getter가 일반적으로 값을 읽어올 수 있습니다.
Swift에서 이와 비슷한 형태를 갖는 것은 느낌표<code class="highlighter-rouge">!</code> 형태입니다. 정확하게 말하자면 <code class="highlighter-rouge">Implicitly Unwrapped Optional</code>이라고 말합니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="o">!</span></code></pre></figure>

<p>이것은 초기 상태가 nil로 nil의 상태로 읽었을 때는 크래시가 나지만 값이 들어있을 때는 보통과 똑같이 사용할 수 있습니다.
Kotlin과의 미묘한 차이는 Kotlin은 notNull에 null을 넣을 수 없지만 Swift의 <code class="highlighter-rouge">!</code>에는 nil을 넣을 수 있다는 것이겠네요.
Swift의 <code class="highlighter-rouge">!</code>는 어디까지나 Optional이라는 것이군요.</p>

<p>그러나 대부분의 경우 일부러 nil을 넣는 일을 하지 않기 때문에 이식하는데는 크게 문제가 없습니다.
보통 그런 일은 Optional에다가 하는 것이 더 바람직하니까요.</p>

<p>이 경우도 Swift에서는 언어 기능이지만 Kotlin에서는 표준 라이브러리가 제공하는 구현입니다.
재미있습니다.</p>

<h4 id="kotterknife">KotterKnife</h4>

<p>Android 앱을 만들 때 제일 많은 부분이 View의 바인딩인데, ButterKnife를 만든 사람이 <a href="https://github.com/JakeWharton/kotterknife">KotterKnife</a>라고 하는 Kotlin 버전의 ButterKnife를 제공하고 있습니다.</p>

<h5 id="section-15">역주</h5>

<p>ButterKnife를 만든 사람은 Square라는 결제 관련 POS 시스템을 만드는 회사에 있는 Jake Wharton이라는 분입니다. ButterKnife는 리소스나 뷰의 바인딩을 쉽게 도와주는 라이브러리로, 안드로이드 개발자들에게 Jake Wharton은 예전부터 다양한 라이브러리로 유명했었습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="kd">class</span> <span class="nc">PersonView</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">:</span> <span class="n">AttributeSet</span><span class="p">?)</span> <span class="p">:</span> <span class="n">LinearLayout</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">firstName</span><span class="p">:</span> <span class="n">TextView</span> <span class="k">by</span> <span class="n">bindView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">first_name</span><span class="p">)</span>
  <span class="kd">val</span> <span class="py">lastName</span><span class="p">:</span> <span class="n">TextView</span> <span class="k">by</span> <span class="n">bindView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">last_name</span><span class="p">)</span>

  <span class="c1">// Optional binding.
</span>  <span class="kd">val</span> <span class="py">details</span><span class="p">:</span> <span class="n">TextView</span><span class="p">?</span> <span class="k">by</span> <span class="n">bindOptionalView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">details</span><span class="p">)</span>

  <span class="c1">// List binding.
</span>  <span class="kd">val</span> <span class="py">nameViews</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TextView</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">bindViews</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">last_name</span><span class="p">)</span>

  <span class="c1">// List binding with optional items being omitted.
</span>  <span class="kd">val</span> <span class="py">nameViews</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">TextView</span><span class="p">&gt;</span> <span class="k">by</span> <span class="n">bindOptionalViews</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">middle_name</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">last_name</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">@IBOutlet</code>이나 <code class="highlighter-rouge">!</code>를 사용한 iOS 개발과, 어노테이션과 리플렉션으로 구현된 Android의 ButterKnife보다 이 방식이 깔끔하고 바람직하다고 생각됩니다.
또한 빌드에 개입하는 것으로 확장 메소드를 구현해주고, 프로퍼티 정의조차 불필요한 플러그인이 있습니다.</p>

<p>나는 이런 언어기능이 바람직하다고 생각합니다.</p>

<h3 id="lateinit">lateinit</h3>

<p>프로퍼티에 대한 한정자로 <code class="highlighter-rouge">lateinit</code>을 사용하면, 초기값이 불필요한 Optional이 아닌 변수를 정의할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="k">lateinit</span> <span class="kd">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span>
<span class="p">}</span></code></pre></figure>

<p>lateinit으로 지정되어있는 변수는 쓰기 전에 읽으면 크래시가 납니다. Swift의 <code class="highlighter-rouge">!</code>처럼 사용할 수 있습니다.</p>

<h4 id="delegatenotnull-">Delegate.notNull과의 차이</h4>

<p>Delegate.notNull과의 차이는 잘 모르겠습니다. 문서에 따르면 lateinit은 자연스럽게 필드명을 만들어서 DI 도구와의 궁합이 좋다고 쓰여있습니다.
아마도 자동생성 바이트코드나 리플렉션에 대한 부분이 아닐까 생각합니다.</p>

<p>하지만 Kotlin 코드 만의 세계에서 보면 그 차이는 중요하지 않습니다.</p>

<p>유일하게 찾아낸 것은 lateinit는 상수에는 사용하지 못하고 변수에만 사용할 수 있습니다. notNull는 상수에도 사용할 수 있습니다.</p>

<p>그러나 notNull가 상수에 사용하는 것은 충돌 가능성만 있고 혜택은 전혀 없기 때문에 상수에서의 사용이 금지 된 lateinit 쪽이 안전하고 약간 우수하다고 생각합니다.</p>

<p>위에서 말한 이유로 notNull이 언어 기능에 의존하지 않는 매력이지만 lateinit을 쓰는 편이 더 바람직해보입니다.</p>

<h3 id="declaration-site-variance">제네릭과 Declaration Site Variance</h3>

<p>Kotlin은 제네릭을 지원하고 있습니다. 제네릭형 매개변수의 variance에 대해서는 Declaration Site Variance라고 칭하고 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">open</span> <span class="kd">class</span> <span class="nc">Animal</span>
<span class="kd">class</span> <span class="nc">Cat</span><span class="p">:</span> <span class="n">Animal</span><span class="p">()</span>

<span class="kd">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;(</span><span class="kd">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="s">"Box($value)"</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Animal</span><span class="p">&gt;</span>
    <span class="kd">val</span> <span class="py">b</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Cat</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">(</span><span class="n">Cat</span><span class="p">())</span>
    <span class="n">a</span> <span class="p">=</span> <span class="n">b</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// Box(Cat@xxxxxxxx)로 표시
</span><span class="p">}</span></code></pre></figure>

<p>Variance가 작동하고 있으므로 Box의 값을 Box의 변수에 대입할 수 있습니다.</p>

<p>Declaration Site라고 하는 것은 선언 시에 지정하는 것으로 Box의 변수형 파라미터 T를 쓰는 그 자리에서 <code class="highlighter-rouge">out T</code>라고 기술함으로써 Box가 T에 대해 covariance라고 선언하고 있습니다.
이 out을 지우면 컴파일 에러가 발생합니다. Swift도 Declaration Site지만, Java는 Use Site입니다.</p>

<p>Java로 위의 예를 쓰면 다음과 같습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{}</span>

<span class="kd">class</span> <span class="nc">Box</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Box</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Box("</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span> <span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Exception</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">Box</span><span class="o">&lt;</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">Animal</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">;</span>
        <span class="kd">final</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;(</span><span class="k">new</span> <span class="n">Cat</span><span class="o">());</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
        <span class="n">print</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> <span class="c1">// Box(Cat@xxxxxxxx)라고 출력된다.</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Box 자체의 정의에 대한 Variance에 대해 적지 않고 <code class="highlighter-rouge">a</code>라는 로컬 변수를 정의할 때의 형태를 꺽쇠 기호<code class="highlighter-rouge">&lt;&gt;</code>로 설명하고 있습니다. 그 외 함수 인수의 정의에서 꺽쇠 기호가 나옵니다.</p>

<p>Declaration Site와 Use Site의 좋고 나쁨에 대해서는 여기까지만 이야기하겠습니다. 저는 Declaration Site 쪽을 선호하기 때문에 Kotlin을 선호합니다. 그 외 Swift나 C#, Go 또한 Declaration Site입니다.</p>

<p>Swift도 동일하기 때문에 Swift로부터 이식하기 쉽습니다. 그러나 Swift에서 Java로의 이식은 꽤나 힘듭니다. 선언은 한 곳에서 함에도 불구하고 사용 부분(함수 인수나 지역 변수)은 많이 있어서 이론적으로는 그것을 <code class="highlighter-rouge">? extends T</code>나 <code class="highlighter-rouge">? super T</code>로 쓰지 않으면 올바르게 이식되지 않습니다.</p>

<p>Variance를 버리고 컴파일 에러가 나는 곳만을 고치는 일이 생길 수도 있습니다.</p>

<h3 id="section-16">클로져와 전역 탈출</h3>

<p>Kotlin의 클로져는 생각지도 못한 기능을 가지고 있습니다. 다음 코드는 다른 언어에 익숙한 사람에게는 의미불명으로 보입니다.
또한 <code class="highlighter-rouge">forEach</code>는 클로져를 하나의 인수로 취하여 리시버의 요소 하나하나에 대하여 클로져를 호출합니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hasZeros</span><span class="p">(</span><span class="n">ints</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Boolean</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">true</span> <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">false</span>
<span class="p">}</span></code></pre></figure>

<p>사실 이 코드는 <code class="highlighter-rouge">forEach</code>에 쓰여진 <code class="highlighter-rouge">return true</code>가 그 클로져 자신이 아닌 <code class="highlighter-rouge">fun hasZeros()</code>를 탈출하는 것입니다. 원래 Kotlin의 클로져 안에는 return을 쓸 수 없습니다. 클로져의 실행 결과는 클로져 코드 마지막의 식의 값입니다.</p>

<p>예외적으로 인라인된 콜백 함수에서는 <code class="highlighter-rouge">return</code>을 쓸 수 있고 그 경우에는 return을 호출한 곳에서부터 가장 가까운 함수를 탈출하게 됩니다.</p>

<p>forEach의 구현은 다음과 같습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="k">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">Iterable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">forEach</span><span class="p">(</span><span class="n">operation</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span> <span class="n">operation</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>이 <code class="highlighter-rouge">fun</code> 앞에 있는 <code class="highlighter-rouge">inline</code>이 포인트입니다. 이것이 붙어있으면 함수가 인라인이라는 것을 뜻하는데, 이 함수를 호출하는 곳에 이 함수의 내용이 쓰여지는 것과 같습니다. 즉 위의 예시는 아래와 같이 해석된다고 보면 됩니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">hasZeros</span><span class="p">(</span><span class="n">ints</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Boolean</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">true</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">false</span>
<span class="p">}</span></code></pre></figure>

<p>이걸로 왜 전역 탈출이 가능하게 되었는지 알 수 있었습니다. 또한 <code class="highlighter-rouge">inline</code>의 지정은 무턱대고 있는 것이 아닙니다. 인라인할 수 없는 함수에 붙어있을 경우에는 컴파일 에러가 납니다.</p>

<p>그래서 이 전역 탈출이라는 기능은 위험한 냄새가 납니다. 올바르게 사용할 때만 구현해서 이용할 수 있으며 그렇지 않을 경우에는 컴파일 에러가 나기 때문에 안전합니다.</p>

<p>이게 가능하기 때문에 <code class="highlighter-rouge">forEach</code>도 그렇습니다만 콜백 함수를 정의하여 제어 구문을 자작할 수 있는 효과가 있습니다.</p>

<p>예를 들면 <code class="highlighter-rouge">run</code>이라고 하는 표준 함수가 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="k">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">R</span><span class="p">&gt;</span> <span class="n">run</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">R</span><span class="p">):</span> <span class="n">R</span> <span class="p">=</span> <span class="n">f</span><span class="p">()</span></code></pre></figure>

<p>인수로 주어진 클로져만을 실행하기 위한 함수이지만, 이것은 로컬 스코프를 만드는데 사용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">fun</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">run</span> <span class="p">{</span>
        <span class="n">val</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">createPoint</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">run</span> <span class="p">{</span>
        <span class="n">val</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"taro"</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">createUser</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"ok!"</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>위의 예에서는 2개의 x는 각각 다른 클로져의 지역 변수이므로 충돌하지 않습니다.
그리고 <code class="highlighter-rouge">createPoint</code>가 실패했을 때 <code class="highlighter-rouge">setup</code> 자체를 중단하고 있습니다.</p>

<p>Swift에서 똑같이 콜백 함수를 사용하고자 하면 그 안에 return을 쓸 수 없게 되기 때문에 <code class="highlighter-rouge">for in</code>이나 <code class="highlighter-rouge">if true {}</code>를 사용하지 않을 수 없습니다.</p>

<p>반대로 말하면 이런 것들을 사용하면 구문과 같은 것들을 만들 수 있다는 뜻이 됩니다.
run에서는 사실 또 정의가 있고 그것을 사용하면 이런 코드를 만들 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">""</span>
    <span class="kd">var</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">user</span><span class="p">.</span><span class="n">run</span> <span class="p">{</span>
        <span class="n">name</span> <span class="p">=</span> <span class="n">makeUserName</span><span class="p">()</span> <span class="o">?:</span> <span class="k">return</span>
        <span class="n">age</span> <span class="p">=</span> <span class="m">3</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><code class="highlighter-rouge">run</code>의 안에서 액세스 되어있는 <code class="highlighter-rouge">name</code>이나 <code class="highlighter-rouge">age</code>는 <code class="highlighter-rouge">user</code>의 프로퍼티입니다.
이 클로져의 안은 User의 메소드를 실행할 때와 같은 this 스코프입니다. 그리고 당연한 이야기지만 그 안에서도 전역 탈출을 쓸 수 있습니다.</p>

<p>이것의 구현은 아래와 같습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">public</span> <span class="k">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">T</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">R</span><span class="p">):</span> <span class="n">R</span> <span class="p">=</span> <span class="n">f</span><span class="p">()</span></code></pre></figure>

<p>모든 타입 T에 대한 확장 메소드 run으로 정의되어 있으며 인수의 클로져의 자료형은 T의 메소드, 즉 리시버로 T 자료형의 인스턴스를 받도록 되어있습니다.
본체의 <code class="highlighter-rouge">f()</code>는 확장 메소드의 정의 중이기 때문에 <code class="highlighter-rouge">this.f()</code>의 축약형입니다.</p>

<p>클로져의 형태가 run의 인수에 따라서 T 자료형의 메소드의 형태로 해결하고 있으므로 콜백 메소드 안에서 name과 age가 <code class="highlighter-rouge">this.</code> 없이 접근할 수 있는 것입니다.</p>

<p>이 클로져의 메소드 형태에 대한 해결책이 정말 강력합니다. 더 복잡한 응용 예는 다음과 같습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">result</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">=</span>
  <span class="n">html</span> <span class="p">{</span>
    <span class="n">head</span> <span class="p">{</span>
      <span class="n">title</span> <span class="p">{+</span><span class="s">"XML encoding with Kotlin"</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="n">body</span> <span class="p">{</span>
      <span class="n">h1</span> <span class="p">{+</span><span class="s">"XML encoding with Kotlin"</span><span class="p">}</span>
      <span class="n">p</span>  <span class="p">{+</span><span class="s">"this format can be used as an alternative markup to XML"</span><span class="p">}</span>

      <span class="c1">// an element with attributes and text content
</span>      <span class="n">a</span><span class="p">(</span><span class="n">href</span> <span class="p">=</span> <span class="s">"http://kotlinlang.org"</span><span class="p">)</span> <span class="p">{+</span><span class="s">"Kotlin"</span><span class="p">}</span>

      <span class="c1">// mixed content
</span>      <span class="n">p</span> <span class="p">{</span>
        <span class="p">+</span><span class="s">"This is some"</span>
        <span class="n">b</span> <span class="p">{+</span><span class="s">"mixed"</span><span class="p">}</span>
        <span class="p">+</span><span class="s">"text. For more see the"</span>
        <span class="n">a</span><span class="p">(</span><span class="n">href</span> <span class="p">=</span> <span class="s">"http://kotlinlang.org"</span><span class="p">)</span> <span class="p">{+</span><span class="s">"Kotlin"</span><span class="p">}</span>
        <span class="p">+</span><span class="s">"project"</span>
      <span class="p">}</span>
      <span class="n">p</span> <span class="p">{+</span><span class="s">"some text"</span><span class="p">}</span>

      <span class="c1">// content generated by
</span>      <span class="n">p</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">arg</span> <span class="k">in</span> <span class="n">args</span><span class="p">)</span>
          <span class="p">+</span><span class="n">arg</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure>

<p>이걸 보면 HTML을 간단한 문법으로 쓰고 있는 것 같아도 이건 엄연히 Kotlin 코드입니다. 게다가 body 태그는 html 태그에 쓰기 같은 것들이 정적 타이핑 검사되고 있습니다.</p>

<p><a href="http://kotlinlang.org/docs/reference/type-safe-builders.html">자세한 내용은 문서를 읽어보십시오.</a></p>

<p>그런데 전역이 아닌 클로져를 중단하고 싶은 로컬한 return을 쓰고 싶을 때가 있습니다. 그런 경우에는 또 다른 클로져 표기법을 쓸 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">,</span><span class="m">4</span><span class="p">).</span><span class="n">forEach</span><span class="p">(</span><span class="k">fun</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>    
<span class="p">})</span>
<span class="p">//</span> <span class="m">13</span><span class="err">이</span> <span class="err">출력됩니다</span><span class="p">.</span></code></pre></figure>

<p><code class="highlighter-rouge">fun</code> 표기가 있으면 인라인과는 전혀 관계 없이 클로져에서 항상 return을 사용할 수 있습니다. 그리고 로컬한 return이 됩니다. 아까 말했듯이 return을 호출한 곳에서부터 가장 가까운 함수를 탈출한다는 규칙에도 맞습니다.</p>

<h3 id="section-17">기본 생성자</h3>

<p>Kotlin에서는 생성자를 다중 정의할 수 있습니다. 그리고 특별한 기본 생성자는 생성자를 하나만 만들 수 있습니다.
이 생성자가 있는 경우에는 다른 생성자는 결국 기본 생성자를 호출할 수밖에 없습니다.</p>

<p>그리고 기본 생성자는 인수 정의와 동시에 속성 정의를 할 수 있는데, 이 기능이 꽤 유용합니다. 키워드를 한 번 쓰는 것만으로 되니까요.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Person</span><span class="p">(</span><span class="kd">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="kd">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="kd">val</span> <span class="py">height</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init</span> <span class="p">{</span>
        <span class="c1">// 기본 생성자의 본문입니다.
</span>        <span class="n">print</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">constructor</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="k">this</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">170.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 2차 생성자의 본문입니다.
</span>        <span class="n">print</span><span class="p">(</span><span class="s">"2"</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">constructor</span><span class="p">():</span> <span class="k">this</span><span class="p">(</span><span class="s">"saito"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 2차 생성자의 또 다른 하나입니다. 다른 2차 생성자를 호출하고 있습니다.
</span>        <span class="n">print</span><span class="p">(</span><span class="s">"3"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">Person</span><span class="p">(</span><span class="s">"yamada"</span><span class="p">,</span> <span class="m">19</span><span class="p">,</span> <span class="m">160.0</span><span class="p">)</span> <span class="c1">// 1이 출력됩니다.
</span>    <span class="n">println</span><span class="p">()</span>
    <span class="n">Person</span><span class="p">(</span><span class="s">"tanaka"</span><span class="p">)</span> <span class="c1">// 12가 출력됩니다.
</span>    <span class="n">println</span><span class="p">()</span>
    <span class="n">Person</span><span class="p">()</span> <span class="c1">// 123이 출력됩니다.
</span>    <span class="n">println</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>기본 생성자의 인수로 있는 상수가 프로퍼티 정의를 지정합니다.</p>

<p>기본 생성자를 정의하지 않는 것 또한 가능합니다.</p>

<p>Swift의 경우에는 지정 이니셜라이저(Designated Initializer)와 편의 이니셜라이저(Convience Initializer)가 있습니다.
Kotlin과 같이, 편의 이니셜라이저는 지정 이니셜라이저를 호출할 필요가 있습니다.
Kotlin하고는 다르게 지정 이니셜라이저를 다중 정의할 수도 있습니다.</p>

<p>생성자에서 프로퍼티 정의 구문이 없기 때문에 프로퍼티, 생성자의 인수, 생성자의 본문에서 왼쪽 값, 오른쪽 값으로 총 4번 동일한 키워드를 쓸 수밖에 없습니다.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="k">let</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span>
    <span class="k">let</span> <span class="nv">height</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">height</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 기본 생성자 1</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
        <span class="k">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">_</span> <span class="nv">age</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">height</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 기본 생성자 2</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">self</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span>
        <span class="k">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="kt">Double</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 2차 생성자 1</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mf">170.0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 2차 생성자 2</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="s">"saito"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>이식의 관점에서 보면 Swift에서 지정 이니셜라이저가 다수 있어도 프로퍼티를 모두 채울 기본 생성자를 만들고 나머지 지정 이니셜라이저와 편의 이니셜라이저를 보조로 쓰면 크게 문제되지 않는다고 생각됩니다.</p>

<p>Java의 경우 Swift와 거의 비슷한 규칙이지만 convenience같은 키워드는 존재하지 않네요.</p>

<h3 id="section-18">특별한 자료형</h3>

<p>Kotlin만이 가지고 있는 특별한 자료형에 대해 소개해보고자 합니다.</p>

<h4 id="any">Any</h4>

<p>Any는 모든 자료형를 취할 수 있는 자료형입니다. 하지만 Optional 자료형은 취할 수 없습니다.
제네릭형의 매개변수를 정의할 때 null을 제거할 때 쓰입니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">NonNullBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span>
<span class="kd">class</span> <span class="nc">NullableBox</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span></code></pre></figure>

<p><code class="highlighter-rouge">NonNullBox</code>에는 Optional 자료형이 들어갈 수 없지만 <code class="highlighter-rouge">NullableBox</code>는 들어갈 수 있습니다.</p>

<h4 id="unit">Unit</h4>

<p>Unit은 값이 하나 밖에 없고, 다른 형식으로 독립한 자료형입니다.
C의 void와 Swift의 Void 등에 대응하며, 함수 반환 값의 자료형을 생략했을 때는 Unit이 반환됩니다.
Unit 자료형의 값은 Unit입니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">a</span><span class="p">():</span> <span class="n">Unit</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Unit</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">b</span><span class="p">():</span> <span class="n">Unit</span> <span class="p">{</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="k">fun</span> <span class="nf">c</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span></code></pre></figure>

<p>여기서 <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, <code class="highlighter-rouge">c</code>는 모두 같은 의미입니다.</p>

<p>역으로 Kotlin엔 void라는 개념이 존재하지 않습니다.</p>

<h4 id="nothing">Nothing</h4>

<p>Nothing은 값이 존재하지 않고 다른 모든 타입에 할당할 수 있는 자료형입니다. Any는 모든 자료형를 대입할 수 있지만 그것과 반대로 되어있습니다.
값이 존재하지 않기 때문에 함수의 반환 값으로 지정하면 들어가면 절대로 탈출하지 않는 함수가 됩니다. 값이 존재하지 않기 때문에 반환 값을 return 할 수 없기 때문입니다.</p>

<p>다음과 같은 코드를 컴파일 할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">fun</span> <span class="nf">crash</span><span class="p">():</span> <span class="n">Nothing</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">Exception</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">mainLoop</span><span class="p">(</span><span class="n">proc</span><span class="p">:</span> <span class="p">()-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">Nothing</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">proc</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>이외에도 Nothing의 값이 존재하지 않는 것을 이용하여 <code class="highlighter-rouge">null</code>에만 매칭되는 변수의 형태를 만들 수 있습니다. 예를 들면 다음과 같습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Json</span> <span class="p">{</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">aNull</span><span class="p">:</span> <span class="n">Nothing</span><span class="p">?)</span> <span class="p">{}</span>
    <span class="k">constructor</span><span class="p">(</span><span class="n">aString</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span></code></pre></figure>

<p>이렇게 하면 <code class="highlighter-rouge">Json(null)</code>은 첫 번째 생성자, <code class="highlighter-rouge">Json("aaa")</code>는 두번째 생성자라는 식으로 오버로드를 구분할 수 있습니다. Kotlin에서는 null 자체에는 자료형이 없기 때문에 이렇게 Nothing을 사용하고 있습니다.</p>

<p>그런데 값이 존재하지 않는데 할당 할 수 있다는 것은 무슨 뜻인가하면, 제네릭의 Variance에서 이것이 효과가 있습니다. 아래를 예로 들어보곘습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">class</span> <span class="nc">Result</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="k">out</span> <span class="n">E</span><span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span> 
    <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span>
        <span class="kd">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span><span class="p">?,</span> 
        <span class="kd">val</span> <span class="py">error</span><span class="p">:</span> <span class="n">E</span><span class="p">?)</span> 
<span class="p">{</span>
    <span class="k">companion</span> <span class="kd">object</span> <span class="err">{
        </span><span class="nc">fun</span> <span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span> <span class="n">Ok</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Result</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span>
        <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span> <span class="n">Error</span><span class="p">(</span><span class="n">error</span><span class="p">:</span> <span class="n">E</span><span class="p">):</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Result</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">proc1</span><span class="p">():</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">Nothing</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Result</span><span class="p">.</span><span class="n">Ok</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">ret</span><span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">Exception</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">proc1</span><span class="p">()</span>
<span class="p">}</span></code></pre></figure>

<p>Result는 값과 에러의 두 가지 자료형를 covariance로 가지는 제너릭형입니다. 여기서 <code class="highlighter-rouge">proc1</code>은 절대로 문제가 생길 일이 없는 메소드이므로 오류값에 대해 Nothing으로 지정하고 있습니다.
그리고 그 결과를 <code class="highlighter-rouge">Result&lt;Int, Exception&gt;</code>에 대입하고 있습니다. 즉, 일반 오류가 있을 수 있는 경우의 처리에 대해 에러가 없었던 경우의 자료형을 형변환 없이 안전하게 할당 할 수 있습니다.</p>

<p>이것은 <code class="highlighter-rouge">Nothing is Exception</code>이기 떄문입니다만 is의 오른쪽에는 어떤 자료형도 넣을 수도 있습니다. Exception 대신 에러 메세지로 String으로 에러를 핸들링하고 있는 경우에도 <code class="highlighter-rouge">Result&lt;Int, String&gt;</code>에 <code class="highlighter-rouge">Result&lt;Int, Nothing&gt;</code>을 넣을 수 있다는 것입니다. 값이 존재하지 않기 때문에 무엇이든 될 수 있다는 것은 흥미롭습니다.</p>

<h3 id="section-19">데이터 클래스와 튜플</h3>

<p>Kotlin에는 데이터 클래스라는 기능이 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">data class</span> <span class="nc">Vector3</span><span class="p">(</span><span class="kd">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="kd">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="kd">val</span> <span class="py">z</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">(</span><span class="m">1.0</span><span class="p">,</span> <span class="m">2.0</span><span class="p">,</span> <span class="m">3.0</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">// Vector3(x=1.0, y=2.0, z=3.0) 라고 출력됩니다.
</span>    <span class="kd">val</span> <span class="err">(</span><span class="py">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="p">=</span> <span class="n">a</span>
    <span class="kd">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">=</span><span class="m">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">=</span><span class="m">4.0</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1">// Vector3(x=0.0, y=2.0, z=4.0) 라고 출력됩니다.
</span><span class="p">}</span></code></pre></figure>

<p>데이터 클래스를 이용하면 몇개의 메소드가 자동적으로 생성됩니다.</p>

<p><code class="highlighter-rouge">equals</code>와 <code class="highlighter-rouge">hashCode</code>가 정의됩니다. 이것을 통해 직접 비교를 할 수 있으며 Map의 키로서도 쓸 수 있습니다.</p>

<p><code class="highlighter-rouge">toString</code>이 정의됩니다. 프로퍼티의 값이 표시되기 때문에 디버깅이 편합니다.</p>

<p><code class="highlighter-rouge">componentN</code>이 정의됩니다. 위 코드에서 Vector3의 경우에는 <code class="highlighter-rouge">component1()</code>, <code class="highlighter-rouge">component2()</code>, <code class="highlighter-rouge">component3()</code>이 정의되겠군요. 이것은 각각의 프로퍼티에 대한 getter입니다. 그리고 이것이 정의된 클래스는 이러한 프로퍼티를 변수에 각각 할당할 수 있습니다. <code class="highlighter-rouge">val (x, y, z) = a</code> 이 대목에서 볼 수 있는 부분입니다.</p>

<p><code class="highlighter-rouge">copy</code>가 정의됩니다. 이것은 프로퍼티와 동명의 인수를 취하는 메소드에서 기본 인수로서 자신의 프로퍼티 값이 설정되어 있습니다. 그리고 인수로 지정된 속성을 지정한 새로운 인스턴스를 반환합니다. 따라서 특정 프로퍼티만을 바꾼 복사본을 만드는 방법입니다.</p>

<p>불변 프로그래밍(Immutable Programming)을 하려고 하면 특정 프로퍼티만 바꾼 복사본을 만드는게 복잡합니다. <code class="highlighter-rouge">withName(newName) //name 만 변경한 복사본을 반환</code>와 같이 하나만 변경하는 것을 모든 프로퍼티에 대해 준비하더라도 다수의 프로퍼티를 변경할 때는 그만큼의 메소드 체인을 써야합니다. 한편, 모든 프로퍼티를 가지는 생성자는 있습니다만, 모두는 변화하지 않는 경우는 같은 값을 다시 지정하는 것이 귀찮습니다. <code class="highlighter-rouge">copy</code>는 이 귀찮은 일로부터 프로그래머를 해방시켜주어 불변의 원칙을 더욱 쉽게 사용할 수 있게 해줍니다.</p>

<p>Kotlin에서는 튜플 기능은 존재하지 않습니다. 그러나 데이터 클래스를 이용하면 같은 기능을 이용할 수 있습니다. 위에서 예를 나타낸 것과 같이 클래스 정의라고 해봤자 최소한의 타이핑으로 할 수 있으므로 그다지 귀찮은 일은 아닙니다.</p>

<h3 id="section-20">별명 임포트</h3>

<p>Kotlin에서는 별명 임포트라는 기능이 있습니다. 다른 두 개의 패키지에 동일한 클래스의 이름이 있을 때 각각 별명을 붙여 가져올 수 있는 기능으로 그 긴 풀 패키지 네임을 쓸 필요가 없습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">import</span> <span class="nn">com.omochimetaru.Bitmap</span> <span class="k">as</span> <span class="n">MyBitmap</span>
<span class="k">import</span> <span class="nn">android.graphics.Bitmap</span> <span class="k">as</span> <span class="n">ABitmap</span>

<span class="k">fun</span> <span class="nf">hoge</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">MyBitmap</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">fuga</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ABitmap</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span></code></pre></figure>

<p>Swift에서도 같은 기능을 쓸 수 있습니다. Java라면 이게 괴로웠겠죠?</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">import</span> <span class="nn">com.omochimetaru.Bitmap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.graphics.Bitmap</span><span class="o">;</span>

<span class="kt">void</span> <span class="nf">hoge</span><span class="o">(</span><span class="n">com</span><span class="o">.</span><span class="na">omochimetaru</span><span class="o">.</span><span class="na">Bitmap</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="nf">fuga</span><span class="o">(</span><span class="n">android</span><span class="o">.</span><span class="na">graphics</span><span class="o">.</span><span class="na">Bitmap</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<h3 id="enum---enum-sealed-classtagged-enum">Enum, 값을 포함한 Enum, Sealed Class(Tagged Enum)</h3>

<p>Kotlin에서도 당연히 Enum이 있습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">enum</span> <span class="kd">class</span> <span class="nc">Direction</span> <span class="p">{</span>
    <span class="n">NORTH</span><span class="p">,</span> <span class="n">SOUTH</span><span class="p">,</span> <span class="n">WEST</span><span class="p">,</span> <span class="n">EAST</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="kd">class</span> <span class="nc">Color</span><span class="p">(</span><span class="kd">val</span> <span class="py">rgb</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RED</span><span class="p">(</span><span class="m">0</span><span class="n">xFF0000</span><span class="p">),</span>
    <span class="n">GREEN</span><span class="p">(</span><span class="m">0</span><span class="n">x00FF00</span><span class="p">),</span>
    <span class="n">BLUE</span><span class="p">(</span><span class="m">0</span><span class="n">x0000FF</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>두번째 예와 같이 값을 포함한 Enum도 만들 수 있습니다. 그러나 Swift에서 할 수 있는 같은 enum마다 다른 property를 갖게 하는 Tagged Enum이라는 기능은 enum으로는 만들 수 없습니다.</p>

<p>Swift의 예를 한번 보시죠.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">enum</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kt">Left</span><span class="p">(</span><span class="kt">T</span><span class="p">)</span>
    <span class="k">case</span> <span class="kt">Right</span><span class="p">(</span><span class="kt">U</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>Left와 Right에서 프로퍼티의 자료형이 다릅니다. 기타 Optional에서는 Some에는 프로퍼티가 있지만 None에는 없는 것과 같은 패턴도 있습니다.</p>

<p>Kotlin에는 <code class="highlighter-rouge">sealed class</code>라는걸 이용해서 같은 것을 만들 수가 있습니다. sealed class라는 것은 상속을 금지한 클래스입니다. 그러나 그 클래스의 내부에서는 상속할 수 있습니다. 따라서 사전에 준비한 서브클래스만을 가질 수 있는 클래스가 됩니다.</p>

<p>그렇다면 when문(C나 Java의 switch문)에서 자료형 판정을 체크할 수 있어서 분기에서 문제가 생기지 않는 것을 컴파일러에 의해 보장받습니다.</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">sealed</span> <span class="kd">class</span> <span class="nc">Expr</span> <span class="p">{</span>
    <span class="kd">class</span> <span class="nc">Const</span><span class="p">(</span><span class="kd">val</span> <span class="py">number</span><span class="p">:</span> <span class="n">Double</span><span class="p">)</span> <span class="p">:</span> <span class="n">Expr</span><span class="p">()</span>
    <span class="kd">class</span> <span class="nc">Sum</span><span class="p">(</span><span class="n">e1</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">e2</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="p">:</span> <span class="n">Expr</span><span class="p">()</span>
    <span class="kd">object</span> <span class="nc">NotANumber</span> <span class="p">:</span> <span class="n">Expr</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">):</span> <span class="n">Double</span> <span class="p">=</span> <span class="k">when</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="n">Const</span> <span class="p">-&gt;</span> <span class="n">expr</span><span class="p">.</span><span class="n">number</span>
    <span class="k">is</span> <span class="n">Sum</span> <span class="p">-&gt;</span> <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">e1</span><span class="p">)</span> <span class="p">+</span> <span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">e2</span><span class="p">)</span>
    <span class="n">NotANumber</span> <span class="p">-&gt;</span> <span class="n">Double</span><span class="p">.</span><span class="n">NaN</span>
    <span class="c1">// the `else` clause is not required because we've covered all the cases
</span><span class="p">}</span></code></pre></figure>

<p>위의 예와 같이 Smart Cast가 있으므로 when문에서는 같은 변수 이름이 이미 형변환된 상태입니다.</p>

<h3 id="type-alias-">Type Alias가 없다.</h3>

<p>Kotlin에서는 Type Alias와 같은 기능이 없습니다. Swift에서는 까다로운 클로져형 등에 이름을 붙일 수 있지만, 이런 코드를 Kotlin으로 이식하면 전부 빨간 밑줄이 그어집니다.</p>

<h2 id="section-21">끝으로</h2>

<p>이 내용 중 쓸 수 없는 경우도 있겠지만 여기까지 읽은 사람이라면 꽤나 Kotlin이 쓰고 싶은게 아닐까요!</p>
]]>
            </content:encoded>
            <excerpt:encoded>
                <![CDATA[]]>
            </excerpt:encoded>
            <wp:post_id>번역-android-개발을-수주해서-kotlin을-제대로-써봤더니-최고였다</wp:post_id>
            <wp:post_date>2015-10-17 09:00:00</wp:post_date>
            <wp:comment_status>closed</wp:comment_status>
            <wp:ping_status>closed</wp:ping_status>
            <wp:post_name>post-format-standard</wp:post_name>
            <wp:status>publish</wp:status>
            <wp:post_parent>0</wp:post_parent>
            <wp:menu_order>0</wp:menu_order>
            <wp:post_type>post</wp:post_type>
            <wp:post_password/>
            <wp:is_sticky>0</wp:is_sticky>
        </item>
        
    </channel>
</rss>
