<!doctype html>
<html amp lang="en">
  <head>
    <meta charset="utf-8">
    <title>RxJava 2.x, 무엇이 달라졌을까?</title>
    <link rel="canonical" href="http://realignist.me/code/2017/01/25/rxjava2-changelog.html" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <style amp-custom>.radius-half {
  border-radius: 50%; }

.site-header {
  position: relative;
  width: 100%;
  max-width: 700px;
  margin: 16px auto 0 auto;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box; }
  .site-header .page-links {
    display: block;
    position: absolute;
    top: 10px;
    right: 16px;
    font-weight: 200;
    font-style: normal;
    font-size: 18px;
    line-height: 30px; }
    .site-header .page-links a {
      text-decoration: none;
      color: #999999; }
      .site-header .page-links a:hover {
        color: #333333; }

code {
  word-break: break-all;
  white-space: pre-wrap; }

body {
  padding: 5%;
  max-width: 700px;
  line-height: 1.45em; }

h1 {
  font-size: 1.7em; }

h2 {
  font-size: 1.35em; }

h5 {
  text-align: center;
  padding-top: 10%; }
</style>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <header class="site-header">
      <a href="/" class="logo"><span class="logo"><amp-img src="/assets/images/pikachu_logo.png" width="48" height="48" class="radius-half" /></span></a>
      <div class="page-links">
        <a class="page-link" href="/">Home</a> • <a class="page-link" href="/about/">About</a>
      </div>
    </header>
    <h1 class="post-title">
      RxJava 2.x, 무엇이 달라졌을까?
    </h1>
    <span>2017년 01월 25일 작성 - Haze Lee.</span>
    <h2 id="section">글에 앞서,</h2>

<p>RxJava 2.x은 <a href="https://github.com/reactive-streams/reactive-streams-jvm">Reactive-Streams 표준</a>에 맞게 많은 부분이 바뀌었습니다. 오늘은 RxJava Wiki에 있는 <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0">What’s Different in 2.0</a> 문서를 번역하면서 어떤 점들이 바뀌었나 알아보는 시간을 갖도록 하겠습니다.</p>

<hr>

<p>RxJava 2.0은 Reactive-Streams의 표준 사양에 따라 처음부터 다시 작성되었습니다. 사양에 대해서는 RxJava 1.x에서 발전했으며, 리액티브 시스템과 라이브러리에 대한 공통된 기준을 제시합니다.</p>

<p>왜냐하면 Reactive-Streams는 기존의 RxJava와는 아키텍처가 다르므로, 기존 RxJava의 많은 타입을 변경해야만 했습니다. 이 페이지에서는 변경된 내용을 요약하고, RxJava 1.x로 된 코드를 RxJava 2.x 코드로 다시 작성하는 법을 설명합니다.</p>

<p>RxJava 2.x를 위한 오퍼레이터를 작성하는 방법은 <a href="https://github.com/ReactiveX/RxJava/wiki/Writing-operators-for-2.0">오퍼레이터를 작성하는 법</a>이라는 Wiki 페이지를 방문해주세요.</p>

<h2 id="section-1">메이븐 주소와 베이스 패키지</h2>

<p>RxJava 1.x와 RxJava 2.x를 나란히 둘 수 있도록 RxJava 2.x는 Maven 좌표 <code class="highlighter-rouge">io.reactivex.rxjava2:rxjava:2.x.y</code>로 받아올 수 있으며 클래스는 <code class="highlighter-rouge">io.reactivex</code>에서 접근할 수 있습니다.</p>

<p>1.x에서 2.x로 전환하는 사용자들은 import를 처음부터 다시 구성해야하므로, 조심해야 합니다.</p>

<h2 id="javadoc">Javadoc</h2>

<p>RxJava 2.x를 위한 공식 Javadoc은 <a href="http://reactivex.io/RxJava/2.x/javadoc/">여기</a>에서 보실 수 있습니다.</p>

<h2 id="null-">Null 값</h2>

<p>RxJava 2.x는 더는 <code class="highlighter-rouge">null</code> 값을 허용하지 않으며, 다음과 같은 코드들은 즉시, 또는 다운스트림으로 NullPointerException을 발생할 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="n">Single</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">.</span><span class="na">fromCallable</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="o">)</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">,</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<p>이 말은 즉, <code class="highlighter-rouge">Observable&lt;Void&gt;</code>는 더는 값을 발생시킬 수 없으며 정상적으로 종료되거나 Exception을 발생시킵니다. API 디자이너들은 대신 <code class="highlighter-rouge">Object</code>가 어떤 값이 될지 보장할 수 없을 때 <code class="highlighter-rouge">Observable&lt;Object&gt;</code>를 사용할 수 있습니다. (어쨌든 관련이 없어야 합니다.) 예를 들어 신호기와 같은 소스가 필요할 때, 공유 enum을 정의하고 해당 인스턴스를 <code class="highlighter-rouge">onNext</code>에 담아 보낼 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">enum</span> <span class="n">Irrelevant</span> <span class="o">{</span> <span class="n">INSTANCE</span><span class="o">;</span> <span class="o">}</span>

<span class="n">Observable</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">create</span><span class="o">((</span><span class="n">ObservableEmitter</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">emitter</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 1"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 2"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

   <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Side-effect 3"</span><span class="o">);</span>
   <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="n">Irrelevant</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
<span class="o">});</span>

<span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="cm">/* Ignored. */</span> <span class="o">},</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<h2 id="observable-flowable">Observable과 Flowable</h2>

<p>RxJava 0.x에서 배압 개념을 도입하면서 별도의 베이스가 되는 리액티브 클래스를 두지 않고, <code class="highlighter-rouge">Observable</code>을 필요에 맞게 개조해서 사용했던거에 대한 약간의 후회가 있습니다. Backpressure의 주된 문제점은 UI 이벤트와 같은 많은 핫 소스들이 합리적으로 배압되지 않고, 예기치 않은 <code class="highlighter-rouge">MissingBackpressureException</code>이 발생할 수 있는 것이었습니다. (즉, 초보자들은 이런 문제를 예상하지 못합니다.)</p>

<p>우리는 2.x에서 이러한 문제를 해결하기 위해  <code class="highlighter-rouge">io.reactivex.Observable</code>에는 Backpressure를 없애고, Backpressure가 적용된 새로운 기본 리액티브 클래스인 <code class="highlighter-rouge">io.reactivex.Flowable</code>를 만들었습니다.</p>

<p>좋은 소식은 오퍼레이터의 이름이 대부분 같다는 것입니다. 나쁜 소식은 import를 관리할 때 의도치 않게 Backpressure가 적용되지 않은 <code class="highlighter-rouge">io.reactivex.Observable</code>을 선택할 수 있으므로 조심해야 합니다.</p>

<h3 id="section-2">어떤 타입을 써야할까?</h3>

<p>RxJava의 최종 소비자로서 데이터 플로우를 설계하거나, 2.x에 호환되는 라이브러리를 사용할 때 <code class="highlighter-rouge">MissingBackpressureException</code> 또는 <code class="highlighter-rouge">OutOfMemoryError</code>와 같은 문제를 피하는데 도움이 되는 몇 가지 요소를 고려할 수 있습니다.</p>

<h4 id="observable--">Observable을 써야할 때,</h4>

<ul>
  <li>만약 플로우에 1000개 이하의 항목이 있다면, 시간이 지나면서 항목이 대부분 없어지기 때문에 애플리케이션에서 <code class="highlighter-rouge">OutOfMemoryError</code>가 발생할 일이 없습니다.</li>
  <li>마우스 움직임이나 터치 이벤트와 같은 GUI 이벤트를 처리할 때는 합리적으로 Backpressure를 줄 수 없으며, 빈번하지도 않습니다. <code class="highlighter-rouge">Observable</code>을 사용하면 초당 1000개 혹은 그 이하의 항목을 처리할 수 있지만 샘플링이나 디바운싱을 사용하는 것이 좋습니다.</li>
  <li>플로우가 본질적으로는 동기식이지만 플랫폼이 Java 스트림을 지원하지 않거나 그런 기능이 있다는걸 놓쳤을 때, <code class="highlighter-rouge">Observable</code>을 쓰는 것이 <code class="highlighter-rouge">Flowable</code>을 쓰는 것보다 대부분 오버헤드가 적습니다. <em>(Java 6+를 지원하는 Iterable 플로우에 최적화된 IxJava도 고려할 수 있습니다.)</em>
</li>
</ul>

<h4 id="flowable--">Flowable을 써야할 때,</h4>

<ul>
  <li>어딘가에서 생성되는 10000개 이상의 요소를 처리할 때, 체인은 소스가 생성되는 양을 제한할 수 있습니다.</li>
  <li>파일을 디스크에서 읽거나 파싱하는 일은 본질적으로 블로킹이고, 풀에 기반(Pull-based)합니다. 이럴 때는 Backpressure를 통해 사용자가 제어할 수 있습니다.</li>
  <li>JDBC를 통해 데이터베이스를 읽는 것 또한 블로킹이고 풀에 기반을 두며, 각 다운스트림 요청에 대해 <code class="highlighter-rouge">ResultSet.next()</code>를 호출해서 사용자가 제어할 수 있습니다.</li>
  <li>네트워크를 거치거나, 논리적 리소스를 요청하는 프로토콜을 사용하는 네트워크 (스트리밍) 입출력</li>
  <li>추후에 논블로킹 리액티브 API 혹은 드라이버를 지원하게 될 수 있는, 블로킹이거나 풀에 기반을 둔 데이터 소스</li>
</ul>

<h2 id="single">Single</h2>

<p>하나의 <code class="highlighter-rouge">onSuccess</code>나 <code class="highlighter-rouge">onError</code>를 방출할 수 있는 기본 리액티브 타입인 <code class="highlighter-rouge">Single</code>은 2.x에서 처음부터 다시 디자인되었습니다. 이 아키텍처는 Reactive-Streams의 디자인에서 파생되었습니다. 해당 소비자 타입인 <code class="highlighter-rouge">rx.Single.SingleSubscriber</code>는 <code class="highlighter-rouge">rx.Subscription</code>을 받을 수 있도록 인터페이스 <code class="highlighter-rouge">io.reactivex.SingleObserver&lt;T&gt;</code>는 딱 3개의 메소드만을 가지도록 다음과 같이 바뀌었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">SingleObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Disposable</span> <span class="n">d</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">error</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이를 통해 <code class="highlighter-rouge">onSubscribe(onSuccess | onError)?</code> 규격을 따를 수 있게끔 되었습니다.</p>

<h2 id="completable">Completable</h2>

<p><code class="highlighter-rouge">Completable</code> 타입은 대체로 비슷합니다. 1.x 때 Reactive-Streams의 스타일에 따라 설계되었기 때문에 사용자 레벨의 변경사항은 없습니다.</p>

<p>명칭이 바뀐 것과 비슷하게, <code class="highlighter-rouge">rx.Completable.CompletableSubscriber</code>는 <code class="highlighter-rouge">onSubscribe(Disposable)</code>와 함께 <code class="highlighter-rouge">io.reactivex.CompleteObserver</code>가 되었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">CompletableObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Disposable</span> <span class="n">d</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">error</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>이를 통해 <code class="highlighter-rouge">onSubscribe(onSuccess | onError)?</code> 규격을 계속 따르고 있습니다.</p>

<h2 id="maybe">Maybe</h2>

<p>RxJava 2.0.0-RC2에선 새로운 기본 리액티브 타입인 <code class="highlighter-rouge">Maybe</code>가 도입되었습니다. 개념적으로 <code class="highlighter-rouge">Single</code>과 <code class="highlighter-rouge">Completable</code>의 리액티브 소스에 의해 0개 혹은 1개의 항목, 혹은 에러를 발생할 수 있는 패턴을 포착할 수 있도록 제공합니다.</p>

<p><code class="highlighter-rouge">Maybe</code> 클래스는 <code class="highlighter-rouge">MaybeSource</code>를 기본 인터페이스 타입으로, <code class="highlighter-rouge">onSubscribe (onSuccess | onError | onComplete)?</code> 규격을 따르는 <code class="highlighter-rouge">MaybeObserver</code>를 데이터를 수신하는 인터페이스로 이용합니다. 왜냐면 많아도 1개의 항목이 발생할 수 있기 때문에, <code class="highlighter-rouge">Maybe</code> 타입에는 Backpressure 개념이 없습니다. (왜냐하면 알 수 없는 길이의 <code class="highlighter-rouge">Flowable</code>이나 <code class="highlighter-rouge">Observable</code>과 같이 Buffer가 팽창할 가능성이 없기 때문입니다.)</p>

<p>이는 <code class="highlighter-rouge">onSubscribe(Disposable)</code>의 호출에는 잠재적으로 다른 <code class="highlighter-rouge">onXXX</code> 메소드 중 하나가 따라옵니다. <code class="highlighter-rouge">Flowable</code>과는 달리 단일 값만이 있는 경우 <code class="highlighter-rouge">onSuccess</code>만이 호출되며, <code class="highlighter-rouge">onComplete</code>는 호출되지 않습니다.</p>

<p>이 새로운 기본 리액티브 타입은 0개 또는 1개의 항목에 동작하는 <code class="highlighter-rouge">Flowable</code> 오퍼레이터의 적당한 서브셋을 제공하므로 다른 타입과 실질적으로 같습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Maybe</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">.</span><span class="na">defaultIfEmpty</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="na">test</span><span class="o">()</span>
    <span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span></code></pre></figure>

<h2 id="section-3">기본 리액티브 인터페이스</h2>

<p>Reactive-Streams <code class="highlighter-rouge">Publisher</code>를 <code class="highlighter-rouge">Flowable</code>로 확장하는 스타일에 따라서, 다른 기본 리액티브 클래스들은 이제 <code class="highlighter-rouge">io.reactivex</code> 패키지 안에 있는 비슷한 베이스 인터페이스를 상속받게 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">ObservableSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">Observer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">SingleSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">SingleObserver</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">CompletableSource</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">CompletableObserver</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">MaybeSource</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">MaybeObserver</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>따라서 사용자의 일부 기본 리액티브 타입을 인자로 받는 많은 오퍼레이터가 이제 <code class="highlighter-rouge">Publisher</code>와 <code class="highlighter-rouge">XSource</code>를 지원합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">Publisher</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">);</span>

<span class="n">Observable</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span> <span class="nf">flatMap</span><span class="o">(</span><span class="n">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="n">ObservableSource</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">R</span><span class="o">&gt;&gt;</span> <span class="n">mapper</span><span class="o">);</span></code></pre></figure>

<p><code class="highlighter-rouge">Publisher</code>를 이런 방식으로 입력하면 다른 Reactive-Streams에 호환되는 라이브러리를 랩핑하거나, Flowable로 변환할 필요 없이 작성할 수 있습니다.</p>

<p>그러나 오퍼레이터가 기본 리액티브 타입을 제공해야하는 경우, 사용자는 전체 리액티브 클래스를 받게 됩니다. (<code class="highlighter-rouge">XSource</code>를 제공하는 것은 오퍼레이터가 없으므로 실질적으로 쓸모가 없습니다.)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">windows</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="na">window</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

<span class="n">source</span><span class="o">.</span><span class="na">compose</span><span class="o">((</span><span class="n">Flowable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">flowable</span><span class="o">)</span> <span class="o">-&gt;</span> 
    <span class="n">flowable</span>
        <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">io</span><span class="o">())</span>
        <span class="o">.</span><span class="na">observeOn</span><span class="o">(</span><span class="n">AndroidSchedulers</span><span class="o">.</span><span class="na">mainThread</span><span class="o">()));</span></code></pre></figure>

<h2 id="subject-processor">Subject와 Processor</h2>

<p>Reactive-Streams 사양에서 이벤트의 소비자이면서 동시에 공급자이기도 한 <code class="highlighter-rouge">Subject</code>와 비슷한 동작들은 <code class="highlighter-rouge">org.reactivestream.Processor</code> 인터페이스에 의해 수행됩니다. <code class="highlighter-rouge">Observable</code>과 <code class="highlighter-rouge">Flowable</code>의 분리와 마찬가지로, Backpressure와 Reactive-Streams 사양을 준수한 구현은 <code class="highlighter-rouge">FlowableProcessor</code> 클래스를 기반으로 합니다. (<code class="highlighter-rouge">Flowable</code>을 확장하여 풍부한 인스턴스 내 오퍼레이터를 제공합니다.) <code class="highlighter-rouge">Subject</code>에서 중요한 변화는 더는 <code class="highlighter-rouge">T -&gt; R</code>과 같은 변환을 지원하지 않은 것입니다. (입력 타입이 T이고 출력 타입이 R 유형임을 뜻합니다.) (우리는 1.x에서 이 클래스를 사용하지 못했고, 원래 <code class="highlighter-rouge">Subject</code>는 .NET에서 왔는데 .NET에서는 같은 클래스 이름에 다른 수의 타입 인자를 둘 수 있어 오버로드가 있었습니다.)</p>

<p>다음 클래스들 <code class="highlighter-rouge">io.reactivex.subjects.AsyncSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.BehaviorSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.PublishSubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.ReplaySubject</code>, <code class="highlighter-rouge">io.reactivex.subjects.UnicastSubject</code>은 RxJava 2.x에서 Backpressure를 지원하지 않습니다. (2.x의 <code class="highlighter-rouge">Observable</code> 계열의 일부로서)</p>

<p>다음 클래스들 <code class="highlighter-rouge">io.reactivex.processors.AsyncProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.BehaviorProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.PublishProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.ReplayProcessor</code>, <code class="highlighter-rouge">io.reactivex.processors.UnicastProcessor</code>는 Backpressure를 쓸 수 있습니다. <code class="highlighter-rouge">BehaviorProcessor</code>와 <code class="highlighter-rouge">PublishProcessor</code>는 다운스트림 Subscriber의 요청을 조정하지 않으며(<code class="highlighter-rouge">Flowable.publish()</code>를 씁니다.), 다운스트림이 계속 유지될 수 없을 때 <code class="highlighter-rouge">MissingBackpressureException</code>으로 알려줍니다. 다른 <code class="highlighter-rouge">XProcessor</code> 타입들은 다운스트림 Subscriber의 Backpressure를 존중하지만, 소스를 subscribe할 때(선택 사항) 무제한적으로 소비하게 됩니다. (<code class="highlighter-rouge">Long.MAX_VALUE</code>를 요청합니다.)</p>

<h2 id="testsubject">TestSubject</h2>

<p>1.x에 있었던 <code class="highlighter-rouge">TestSubject</code>가 삭제되었습니다. 이 기능은 <code class="highlighter-rouge">TestScheduler</code>, <code class="highlighter-rouge">PublishProcessor</code>/<code class="highlighter-rouge">PublishSubject</code>와 <code class="highlighter-rouge">observeOn(testScheduler)</code>/scheduler 파라미터를 통해 수행할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TestScheduler</span> <span class="n">scheduler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestScheduler</span><span class="o">();</span>
<span class="n">PublishSubject</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">delay</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="n">scheduler</span><span class="o">)</span>
    <span class="o">.</span><span class="na">test</span><span class="o">();</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertEmpty</span><span class="o">();</span>

<span class="n">ps</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="n">scheduler</span><span class="o">.</span><span class="na">advanceTimeBy</span><span class="o">(</span><span class="mi">999</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertEmpty</span><span class="o">();</span>

<span class="n">scheduler</span><span class="o">.</span><span class="na">advanceTimeBy</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertValue</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h2 id="section-4">다른 클래스들</h2>

<p><code class="highlighter-rouge">rx.observables.ConnectableObservable</code> 는 이제 <code class="highlighter-rouge">io.reactivex.observables.ConnectableObservable</code>와 <code class="highlighter-rouge">io.reactivex.flowables.ConnectableFlowable</code>로 바뀌었습니다.</p>

<h3 id="groupedobservable">GroupedObservable</h3>

<p>기존 <code class="highlighter-rouge">rx.observables.GroupedObservable</code>는 <code class="highlighter-rouge">io.reactivex.observables.GroupedObservable</code>와 <code class="highlighter-rouge">io.reactivex.flowables.GroupedFlowable</code>로 바뀌었습니다.</p>

<p>1.x에서는 <code class="highlighter-rouge">GroupedObservable.from()</code>을 통해 인스턴스를 생성할 수 있었습니다. 2.x에서는 팩토리 메소드가 더는 제공되지 않기 때문에 <code class="highlighter-rouge">GroupedObservable</code>을 직접 확장해서 써야합니다. 전체 클래스는 추상화되었습니다.</p>

<p>다음과 같이 클래스를 확장하고 사용자가 정의한 <code class="highlighter-rouge">subscribeActural</code> 동작을 추가하여 1.x와 유사한 기능을 구현할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MyGroup</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">GroupedObservable</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">K</span> <span class="n">key</span><span class="o">;</span>

    <span class="kd">final</span> <span class="n">Subject</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">subject</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyGroup</span><span class="o">(</span><span class="n">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subject</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">T</span> <span class="nf">getKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">subscribeActual</span><span class="o">(</span><span class="n">Observer</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">subject</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>(<code class="highlighter-rouge">GroupedFlowable</code>도 비슷한 방법으로 이용할 수 있습니다.)</p>

<h2 id="section-5">함수형 인터페이스</h2>

<p>1.x와 2.x 모두 Java 6+를 대상으로 하므로 우리는 <code class="highlighter-rouge">java.util.function.Function</code>과 같은 Java 8의 함수형 인터페이스를 사용할 수 없습니다. 하지만 우리는 자체적인 함수형 인터페이스를 1.x에서 구현했으며, 2.x에서도 그 전통을 따랐습니다.</p>

<p>주목할만한 차이점은 이제 우리의 모든 함수형 인터페이스에 <code class="highlighter-rouge">throws Exception</code>가 붙었습니다. 더는 <code class="highlighter-rouge">try-catch</code> 문으로 감싸거나, 검사 예외를 바꿀 필요가 없으므로 소비자와 매퍼에 큰 편의를 제공합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">"file.txt"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="n">Files</span><span class="o">.</span><span class="na">readLines</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">lines</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">lines</span><span class="o">.</span><span class="na">size</span><span class="o">()),</span> <span class="nl">Throwable:</span><span class="o">:</span><span class="n">printStackTrace</span><span class="o">);</span></code></pre></figure>

<p>파일이 없거나 제대로 읽을 수 없을 때, 최종 사용자는 <code class="highlighter-rouge">IOException</code>을 직접 출력합니다. try-catch 없이 호출된 <code class="highlighter-rouge">Files.readLines(name)</code>에 주목해주세요.</p>

<h2 id="action">Action</h2>

<p>컴포넌트 수를 줄일 수 있는 좋은 기회이기 때문에, 2.x에서는 <code class="highlighter-rouge">Action3</code>-<code class="highlighter-rouge">Action9</code>와  <code class="highlighter-rouge">ActionN</code>(RxJava 자체에서는 사용되지 않음)이 빠지게 되었습니다.</p>

<p>나머지 액션 인터페이스들은 Java 8의 함수형 타입에 따라 이름이 바뀌었습니다. 매개변수가 없는 <code class="highlighter-rouge">Action0</code>은 <code class="highlighter-rouge">io.reactivex.functions.Action</code>으로 바뀌었으며, <code class="highlighter-rouge">Scheduler</code> 메소드에 대한 <code class="highlighter-rouge">java.lang.Runnable</code>로 대체됩니다. <code class="highlighter-rouge">Action1</code>은 <code class="highlighter-rouge">Consumer</code>로, <code class="highlighter-rouge">Action2</code>는 <code class="highlighter-rouge">BiConsumer</code>로 이름이 바뀌었습니다. <code class="highlighter-rouge">ActionN</code>은 <code class="highlighter-rouge">Consumer&lt;Object[]&gt;</code> 타입 선언으로 대체됩니다.</p>

<h3 id="function">Function</h3>

<p>우리는 Java 8의 네이밍 컨벤션에 맞춰 <code class="highlighter-rouge">io.reactivex.functions.Function</code>과 <code class="highlighter-rouge">io.reactivex.functions.BiFunction</code>을 정의했으며, <code class="highlighter-rouge">Func3</code> - <code class="highlighter-rouge">Func9</code>를 각각  <code class="highlighter-rouge">Function3</code> - <code class="highlighter-rouge">Function9</code>로 바꿨습니다. <code class="highlighter-rouge">FuncN</code>은 <code class="highlighter-rouge">Function</code>  타입 선언으로 대체됩니다.</p>

<p>또한 서술을 필요로 하는 오퍼레이터는 더는 <code class="highlighter-rouge">Func1&lt;T, Boolean&gt;</code>를 사용하지 않고 별도의 기본 반환 타입인 <code class="highlighter-rouge">Predicate&lt;T&gt;</code>를 가집니다. (오토박싱이 없으므로 더 좋은 인라인이 가능합니다.)</p>

<p><code class="highlighter-rouge">io.reactivex.functions.Functions</code> 유틸리티 클래스는 일반적인 함수 소스와 <code class="highlighter-rouge">Function&lt;Object[], R&gt;</code>으로의 변환을 제공합니다.</p>

<h2 id="subscriber">Subscriber</h2>

<p>Reactive-Streams 사양에는 Subscriber가 자체 인터페이스로 있습니다. 이 인터페이스는 가볍고 요청 관리와 취소를<code class="highlighter-rouge">rx.Producer</code>와 <code class="highlighter-rouge">rx.Subscription</code>을 별도로 갖는 대신 하나의 인터페이스인 <code class="highlighter-rouge">org.reactivestreams.Subscription</code>로 합쳐서 사용합니다. 이렇게 하면 1.x의 무거운 <code class="highlighter-rouge">rx.Subscriber</code>보다 내부 상태가 적은 스트림 소비자를 생성할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>이름이 충돌하므로 패키지를 <code class="highlighter-rouge">rx</code>에서 <code class="highlighter-rouge">org.reactivestreams</code>로 바꾸는 것만으로는 충분하지 않습니다. 또한 <code class="highlighter-rouge">org.reactivestreams.Subscriber</code>는 리소스를 추가하거나 취소하거나 외부에서 요청하는 개념을 가지고 있지 않습니다.</p>

<p>이 격차을 메우기 위해 <code class="highlighter-rouge">rx.Subscriber</code>와 마찬가지로 <code class="highlighter-rouge">Disposable</code>들의 리소스 추적 지원을 제공하고, <code class="highlighter-rouge">dispose()</code>를 통해 외부에서 취소하거나 정리할 수 있는 <code class="highlighter-rouge">Flowable</code>(과 <code class="highlighter-rouge">Observable</code>)을 위한 추상 클래스 <code class="highlighter-rouge">DefaultSubscriber</code>, <code class="highlighter-rouge">ResourceSubscriber</code>, <code class="highlighter-rouge">DisposableSubscriber</code>(<code class="highlighter-rouge">XObserver</code> 변형 포함)를 정의했습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ResourceSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ResourceSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onStart</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">).</span><span class="na">delay</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span>

<span class="n">subscriber</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span></code></pre></figure>

<p>또한 Reactive-Streams와의 호환을 위해 <code class="highlighter-rouge">onCompleted</code> 메소드는 뒤에 <code class="highlighter-rouge">d</code>가 빠진 <code class="highlighter-rouge">onComplete</code>로 이름이 바뀌었습니다.</p>

<p>1.x에서 <code class="highlighter-rouge">Observable.subscribe(Subscriber)</code>는 <code class="highlighter-rouge">Subscription</code>을 반환했는데, 사용자들은 <code class="highlighter-rouge">Subscription</code>을 다음과 같이 <code class="highlighter-rouge">CompositeSubscription</code>에 추가했었습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">CompositeSubscription</span> <span class="n">composite</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompositeSubscription</span><span class="o">();</span>

<span class="n">composite</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()));</span></code></pre></figure>

<p>Reactive-Streams 사양에 따라 <code class="highlighter-rouge">Publisher.subscribe</code>는 void를 반환하므로 이런 패턴은 2.0에서는 더는 작동하지 않습니다. 이를 해결하기 위해 <code class="highlighter-rouge">E subscribeWith(E subscriber)</code> 메소드가 입력받은 구독자와 관찰자를 그대로 반환하는 각 기본 리액티브 클래스에 추가되었습니다. <code class="highlighter-rouge">ResourceSubscriber</code>가 <code class="highlighter-rouge">Disposable</code>을 직접 구현하므로 이전의 두 예제를 사용하면 2.x 코드는 다음과 같이 보입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">CompositeDisposable</span> <span class="n">composite2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompositeDisposable</span><span class="o">();</span>

<span class="n">composite2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">subscribeWith</span><span class="o">(</span><span class="n">subscriber</span><span class="o">));</span></code></pre></figure>

<h3 id="onsubscribeonstart-request-">onSubscribe/onStart에서 request 호출하기</h3>

<p>요청 관리가 어떻게 작동하는지에 따라 <code class="highlighter-rouge">Subscriber.onSubscribe</code>나 <code class="highlighter-rouge">ResourceSubscriber.onStart</code>에서 <code class="highlighter-rouge">request(n)</code>을 호출하면 <code class="highlighter-rouge">request()</code> 호출 자체가 자신의 <code class="highlighter-rouge">onSubscribe</code>/<code class="highlighter-rouge">onStart</code> 메소드로 돌아가기 전에 <code class="highlighter-rouge">onNext</code>를 즉시 호출하도록 유도할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OnSubscribe start"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OnSubscribe end"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Done"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span></code></pre></figure>

<p>이는 다음과 같이 출력될 것입니다.</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>OnSubscribe start
1
2
3
Done
OnSubscribe end
</code></pre>
</div>

<p>문제는 <code class="highlighter-rouge">request</code>를 호출한 뒤  <code class="highlighter-rouge">onSubscribe/onStart</code>에서 초기화를 수행할 때 문제가 발생하고, <code class="highlighter-rouge">onNext</code>는 초기화의 결과를 볼 수도 있고 보지 않을 수도 있습니다. 이 상황을 피하려면 onSubscribe / onStart에서 <strong>모든 초기화가 완료된 후</strong>에 request를 호출해야 합니다.</p>

<p>2.x에서 이 동작은 <code class="highlighter-rouge">request</code> 호출이 업스트림 <code class="highlighter-rouge">Producer</code>가 도착할 때까지 지연 로직을 거쳐 요청을 축적한 1.x와는 다릅니다. (이 특성은 1.x의 모든 오퍼레이터와 소비자에 오버헤드를 더합니다.) 2.x에서는 항상 <code class="highlighter-rouge">Subscription</code>은 첫 번째로 내려가고, 90%는 요청을 연기할 필요가 없습니다.</p>

<h2 id="subscription">Subscription</h2>

<p>RxJava 1.x에서 <code class="highlighter-rouge">rx.Subscription</code> 인터페이스는 스트림 및 리소스의 라이프사이클 관리, 즉 시퀀스의 구독을 취소하고 예약된 작업과 같은 일반적인 리소스를 해제합니다. Reactive-Streams 사양은 소스와 소비자 간의 상호작용 지점을 지정하기 위해 이 이름을 사용했습니다. <code class="highlighter-rouge">org.reactivestreams.Subscription</code>을 사용하면 업스트림에서 요청할 수 있으며 시퀀스를 취소할 수 있습니다.</p>

<p>이름 충돌을 피하기 위해 1.x의 <code class="highlighter-rouge">rx.Subscription</code>은 <code class="highlighter-rouge">io.reactivex.Disposable</code>(.NET의 IDisposable과 비슷함)으로 이름이 바뀌었습니다.</p>

<p>왜냐하면, Reactive-Streams의 기본 인터페이스 <code class="highlighter-rouge">org.reactivestreams.Publisher</code>는 <code class="highlighter-rouge">subscribe()</code> 메소드를 void로 정의했기 때문입니다. <code class="highlighter-rouge">Flowable.subscribe(Subscriber)</code>는 더는 어떠한 <code class="highlighter-rouge">Subscription</code>이나 <code class="highlighter-rouge">Disposable</code>을 반환하지 않습니다. 다른 기본 리액티브 타입들도 각각의 구독자 타입에 따라 이 규칙을 따릅니다.</p>

<p><code class="highlighter-rouge">subscribe</code>의 다른 오버로드는 2.x에서 <code class="highlighter-rouge">Disposable</code>을 반환합니다.</p>

<p>원래의 <code class="highlighter-rouge">Subscription</code> 컨테이너 타입들은 이름이 바뀌고 새로워졌습니다.</p>

<ul>
  <li>
<code class="highlighter-rouge">CompositeSubscription</code>은 <code class="highlighter-rouge">CompositeDisposable</code>로 바뀌었습니다.</li>
  <li>
<code class="highlighter-rouge">SerialSubscription</code>와 <code class="highlighter-rouge">MultipleAssignmentSubscription</code>는 <code class="highlighter-rouge">SerialDisposable</code>로 합쳐졌습니다. <code class="highlighter-rouge">set()</code> 메소드는 오래된 값을 정리하며 <code class="highlighter-rouge">replace()</code> 메소드는 정리하지 않습니다.</li>
  <li>
<code class="highlighter-rouge">RefCountSubscription</code>는 삭제되었습니다.</li>
</ul>

<h2 id="backpressure">Backpressure</h2>

<p>Reactive-Streams의 사양은 Backpressure를 지원하는 연산자를 요구합니다. 특히 Backpressure를 요구하지 않을 때 소비자가 넘치지 않도록 보장해줍니다. 새로운 <code class="highlighter-rouge">Flowable</code> 기본 리액티브 타입의 오퍼레이터는 이제 다운스트림 요청량을 적절하게 고려하지만 <code class="highlighter-rouge">MissingBackpressureException</code>이 완전히 사라진 것은 아닙니다. 이런 익셉션은 여전히 존재하지만 이번에는 더 많은 신호를 보낼 수 없는 오퍼레이터가 대신 익셉션을 알립니다. (이를 통해 제대로 Backpressure 되지 않은 부분을 더 잘 식별할 수 있습니다.)</p>

<p>대안으로 2.x의 <code class="highlighter-rouge">Observable</code>은 전혀 Backpressure를 하지 않으며, 선택의 여지가 있습니다.</p>

<h2 id="reactive-streams-">Reactive-Streams 호환</h2>

<p>Flowable에 기반을 둔 소스와 오퍼레이터는 규칙 §3.9와 규칙 §1.3의 한 해석을 제외하고 Reactive-Streams 1.0.0 규격을 준수합니다.</p>

<blockquote>
  <p>§3.9: Subscription이 취소되지 않은 동안 Subscription.request(long n)은 인수가 &lt;= 0인 경우 무조건 java.lang.IllegalArgumentException으로 onError를 호출합니다. 에러 메시지에는 이 규칙에 대한 참조가 무조건 포함되어야만 합니다. 그리고 선택적으로 전체 규칙에 대한 인용이 포함될 수 있습니다.</p>
</blockquote>

<p>규칙 §3.9는 버그 케이스에 대처하기 위해 과도한 오버헤드(<code class="highlighter-rouge">request()</code>를 처리하는 <strong>모든</strong> 오퍼레이터에 대한 half-serializer)가 필요합니다. RxJava 2(와 Reactor 3)는 <code class="highlighter-rouge">RxJavaPlugins.onError</code>에 <code class="highlighter-rouge">IllegalArgumentException</code>을 보고하고, 그렇지 않으면 무시합니다. RxJava 2는 <code class="highlighter-rouge">IllegalArgumentException</code>을 비동기식으로 <code class="highlighter-rouge">Subscriber.onError</code>에 라우팅하는 <a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/test/java/io/reactivex/tck/FlowableTck.java">사용자 지정 오퍼레이터</a>를 적용하여 TCK(Test Compatibility Kit)를 전달합니다. 모든 주요 Reactive-Streams 라이브러리에는 이러한 제로 요청이 없습니다. Reactor 3은 이를 무시하고, Akka-Stream은 TCK 오퍼레이터와 비슷한 라우팅 동작을 가진 변환기(다른 RS 소스 및 소비자와 상호작용하기 위해)를 사용합니다.</p>

<blockquote>
  <p>§1.3: onSubscribe, onNext, onError, onComplete는 구독자에게 순차적으로 신호를 보내야 합니다. (동시에 알림을 보낼 수 없습니다.)</p>
</blockquote>

<p>TCK는 <code class="highlighter-rouge">onSubscribe</code>와 <code class="highlighter-rouge">onNext</code>간에 동기식이지만 제한된 재진입을 허용합니다. 즉, <code class="highlighter-rouge">onSubscribe</code>에 있는동안 <code class="highlighter-rouge">request(1)</code> 호출은 <code class="highlighter-rouge">onSubscribe</code>가 제어를 반환하지 않고도 <code class="highlighter-rouge">onNext</code>를 호출할 수 있습니다. 거의 모든 오퍼레이터가 이러한 방식으로 동작하지만 오퍼레이터 <code class="highlighter-rouge">observeOn</code>은 <code class="highlighter-rouge">request(1)</code>에 대한 응답으로 <code class="highlighter-rouge">onNext</code>를 비동기적으로 호출할 수 있으므로 <code class="highlighter-rouge">onSubscribe</code>가 <code class="highlighter-rouge">onNext</code>와 동시에 실행됩니다. 이것은 TCK에 의해 확률적으로 탐지되며 <code class="highlighter-rouge">onSubscribe</code>가 반환될 때까지 다운스트림 요청을 연기하는 <a href="https://github.com/ReactiveX/RxJava/blob/2.x/src/test/java/io/reactivex/tck/FlowableAwaitOnSubscribeTck.java">다른 오퍼레이터</a>를 사용합니다. 이 비동기 동작은 RxJava 2 및 Reactor 3에서 문제가 되지 않습니다. 연산자는 <code class="highlighter-rouge">onSubscribe</code> 안에서 스레드에 안전한 방식으로 작업을 수행하고, Akka-Stream의 변환기는 비슷한 지연된 요청 관리를 수행하기 때문입니다.</p>

<p>이 두 동작은 라이브러리 간의 동작에 영향을 주기 때문에 버전 2.0.5에서는 <code class="highlighter-rouge">strict()</code> 오퍼레이터가 도입되고 항목 당 오버헤드를 희생시키면서 이러한 규칙과 몇가지 추가 규칙이 적용됩니다.</p>

<h2 id="section-6">런타임 훅</h2>

<p>2.x에서는 런타임 시 훅을 변경할 수 있는 <code class="highlighter-rouge">RxJavaPlugins</code>를 다시 디자인했습니다. 스케줄러와 기본 리액티브 타입의 라이프사이클을 오버라이드하려는 테스트는 콜백 함수를 통해 사례별로 수행할 수 있습니다.</p>

<p>클래스에 기반을 둔 <code class="highlighter-rouge">RxJavaObservableHook</code> 및 친구들은 이제 없어졌으며 <code class="highlighter-rouge">RxJavaHooks</code>의 기능들은 <code class="highlighter-rouge">RxJavaPlugins</code> 에 흡수되었습니다.</p>

<h2 id="section-7">에러 처리</h2>

<p>2.x에서의 중요한 설계 요구사항 중 하나는 <code class="highlighter-rouge">Throwable</code> 에러를 무시해서는 안된다는 것입니다. 이것은 다운스트림의 라이프사이클이 이미 터미널 상태에 도달했거나 다운스트림이 에러를 방출하려고 했던 시퀀스를 취소했기 때문에 방출할 수 없는 에러를 의미합니다.</p>

<p>이러한 에러들은 <code class="highlighter-rouge">RxJavaPlugins.onError</code> 핸들러로 전달됩니다. 이 핸들러는 <code class="highlighter-rouge">RxJavaPlugins.setErrorHandler(Consumer)</code> 메소드로 오버라이드할 수 있습니다. 특정 핸들러가 없으면 RxJava는 기본적으로 Throwable의 스택 추적을 콘솔에 출력하고 현재 스레드의 포착되지 않은 예외 핸들러를 호출합니다.</p>

<p>데스크톱 자바에서 이 후처리기는 Executer-Service 기반 Scheduler에서 아무런 작업도 수행하지 않고 애플리케이션을 계속 실행합니다. 그러나 Android는 더 엄격하고 예기치 못한 예외 상황에서 애플리케이션을 종료합니다.</p>

<p>이 동작이 바람직할 경우 논쟁의 여지가 있지만, 어쨌든 잡히지 않은 에러 핸들러의 호출을 피하려면 RxJava 2를 사용하는 <strong>최종 응용 프로그램</strong>(직접 혹은 간접적으로)에 no-op 핸들러를 설정해야 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 자바 8의 람다식을 쓸 수 있을 때</span>
<span class="n">RxJavaPlugins</span><span class="o">.</span><span class="na">setErrorHandler</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">});</span>

<span class="c1">// Retrolambda나 Jack을 쓸 수 없을 때</span>
<span class="n">RxJavaPlugins</span><span class="o">.</span><span class="na">setErrorHandler</span><span class="o">(</span><span class="n">Functions</span><span class="o">.&lt;</span><span class="n">Throwable</span><span class="o">&gt;</span><span class="n">emptyConsumer</span><span class="o">());</span></code></pre></figure>

<p>중간 라이브러리가 자체 테스트 환경 밖에서 에러 핸들러를 변경하는 것은 권장되지 않습니다.</p>

<h2 id="scheduler">Scheduler</h2>

<p>2.x API에서도 <code class="highlighter-rouge">io.reactivex.schedulers.Schedulers</code> 유틸리티 클래스를 통해 계속 <code class="highlighter-rouge">computation</code>, <code class="highlighter-rouge">io</code>, <code class="highlighter-rouge">newThread</code>, <code class="highlighter-rouge">trampoline</code> 등의 기본 스케줄러 타입을 지원합니다.</p>

<p><code class="highlighter-rouge">immediate</code> 스케줄러는 2.x에서 없어졌습니다. 그것은 종종 잘못 사용되었고 <code class="highlighter-rouge">Scheduler</code>의 스펙을 올바르게 구현하지 못했습니다. 그것은 지연된 행동에 대한 sleep을 차단하는 것을 포함하며 재귀적 스케줄링을 전혀 지원하지 않았습니다. 대신 <code class="highlighter-rouge">Schedulers.trampoline()</code>을 사용하십시오.</p>

<p><code class="highlighter-rouge">Schedulers.test()</code>는 나머지 기본 스케줄러와의 개념 상의 차이를 피하기 위해 없어졌습니다. 그것들은 “글로벌” 스케줄러 인스턴스를 리턴하지만 <code class="highlighter-rouge">test()</code>는 항상 <code class="highlighter-rouge">TestScheduler</code>의 새로운 인스턴스를 리턴합니다. 테스트가 필요한 개발자는 이제 코드에서 단순히 <code class="highlighter-rouge">new TestScheduler()</code>를 사용하면 됩니다.</p>

<p><code class="highlighter-rouge">io.reactivex.Scheduler</code> 추상 기본 클래스는 이제 <code class="highlighter-rouge">Worker</code>(자주 잊어버릴 수 있습니다.)를 생성하고 제거할 필요 없이 직접 태스크를 스케쥴링합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Scheduler</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirect</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirect</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="kt">long</span> <span class="n">delay</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Disposable</span> <span class="nf">scheduleDirectPeriodically</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="kt">long</span> <span class="n">initialDelay</span><span class="o">,</span> 
        <span class="kt">long</span> <span class="n">period</span><span class="o">,</span> <span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">now</span><span class="o">(</span><span class="n">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

    <span class="c1">// ... 나머지는 비슷합니다: 라이프사이클 메소드나, Worker의 생성이나...</span>
<span class="o">}</span></code></pre></figure>

<p>주된 목적은 일반적으로 한번에 끝날 수 있는 작업에 대한 <code class="highlighter-rouge">Worker</code>의 추적 오버헤드를 피하는 것입니다. 이 메소드는 <code class="highlighter-rouge">createWorker</code>를 적절하게 재사용하는 기본 구현을 가지고 있지만 필요하다면 더욱 효율적인 구현으로 오버라이드할 수 있습니다.</p>

<p>스케줄러 자신의 현재 시각을 반환하는 메소드 <code class="highlighter-rouge">now()</code> 는 이제 시간의 측정 단위를 나타내기 위해 <code class="highlighter-rouge">TimeUnit</code>을 받을 수 있게끔 바뀌었습니다.</p>

<h2 id="section-8">리액티브 세계로 들어가기</h2>

<p>RxJava 1.x의 설계 결함 중 하나는 <code class="highlighter-rouge">rx.Observable.create()</code> 메소드가 노출된 것입니다. 이는 리액티브 세계에 들어가기 위해 사용하는 일반적인 연산자가 아닙니다. 불행히도 많은 사람들이 그것을 제거하거나 이름을 바꿀 수 없다는 사실에 의존하고 있습니다.</p>

<p>2.x부터는 새로운 출발이므로, 우리는 그런 실수를 반복하지 않을 것입니다. 각 리액티브 기본 타입인 <code class="highlighter-rouge">Flowable</code>, <code class="highlighter-rouge">Observable</code>, <code class="highlighter-rouge">Single</code>, <code class="highlighter-rouge">Maybe</code>, <code class="highlighter-rouge">Completable</code>은 Backpressure(<code class="highlighter-rouge">Flowable</code>만 해당)와 취소에 대한 올바른 작업을 수행하는 안전한 <code class="highlighter-rouge">create</code> 오퍼레이터를 특징으로 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">create</span><span class="o">((</span><span class="n">FlowableEmitter</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">emitter</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="n">emitter</span><span class="o">.</span><span class="na">onComplete</span><span class="o">();</span>
<span class="o">},</span> <span class="n">BackpressureStrategy</span><span class="o">.</span><span class="na">BUFFER</span><span class="o">);</span></code></pre></figure>

<p>실제로는 1.x의 <code class="highlighter-rouge">fromEmitter</code>(이전의 <code class="highlighter-rouge">fromAsync</code>)는 <code class="highlighter-rouge">Flowable.create</code>로 이름이 바뀌었습니다. 다른 기본 리액티브 타입들도 유사한 <code class="highlighter-rouge">create</code> 메소드를 가지고 있습니다. (Backpressure 전략을 제외한)</p>

<h2 id="section-9">리액티브 세계에서 떠나기</h2>

<p>각각의 소비자(<code class="highlighter-rouge">Subscriber</code>, <code class="highlighter-rouge">Observer</code>, <code class="highlighter-rouge">SingleObserver</code>, <code class="highlighter-rouge">MaybeObserver</code>, <code class="highlighter-rouge">CompletableObserver</code>)와 함수형 인터페이스에 기반을 둔 소비자(<code class="highlighter-rouge">subscribe(Consumer, Consumer, Action)</code>와 같은 것들)를 통해 기본 유형들을 구독하는 것과는 달리, 이전에는 1.x에선 별개로 있었던 <code class="highlighter-rouge">BlockingObservable</code>(와 비슷한 다른 클래스들)이 주요 리액티브 타입과 통합되었습니다. 이제 <code class="highlighter-rouge">blockingX</code> 연산을 직접 호출하여 몇가지 결과들을 직접 블로킹할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">).</span><span class="na">toList</span><span class="o">().</span><span class="na">blockingGet</span><span class="o">();</span> <span class="c1">// toList() returns Single</span>

<span class="n">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">100</span><span class="o">).</span><span class="na">blockingLast</span><span class="o">();</span></code></pre></figure>

<p>(그 이유는 성능과 동기식 Java 8 Streams와 비슷한 프로세서 라이브러리를 쓰는 것에 대한 용이함 때문입니다.)</p>

<p>또 다른 2.x에서 <code class="highlighter-rouge">rx.Subscriber</code>와 <code class="highlighter-rouge">org.reactivestreams.Subscriber</code>의 차이점은 여러분의 <code class="highlighter-rouge">Subscriber</code>와 <code class="highlighter-rouge">Observer</code>는 치명적인 예외를 발생하는 것을 허용하지 않는다는 점입니다.(<code class="highlighter-rouge">Exceptions.throwIfFatal()</code>을 보세요.) (Reactive-Streams 사양은 <code class="highlighter-rouge">onSubscribe</code>, <code class="highlighter-rouge">onNext</code>, <code class="highlighter-rouge">onError</code>가 null 값을 받으면 <code class="highlighter-rouge">NullPointerException</code>을 날릴 수 있지만 RxJava는 <code class="highlighter-rouge">null</code>을 허용하지 않습니다.) 이는 다음 코드는 더는 유효하지 않다는 것을 뜻합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSubscribe</span><span class="o">(</span><span class="n">Subscription</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onNext</span><span class="o">(</span><span class="n">Integer</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onError</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">IllegalArgumentException</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoSuchElementException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">subscriber</span><span class="o">);</span></code></pre></figure>

<p>같은 것들이 <code class="highlighter-rouge">Observer</code>, <code class="highlighter-rouge">SingleObserver</code>, <code class="highlighter-rouge">MaybeObserver</code>, <code class="highlighter-rouge">CompletableObserver</code>에도 적용되었습니다.</p>

<p>1.x를 타겟으로하는 많은 기존 코드가 그런 일을 하므로, 이러한 기준에 적합하지 않은 소비자를 처리하는 <code class="highlighter-rouge">safeSubscribe</code> 메소드가 도입되었습니다.</p>

<p>또는, <code class="highlighter-rouge">subscribe (Consumer, Consumer, Action)</code>(와 유사한) 메소드를 사용하여 다음을 던질 수 있는 콜백 혹은 람다식을 제공할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onNext</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onError</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onComplete</span><span class="o">,</span> 
    <span class="nl">subscriber:</span><span class="o">:</span><span class="n">onSubscribe</span>
<span class="o">);</span></code></pre></figure>

<h2 id="section-10">테스팅</h2>

<p>RxJava 2.x 테스트는 1.x에서와 같은 방식으로 작동합니다. <code class="highlighter-rouge">Flowable</code>은<code class="highlighter-rouge">io.reactivex.subscribers.TestSubscriber</code>로 테스트 할 수 있습니다. 반면에<code class="highlighter-rouge">Observable</code>, <code class="highlighter-rouge">Single</code>, <code class="highlighter-rouge">Maybe</code>, <code class="highlighter-rouge">Completable</code>은<code class="highlighter-rouge">io.reactivex.observers.TestObserver</code>로 테스트 할 수 있습니다.</p>

<h3 id="test-">test() “오퍼레이터”</h3>

<p>우리의 내부 테스트를 지원하기 위해, 모든 기본 리액티브 타입은 이제 <code class="highlighter-rouge">TestSubscriber</code> 또는<code class="highlighter-rouge">TestObserver</code>를 반환하는 <code class="highlighter-rouge">test()</code>메소드를 제공합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">to</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tso</span> <span class="o">=</span> <span class="n">Single</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tmo</span> <span class="o">=</span> <span class="n">Maybe</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">test</span><span class="o">();</span>

<span class="n">TestObserver</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">tco</span> <span class="o">=</span> <span class="n">Completable</span><span class="o">.</span><span class="na">complete</span><span class="o">().</span><span class="na">test</span><span class="o">();</span></code></pre></figure>

<p>두 번째 편리함은 대부분의 <code class="highlighter-rouge">TestSubscriber</code>/<code class="highlighter-rouge">TestObserver</code> 메소드가 인스턴스 자체를 반환하여 다양한 <code class="highlighter-rouge">assertX</code> 메소드와 연결될 수 있다는 것입니다. 세 번째 편리함은 코드에서 <code class="highlighter-rouge">TestSubscriber</code> / <code class="highlighter-rouge">TestObserver</code> 인스턴스를 생성하거나 삽입하지 않고 소스를 자유롭게 테스트할 수 있다는 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
	<span class="o">.</span><span class="na">test</span><span class="o">()</span>
	<span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span></code></pre></figure>

<h4 id="section-11">주목할만한 새로운 단언문 메소드</h4>

<ul>
  <li>
<code class="highlighter-rouge">assertResult(T... items)</code>: 구독할 때 지정된 순서로 지정된 항목을 정확히 수신한 뒤 에러 없이 <code class="highlighter-rouge">onComplete</code> 되는 것을 단언합니다.</li>
  <li>
<code class="highlighter-rouge">assertFailure(Class clazz, T... items)</code>: 구독할 때 지정된 순서로 지정된 항목을 정확히 수신한 뒤, <code class="highlighter-rouge">clazz.isInstance()</code>를 만족하는 <code class="highlighter-rouge">Throwable</code> 에러를 수신하는걸 단언합니다.</li>
  <li>
<code class="highlighter-rouge">assertFailureAndMessage(Class clazz, String message, T... items)</code>: <code class="highlighter-rouge">assertFailure</code>와 비슷한 역할을 하며, <code class="highlighter-rouge">getMessage()</code>를 통해 특정 에러 메시지를 validation 하는 기능이 더해졌습니다.</li>
  <li>
<code class="highlighter-rouge">awaitDone(long time, TimeUnit unit)</code>은 블로킹 방식으로 터미널 이벤트를 기다리고, 타임아웃이 경과하면 시퀀스를 취소합니다.</li>
  <li>
<code class="highlighter-rouge">assertOf(Consumer&gt; consumer)</code>는 단언문을 자연스러운 체인에 구성합니다. (오퍼레이터 결합이 현재 아직 공개된 API가 아니기 때문에 결합 테스트를 위해 내부적으로 사용됩니다.)</li>
</ul>

<p><code class="highlighter-rouge">Flowable</code>을 <code class="highlighter-rouge">Observable</code>로 변경하면서 생기는 이점 중 하나는 <code class="highlighter-rouge">TestSubscriber</code>를 <code class="highlighter-rouge">TestObserver</code>로 암시적으로 변경했기 때문에, 테스트 코드를 전혀 변경할 필요가 없다는 것입니다.</p>

<h3 id="section-12">취소와 먼저 요청하기</h3>

<p><code class="highlighter-rouge">TestObserver</code>에 있는 <code class="highlighter-rouge">test()</code> 메소드는 <code class="highlighter-rouge">test(boolean cancel)</code>을 오버로드해, 구독하기도 전에 <code class="highlighter-rouge">TestSubscriber</code>/<code class="highlighter-rouge">TestObserver</code>를 취소하거나 정리합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PublishSubject</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">PublishSubject</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="c1">// 아직 아무도 구독하지 않았음</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">hasSubscribers</span><span class="o">());</span>

<span class="n">pp</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

<span class="c1">// 여전히 아무도 구독하지 않았음</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="n">pp</span><span class="o">.</span><span class="na">hasSubscribers</span><span class="o">());</span></code></pre></figure>

<p><code class="highlighter-rouge">TestSubscriber</code>는 <code class="highlighter-rouge">test(long initialRequest)</code>와 <code class="highlighter-rouge">test(long initialRequest, boolean cancel)</code> 오버로드로 처음 요청할 양을 지정하고, <code class="highlighter-rouge">TestSubscriber</code>도 즉시 취소해야하는지 여부를 지정합니다.  <code class="highlighter-rouge">initialRequest</code>가 주어지면 <code class="highlighter-rouge">TestSubscriber</code> 인스턴스는 <code class="highlighter-rouge">request()</code> 메소드에 접근하기 위해 캡쳐해야 합니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PublishProcessor</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">PublishProcessor</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>

<span class="n">TestSubscriber</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="na">test</span><span class="o">(</span><span class="mi">0L</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

<span class="n">pp</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">pp</span><span class="o">.</span><span class="na">onNext</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="n">ts</span><span class="o">.</span><span class="na">assertFailure</span><span class="o">(</span><span class="n">MissingBackpressureException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h3 id="section-13">비동기 소스를 테스팅하기</h3>

<p>비동기 소스가 주어지면 터미널 이벤트를 자연스럽게 차단할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">.</span><span class="na">subscribeOn</span><span class="o">(</span><span class="n">Schedulers</span><span class="o">.</span><span class="na">single</span><span class="o">())</span>
  <span class="o">.</span><span class="na">test</span><span class="o">()</span>
  <span class="o">.</span><span class="na">awaitDone</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">)</span>
  <span class="o">.</span><span class="na">assertResult</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></code></pre></figure>

<h3 id="mockito-testsubscriber">Mockito와 TestSubscriber</h3>

<p>Mockito를 사용하고, 1.x에서 모킹된 Observer를 쓰는 사람들은 <code class="highlighter-rouge">Subscriber.onSubscribe</code> 메소드를 모킹해서 초기 요청을 보내야 합니다. 그렇지 않으면 시퀀스가 멈추거나, 핫 소스와 함께 실패하게 됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">mockSubscriber</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">w</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">Subscriber</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="n">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="k">new</span> <span class="n">Answer</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="nf">answer</span><span class="o">(</span><span class="n">InvocationOnMock</span> <span class="n">a</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="n">Subscription</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">getArgumentAt</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">Subscription</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="n">s</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">w</span><span class="o">).</span><span class="na">onSubscribe</span><span class="o">((</span><span class="n">Subscription</span><span class="o">)</span><span class="n">any</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h2 id="section-14">오퍼레이터 변경 사항</h2>

<p>대부분의 오퍼레이터는 2.x에서 여전히 사용되고 있으며 거의 모든 오퍼레이터는 1.x에서와 비슷하게 동작합니다. 다음 하위 섹션에서는 각 기본 리액티브 타입과 1.x와 2.x에서의 차이점이 나와있습니다.</p>

<p>일반적으로 많은 오퍼레이터가 업스트림(또는 내부 소스)을 실행해야 하는 내부 버퍼 크기 또는 pre-fetch 양을 지정할 수 있게 되어 오버로드가 늘었습니다.</p>

<p>일부 연산자 오버로드는 <code class="highlighter-rouge">fromArray</code>, <code class="highlighter-rouge">fromIterable</code> 등과 같이 접미사를 포함해 이름이 바뀌었습니다. 그 이유는 라이브러리가 Java 8로 컴파일 될 때, javac가 함수형 인터페이스 타입을 명확하게 파악할 수 없기 때문입니다.</p>

<p>1.x에서 <code class="highlighter-rouge">@Beta</code>나 <code class="highlighter-rouge">@Experimental</code>였던 오퍼레이터들은 이제 표준이 되었습니다.</p>

<h3 id="x-observable-2x-flowable">1.x Observable에서 2.x Flowable로</h3>

<h4 id="section-15">팩토리 메소드:</h4>

<table>
  <thead>
    <tr>
      <th>1.x</th>
      <th>2.x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">amb</code></td>
      <td>
<code class="highlighter-rouge">amb(ObservableSource...)</code>  오버로드가 추가되고, 인자가 2-9개인 버전이 삭제되었습니다.</td>
    </tr>
    <tr>
      <td>RxRingBuffer.SIZE</td>
      <td><code class="highlighter-rouge">bufferSize()</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">combineLatest</code></td>
      <td>가변인자 오버로드가 추가되었습니다. <code class="highlighter-rouge">bufferSize</code> 인자에 대한 오버로드가 추가되었고, <code class="highlighter-rouge">combineLatest(List)</code>가 없어졌습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concat</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 5-9 소스에 대한 오버로드가 없어졌습니다, 대신 <code class="highlighter-rouge">concatArray</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">concatArray</code>와  <code class="highlighter-rouge">concatArrayDelayError</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">concatArrayEager</code>와 <code class="highlighter-rouge">concatArrayEagerDelayError</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatDelayError</code></td>
      <td>끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatEagerDelayError</code></td>
      <td>끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(SyncOnSubscribe)</code></td>
      <td>
<code class="highlighter-rouge">generate</code>로 바뀌었습니다. 인터페이스의 변경으로 한번에 구현할 수 있게 되었습니다. 이에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(AsnycOnSubscribe)</code></td>
      <td>변경 사항이 없습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">create(OnSubscribe)</code></td>
      <td>안전한 <code class="highlighter-rouge">create(FlowableOnSubscribe, BackpressureStrategy)</code>으로 목적이 바뀌었습니다. raw 형태의 지원은 <code class="highlighter-rouge">unsafeCreate()</code>를 이용합니다..</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">from</code></td>
      <td>
<code class="highlighter-rouge">fromArray</code>, <code class="highlighter-rouge">fromIterable</code>, <code class="highlighter-rouge">fromFuture</code>로 모호함을 없앴습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">fromPublisher</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">fromAsync</code></td>
      <td>
<code class="highlighter-rouge">create()</code>로 이름이 바뀌었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">intervalRange()</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">limit</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">take</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">merge</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">mergeDelayError</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">sequenceEqual</code></td>
      <td>
<code class="highlighter-rouge">bufferSize</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchOnNext</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchOnNextDelayError</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">timer</code></td>
      <td>사용하지 않게 된 오버로드를 없앴습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">zip</code></td>
      <td>
<code class="highlighter-rouge">bufferSize</code>와  <code class="highlighter-rouge">delayErrors</code> 가능성에 대한 오버로드가 추가되었습니다. <code class="highlighter-rouge">zipArray</code>, <code class="highlighter-rouge">zipIterable</code>와의 모호함을 없앴습니다.</td>
    </tr>
  </tbody>
</table>

<h4 id="section-16">인스턴스 메소드:</h4>

<table>
  <thead>
    <tr>
      <th>1.x</th>
      <th>2.x</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">all</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">any</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">asObservable</code></td>
      <td>
<code class="highlighter-rouge">hide()</code>로 바뀌었습니다. 이제 모든 아이덴티티를 숨깁니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">buffer</code></td>
      <td>커스텀 <code class="highlighter-rouge">Collection</code> 서플라이어에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">cache(int)</code></td>
      <td>사용되지 않으며, 삭제되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">collect</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">collect(U, Action2)</code></td>
      <td>
<code class="highlighter-rouge">collectInto</code>와의 모호함을 없애고 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMap</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapDelayError</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapEager</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">concatMapEagerDelayError</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다. 끝날 때까지, 또는 끝까지 지연시키는 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">count</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">countLong</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">count</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">distinct</code></td>
      <td>커스텀 Collection 서플라이어에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">doOnCompleted</code></td>
      <td>
<code class="highlighter-rouge">doOnComplete</code>로 이름이 바뀌었습니다. <code class="highlighter-rouge">d</code>가 빠졌다는걸 유의하세요!</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">doOnUnsubscribe</code></td>
      <td>
<code class="highlighter-rouge">Flowable.doOnCancel</code>와 다른 타입에서는 <code class="highlighter-rouge">doOnDispose</code>로 바뀌었습니다. <a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#dooncanceldoondisposeunsubscribeon">추가 정보</a>
</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">onSubscribe</code>를 다루고, <code class="highlighter-rouge">request</code>와 <code class="highlighter-rouge">cancel</code>를 관찰할 수 있는 <code class="highlighter-rouge">doOnLifecycle</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int)</code></td>
      <td>
<strong>RC3</strong>부터는 소스가 인덱스보다 짧은 경우에 <code class="highlighter-rouge">NoSuchElementException</code>을 내지 않습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(Func1, int)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).elementAt(int)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAtOrDefault(int, T)</code></td>
      <td>
<code class="highlighter-rouge">elementAt(int, T)</code>로 이름이 바뀌었으며 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAtOrDefault(Func1, int, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).elementAt(int, T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first()</code></td>
      <td>
<strong>RC3</strong>부터 <code class="highlighter-rouge">firstElement</code>로 이름이 바뀌었으며 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).first()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstOrDefault(T)</code></td>
      <td>
<code class="highlighter-rouge">first(T)</code>로 바뀌었으며 <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).first(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">flatMap</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>조건부로 소비를 중지하기 위한 <code class="highlighter-rouge">forEachWhile(Predicate, [Consumer, [Action]])</code>이 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">groupBy</code></td>
      <td>
<code class="highlighter-rouge">bufferSize</code>와 <code class="highlighter-rouge">delayError</code> 옵션에 대한 오버로드가 추가되었습니다. <em>커스텀 내부 맵 버전이 RC1에 포함되지 않았습니다.</em>
</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ignoreElements</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Completable</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">isEmpty</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last()</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">lastElement</code>로 이름이 바뀌었으며, <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).last()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastOrDefault(T)</code></td>
      <td>
<code class="highlighter-rouge">last(T)</code>로 이름이 바뀌었습니다. <strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).last(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">nest</code></td>
      <td>없어졌습니다. 수동으로 <code class="highlighter-rouge">just</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">publish(Func1)</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(Func2)</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>가입자-개별(Subscriber-Individual) 방식으로 줄이는 <code class="highlighter-rouge">reduceWith(Callable, BiFunction)</code>가 추가되었습니다. <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">repeatUntil(BooleanSupplier)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">repeatWhen(Func1, Scheduler)</code></td>
      <td>오버로드가 없어졌습니다. 대신 <code class="highlighter-rouge">subscribeOn(Scheduler).repeatWhen(Function)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">retry</code></td>
      <td>
<code class="highlighter-rouge">retry(Predicate)</code>, <code class="highlighter-rouge">retry(int, Predicate)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">retryUntil(BooleanSupplier)</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">retryWhen(Func1, Scheduler)</code></td>
      <td>오버로드가 없어졌습니다. 대신 <code class="highlighter-rouge">subscribeOn(Scheduler).retryWhen(Function)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>가입자-개별(Subscriber-Individual) 방식으로 스캔하는 <code class="highlighter-rouge">sampleWith(Callable, BiFunction)</code>이 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single()</code></td>
      <td>
<strong>RC3</strong>부터 <code class="highlighter-rouge">singleElement</code>로 이름이 바뀌었으며 <code class="highlighter-rouge">Maybe</code>를 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single(Func1)</code></td>
      <td>없어졌습니다. 대신 <code class="highlighter-rouge">filter(predicate).single()</code>을 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleOrDefault(T)</code></td>
      <td>
<code class="highlighter-rouge">single(T)</code>로 이름이 바뀌었으며, <strong>RC3</strong>부터 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleOrDefault(Func1, T)</code></td>
      <td>없어졌습니다. <code class="highlighter-rouge">filter(predicate).single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">skipLast</code></td>
      <td>
<code class="highlighter-rouge">bufferSize</code>, <code class="highlighter-rouge">delayError</code> 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">startWith</code></td>
      <td>인자가 2-9개인 버전이 삭제되었습니다. 대신  <code class="highlighter-rouge">startWithArray</code>을 쓰세요.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>added <code class="highlighter-rouge">startWithArray</code> to disambiguate</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>added <code class="highlighter-rouge">subscribeWith</code> that returns its input after subscription</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchMap</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code> 인자에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">switchMapDelayError</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code> 인자에 대한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">takeLastBuffer</code></td>
      <td>없어졌습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">test()</code>가 추가되었습니다. (<code class="highlighter-rouge">TestSubscriber</code>를 반환하여 이를 구독할 수 있습니다.) 자연스러운 테스트를 위한 오버로드가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">timeout(Func0, ...)</code></td>
      <td>
<code class="highlighter-rouge">timeout(Publisher, ...)</code>로 서명이 바뀌었습니다. 가능할 경우  <code class="highlighter-rouge">defer(Callable&gt;)</code>를 써주세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toBlocking().y</code></td>
      <td>
<code class="highlighter-rouge">toFuture</code>를 제외하고는 <code class="highlighter-rouge">blockingY()</code> 오퍼레이터로 인라인됩니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toCompletable</code></td>
      <td>
<strong>RC3</strong>에서 없어졌습니다. <code class="highlighter-rouge">ignoreElements</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toList</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMap</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMultimap</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">toFuture</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td>N/A</td>
      <td>
<code class="highlighter-rouge">toObservable</code>가 추가되었습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSingle</code></td>
      <td>
<strong>RC3</strong>에서 없어졌습니다. <code class="highlighter-rouge">single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSortedList</code></td>
      <td>
<strong>RC3</strong>부터는 <code class="highlighter-rouge">Single</code>을 반환합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">withLatestFrom</code></td>
      <td>5-9 소스 오버로드가 없어졌습니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">zipWith</code></td>
      <td>
<code class="highlighter-rouge">prefetch</code>와  <code class="highlighter-rouge">delayErrors</code> 옵션에 대한 오버로드가 추가되었습니다.</td>
    </tr>
  </tbody>
</table>

<h4 id="section-17">달라진 반환 타입</h4>

<p>정확히 하나의 값이나 에러를 생성한 오퍼레이터는 2.x에서는 <code class="highlighter-rouge">Single</code>을 반환합니다. (빈 소스가 허용되면 <code class="highlighter-rouge">Maybe</code>도 가능합니다).</p>

<p><em>(Remark: 이는 RC2와 RC3에서 혼합된 타입의 시퀀스로 프로그래밍하는게 어떤지, 또 거기에 너무 많은 toObservable/toFlowable 변환이 너무 많지 않은지를 보기 위한 “실험적 기능”입니다.)</em></p>

<table>
  <thead>
    <tr>
      <th>오퍼레이터</th>
      <th>예전 반환 타입</th>
      <th>새 반환 타입</th>
      <th>비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">all(Predicate)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>모든 요소가 인자와 일치하면 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">any(Predicate)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>특정 요소가 인자와 일치하면 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">count()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>시퀀스에 있는 항목의 갯수를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>주어진 인덱스의 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">elementAt(int, T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>주어진 인덱스의 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">first(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>첫 항목을 방출하거나 <code class="highlighter-rouge">NoSuchElementException</code>를 냅니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">firstElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>첫 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ignoreElements()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Completable</code></td>
      <td>터미널 이벤트를 제외한 모든 걸 무시합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">isEmpty()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>소스가 비어있을 때 true를 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">last(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>마지막 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">lastElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>맨 마지막 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>줄어든 값을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduce(Callable, BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>초깃값 혹은 줄어든 값을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">reduceWith(U, BiFunction)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>초깃값 혹은 줄어든 값을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">single(T)</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>유일한 항목 혹은 미리 지정한 항목을 방출합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">singleElement()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Maybe</code></td>
      <td>유일한 항목을 방출하거나 완료합니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toList()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>
<code class="highlighter-rouge">List</code>로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMap()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>
<code class="highlighter-rouge">Map</code>으로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toMultimap()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>
<code class="highlighter-rouge">Map</code>과 콜렉션으로 항목을 모읍니다.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">toSortedList()</code></td>
      <td><code class="highlighter-rouge">Observable</code></td>
      <td><code class="highlighter-rouge">Single</code></td>
      <td>
<code class="highlighter-rouge">List</code>로 항목을 모으고 정렬합니다.</td>
    </tr>
  </tbody>
</table>

<h3 id="section-18">삭제된 사항</h3>

<p>2.0의 최종 API를 최대한 깨끗하게 만들기 위해, 우리는 릴리즈 후보를 거치면서 메소드와 일부 컴포넌트를 사용되지 않도록 만들지 않고 바로 삭제했습니다.</p>

<table>
  <thead>
    <tr>
      <th>삭제된 버전</th>
      <th>컴포넌트</th>
      <th>대안</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toCompletable()</code></td>
      <td>
<code class="highlighter-rouge">Flowable.ignoreElements()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toSingle()</code></td>
      <td>
<code class="highlighter-rouge">Flowable.single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Flowable.toMaybe()</code></td>
      <td>
<code class="highlighter-rouge">Flowable.singleElement()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toCompletable()</code></td>
      <td>
<code class="highlighter-rouge">Observable.ignoreElements()</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toSingle()</code></td>
      <td>
<code class="highlighter-rouge">Observable.single(T)</code>를 쓰세요.</td>
    </tr>
    <tr>
      <td>RC3</td>
      <td><code class="highlighter-rouge">Observable.toMaybe()</code></td>
      <td>
<code class="highlighter-rouge">Observable.singleElement()</code>를 쓰세요.</td>
    </tr>
  </tbody>
</table>

<h2 id="section-19">잡다한 변경사항</h2>

<h3 id="dooncancel--doondispose--unsubscribeon">doOnCancel / doOnDispose / unsubscribeOn</h3>

<p>1.x에서는 <code class="highlighter-rouge">SafeSubscriber</code>가 자체적으로 <code class="highlighter-rouge">unsubscribe</code>를 호출했기 때문에 <code class="highlighter-rouge">doOnUnsubscribe</code>는 터미널 이벤트에서 항상 실행되었습니다. 이것은 실질적으로 불필요한 일이며, Reactive-Streams 사양에서는 터미널 이벤트가 <code class="highlighter-rouge">Subscriber</code>에게 도착하면 업스트림 <code class="highlighter-rouge">Subscription</code>이 취소된 것으로 간주하여야 하므로<code class="highlighter-rouge">cancel()</code>을 호출하는 것은 아무 작업도 수행하지 않아야한다고 명시합니다.</p>

<p>같은 이유로 <code class="highlighter-rouge">unsubscribeOn</code>는 일반적인 종료 경로에서 호출되지 않고 체인에서 실제 <code class="highlighter-rouge">cancel</code>(또는 <code class="highlighter-rouge">dispose</code>)  호출이 있을 때만 호출됩니다.</p>

<p>따라서 다음 시퀀스는 <code class="highlighter-rouge">doOnCancel</code>을 호출하지 않을 것입니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">doOnCancel</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cancelled!"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span></code></pre></figure>

<p>그러나 다음 시퀀스는 <code class="highlighter-rouge">take</code> 오퍼레이터가 <code class="highlighter-rouge">onNext</code> 이벤트가 전달된 후에 취소되기 때문에 <code class="highlighter-rouge">doOnCancel</code>이 호출됩니다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Flowable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">.</span><span class="na">doOnCancel</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Cancelled!"</span><span class="o">))</span>
  <span class="o">.</span><span class="na">take</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span></code></pre></figure>

<p>만약 일반적인 터미네이션 과정이나 종료 과정에서 모두 정리를 해야할 때는, 대신 <code class="highlighter-rouge">using</code> 오퍼레이터를 쓰는걸 고려해보세요.</p>

<h1 id="section-20">후기</h1>

<p>주관적인 생각이지만 영어 번역은 확실히 일본어 번역보다 더 어려웠던 것 같습니다. 특히 글의 분량도 많았고, 어떻게 하면 이 표현을 자연스럽게 우리말로 쓸 수 있을까에 대한 고민도 꽤 했지만 그럼에도 많이 부족한 것 같습니다. 이 글을 통해 RxJava 2가 어떤 점들이 바뀌었는지 아는데 도움이 되면 좋겠습니다. 오타나 번역에 대한 지적이라던가 댓글은 언제나 환영합니다. 감사합니다. :D</p>

    <h5> <!-- footer start -->

<footer class="site-footer">
  <a class="subscribe" href="/feed.xml"> <span class="tooltip"> <i class="fa fa-rss"></i> Subscribe!</span></a>
    <div class="inner">
         <section class="copyright">All content copyright <a href="mailto:hazelee@re.aligni.st">Haze Lee</a> © 2017 • All rights reserved.</section>
         <section class="poweredby">For Geeky Tomorrow.</section>
    </div>
</footer>

<!-- footer end -->
</h5>
  </body>
</html>