<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haze Park</title>
    <description>책, 음악, 코딩, 피카츄와 함께하는 곳.</description>
    <link>http://realignist.me/</link>
    <atom:link href="http://realignist.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 03 Mar 2016 08:57:31 +0900</pubDate>
    <lastBuildDate>Thu, 03 Mar 2016 08:57:31 +0900</lastBuildDate>
    <generator>Jekyll v3.0.3</generator>
    
      <item>
        <title>피카츄의 기묘한 딥러닝 체험</title>
        <description>&lt;p&gt;최근에 나는 프로그래밍을 이용해서 재밌는 것들을 많이 하려고 노력하는 편인데, 프로그래밍을 이용한 영상 편집이 필요하다는 부탁을 듣고 작업을 하면서 딥러닝이 어떤 것인지 아주 조금 체험할 수 있었다. 다만 그 과정이 정말 기괴하고 힘든 삽질들로 가득했기 때문에 조금이나마 기록을 남기고자 한다. 이 글에서는 Ubuntu 14.04.4를 기준으로 설명해보고자 한다. 또한 이 글을 통해 딥러닝을 같이 체험해보고 싶다면 고사양의 Nvidia GPU가 있는 머신에서 작업하길 권장한다. 아니면 Amazon EC2의 GPU 인스턴스도 좋다. (이 글에서는 CUDA를 활용하고 있다. 나는 i7 6700K와 32GB RAM 환경에서 작업했었는데… 그래픽카드에 대해서는 후술하겠다.)&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;뭘 했는데?&lt;/h4&gt;

&lt;p&gt;내가 한 것은 뮤직비디오의 편집이었는데 뮤직비디오의 컨셉이 싸이키델릭이었다. 기계 학습을 통해서 기계가 만들어낸 이미지는 정말로 난해했고, 뮤직비디오를 만드는 형님은 이 난해함을 영상에 담고 싶었지만 기존의 영상 편집 기술로는 어려웠다고 한다. 찾아보니까 이러한 것을 &lt;strong&gt;“DeepDream”&lt;/strong&gt;이라고 사람들은 부르며 이러한 비디오를 합성할 수 있는 것이 &lt;a href=&quot;https://github.com/graphific/DeepDreamVideo&quot;&gt;GitHub&lt;/a&gt;에 있었다. 사실 이때는 내가 이렇게 미친 삽질들을 할지는 미쳐 알지 못했다.&lt;/p&gt;

&lt;h4 id=&quot;deepdreamvideo-&quot;&gt;DeepDreamVideo는 간단해보였다…&lt;/h4&gt;

&lt;p&gt;처음엔 이게 단순하게 영상을 프레임 단위로 나누어서 이미지 파일로 만들고, 이미지 파일들을 모델 이미지와 섞어서 DeepDream을 구현한 뒤, 그 이미지들을 다시 영상으로 합치는 것이라고 생각했다. 그랬기에 적당히 CPU와 GPU가 좋은 컴퓨터 하나만 있으면 금방할 수 있을 것이라고 생각했다. 다만 내가 생각했던 것은 너무 단순했고 이 안에서 DeepDream을 구현하는 과정이 정말로 스펙터클했다.&lt;/p&gt;

&lt;p&gt;우선 DeepDreamVideo는 영상을 프레임 단위로 분해하고 프레임들을 다시 영상으로 합치기 위해서 ffmpeg나 avconv, mplayer 등을 필요로 한다. 또한 jpg나 png에 맞는 이미지 라이브러리도 필요로 하는데, png의 경우 pngcrush를 요구했다. 나는 ffmpeg를 사용했는데 pngcrush 없이 아래와 같이 ffmpeg 커맨드만으로도 png로 추출할 수 있었다.(도와준 &lt;a href=&quot;http://twitter.com/hibiyasleep&quot;&gt;종이&lt;/a&gt;에게 고맙다는 인사를 전한다.)&lt;/p&gt;

&lt;pre class=&quot; language-bash &quot;&gt;&lt;code&gt;ffmpeg -threads 8 -i master_file.mov -vf fps=30 %08d.png&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 실제로 DeepDream을 만들어내는 Python 코드를 보면 numpy, protobuf, scikit-image, caffe 등을 필요로 한다. caffe를 제외한 셋은 pip를 통해서 설치 가능하다. 문제는 이 caffe였다.&lt;/p&gt;

&lt;h4 id=&quot;cuda-caffe-&quot;&gt;CUDA, Caffe와의 씨름&lt;/h4&gt;

&lt;p&gt;이제 Caffe에 대해서 이야기를 해보려면 CUDA 이야기를 빼놓을 수가 없다. DeepDreamVideo가 사용하고 있는 Caffe는 Berkeley Vision and Learning Center(BVLC)에서 만든 오픈소스 딥러닝 프레임워크다. 이 딥러닝 과정에 GPU 가속을 사용하기 위해서 CUDA 환경이 필요하다. 처음에 CUDA 환경을 구축할 때, 리누스 토발즈가 엔비디아한테 가운데 손가락을 날리면서 “So nVidia, Fu** you”라고 외치는 것이 떠올랐고… 내가 엔비디아 욕을 하지 않길 원했지만 CUDA 가속 때문에 2시간 정도를 날리고 나니까 자연스럽게 입에서 거친 말들이 나왔다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*tIJf0McU91OAqRQOoRJoWg.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;엔비디아를 향한 리누스 토발즈의 욕설은 유명하다. 한때 내 마음도 그와 같았다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;내가 CUDA 환경을 구축하고 Caffe를 빌드하는데에는 &lt;a href=&quot;https://www.reddit.com/r/deepdream/comments/3cd1yf/howto_install_on_ubuntulinux_mint_including_cuda/&quot;&gt;Reddit에 정리된 글&lt;/a&gt;을 참고해서 진행했는데, 글이 매우 잘 정리된 편이지만 몇가지 글에서 조심할 점들을 이야기해보겠다. 이것들을 고치고 나서 나는 CUDA 환경을 구축할 수 있었다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;“/etc/modprobe.d/blacklist.conf”를 설정하지 말아라. 나중에 씁쓸한 오류를 맛보게 될 것이다.&lt;/li&gt;
  &lt;li&gt;처음에 “sudo su”로 root 유저로 들어가면 “~/”로 하는 것들이 사용자의 유저 디렉토리가 아니라 root 유저 디렉토리에 진행되므로,
나중에 일관성이 깨진다. sudo를 계속 사용하거나 아니면 root 계정에서 진행을 하자. 나는 전자를 추천한다.&lt;/li&gt;
  &lt;li&gt;Cuda 7.0을 계속 설치해보려고 했지만 Ubuntu 14.04.4에서는 잘 되지 않았다. 여러번 설치와 삭제를 반복해본 뒤에 나는 Cuda
7.5로 설치를 성공했다.&lt;/li&gt;
  &lt;li&gt;Ubuntu 14.04.4 기준 mdm이라는 service는 존재하지 않는다. Cuda(와 엔비디아의 드라이버)를 설치하기 위해서는 X
Window는 꺼져있어야 한다. 그러기 위해서는 “sudo service lightdm stop / start / restart”를 이용하자.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Caffe 빌드를 위해서는 위에서 언급한 Reddit의 글대로 진행하면 되는데 나는 CUDNN이나 CPU_ONLY, Intel Composer XE같은 것들의 설정을 하지 않고 바로 빌드를 했다. 다른 점이 있다면 나는 &lt;a href=&quot;https://github.com/NVIDIA/caffe&quot;&gt;엔비디아에서 Fork한 Caffe&lt;/a&gt;를 빌드했다는 점이다. 둘 다 써본 결과, 큰 차이가 없기 때문에 어느
쪽을 사용해도 큰 차이는 없을 것이다.&lt;/p&gt;

&lt;p&gt;Google의 DeepDream을 설치할 필요는 없지만, Caffe 내의 모델로 “bvlc_googlenet.caffemodel”는 꼭 설치해야한다.&lt;/p&gt;

&lt;h4 id=&quot;deepdreamvideo&quot;&gt;이제 진짜 DeepDreamVideo를…?&lt;/h4&gt;

&lt;p&gt;사실 여기까지 보는 사람들은 별 것 아니라고 생각할 것이지만, 본인은 딥러닝 등에 대한 경험이 전무했고 소위 초고수가 아니기 때문에 4시간을 삽질하면서 구축했기 때문에 매우 험난하고 지친 과정이었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*BtpZhonatJN9AnSxjpssdg.png&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;나는 그분처럼 전체 글을 봐도 내가 어떻게 환경을 구축해야할지 감이 잘 오지 않았다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;동영상을 프레임으로 쪼개는 작업은 이미 끝났고, python을 이용해서 아래와 같이 실행을 했다.&lt;/p&gt;

&lt;pre class=&quot; language-bash &quot;&gt;&lt;code&gt;python dreaming_time.py -it png -i results -o output_”$1&quot; -gi /media/user/image-dreamer/models/”$1&quot;.jpg —-gpu 0 -b random -t ~/caffe/models/bvlc_googlenet/ -m bvlc_googlenet.caffemodel&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“어? 아… 안 되잖아? 이런 일이 일어날 것 같은 조짐을 느꼈지.” 나는 처음에 GTX960을 이용해서 작업을 진행하려고 했었다. 동영상 파일은 3GB가 넘었고, 프레임들이 저장된 폴더는 13GB가 넘었었다. 2GB의 그래픽 메모리를 가지고 있었던 GTX960은 CUDA에서 Out Of Memory를 외치며 죽어버렸고 나는 이것을 단순히 Caffe에서의 batch_size 문제라고 생각을 했지만… 하드웨어의 한계는 명확했다. 일단 작업하던 컴퓨터를 열고, GTX960을 뽑고 작업하던 스튜디오에서 제일 좋은 성능의 GTX980Ti를 박았다. 당연히 파워를 그대로 썼다간 바로 뻗을거라고 생각해서 스튜디오에 남아있던 1300W짜리 파워를 연결했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*mik7GgJKDb8N7-JfMHeWew.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;아무도 ITX 보드에 GTX980Ti를 박을거라고 생각도 못했을걸?&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;그러고보니 작업용 컴퓨터를 분해하면서 M.2 SSD가 어디에 있는지 한참을 헤맸는데 기가바이트 GA-Z170M-GAMING 5 기준으로는 보드 아랫면에 있었다. 솔직히 좀 충격이었다. 2816 CUDA Core에 6GB 그래픽 메모리가 담긴 크고 아름다운 GTX980Ti를 넣자 그제야 DeepDreamVideo는 멀쩡히 작동하기 시작했다.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;마지막 최적화를 향한 나름대로의 발악&lt;/h4&gt;

&lt;p&gt;전체 뮤직비디오 영상을 프레임으로 쪼개니까 약 8000~9000개의 png 파일로 나뉘었고 이걸 하나하나 DeepDream하게 뽑아내는 작업을 했다. 1 프레임당 3초 정도의 시간이 소요됬으며 이렇게 진행하면 약 7~8시간이 소요되었을 것이라고 나왔다. 이건 아니라고 생각해서 당장 그래픽카드를 오버클럭했는데, Asus의 ROG GTX980Ti Platinum은 애초에 오버클럭용으로 나왔기 때문에 뭔가 걱정은 들지 않았다. 아래 코드의 첫번째 줄과 같이 설정을 해주고 재부팅을 한 뒤 두번째 줄을 실행하자.&lt;/p&gt;

&lt;pre class=&quot; language-bash &quot;&gt;&lt;code&gt;sudo nvidia-xconfig --cool-bits=28
nvidia-settings&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;여러가지 정책들을 통해 GPU Fan 소리는 60%로 고정하고, 그래픽 클럭은 100~150MHz의 클럭을 올렸고 그래픽 메모리 클럭은 1000MHz 정도 올렸다. 그럼에도 불구하고 실행 속도가 특별히 개선되거나 하는 일은 없었다. 뮤직비디오를 만드신 형님이 DeepDream을 적용할 구간만 따로 편집해서 다시 주셔서 프레임은 3000~4000개 전후로 작업할 수 있었다.&lt;/p&gt;

&lt;p&gt;사실 실제로 돌려보고 나니까 알게된 점은 이미지를 그래픽 메모리에 담아야 해서 그래픽 메모리의 점유율이 높았지 특별히 GPU나 CPU의 연산을 많이 사용하지 않았다. (GPU의 경우 GTX980Ti라서 크게 부담스럽지 않았을 수도 있다.) 다만 하나를 실행하니까 그래픽 메모리 5.2GB를 한번에 Python 프로세스가 차지했을 정도였기 때문에 동시에 여러 딥러닝 프로세스를 돌릴 수는 없었다.&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;후기와 참조 링크&lt;/h4&gt;

&lt;p&gt;처음으로 딥러닝을 만져본 후기는 정말 하드웨어빨이 중요하다는 것이었다. 또 관련된 논문을 읽어본 결과 아직 나는 이게 내부에서 어떻게 동작하는지 명확하게 알지도 못하는 정도라는걸 알았고 더 많이 공부하고자 하는 자극이 되었다. 나는 아래 링크들을 많이 참조했으며, 일부 개인적으로 좀 쓰기 편하게 DeepDreamVideo를 수정했다. 그 소스코드는 몇 일 정도 렌더링 작업이 끝나면 GitHub에 문서와 함께 공유하고자 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/graphific/DeepDreamVideo&quot;&gt;https://github.com/graphific/DeepDreamVideo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Dhar/image-dreamer&quot;&gt;https://github.com/Dhar/image-dreamer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/NVIDIA/caffe&quot;&gt;https://github.com/NVIDIA/caffe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/deepdream/comments/3cawxb/what_are_deepdream_images_how_do_i_make_my_own/&quot;&gt;https://www.reddit.com/r/deepdream/comments/3cawxb/what_are_deepdream_images_how_do_i_make_my_own/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/deepdream/comments/3cd1yf/howto_install_on_ubuntulinux_mint_including_cuda/&quot;&gt;https://www.reddit.com/r/deepdream/comments/3cd1yf/howto_install_on_ubuntulinux_mint_including_cuda/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.nvidia.com/cuda-downloads&quot;&gt;https://developer.nvidia.com/cuda-downloads&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 28 Feb 2016 09:00:00 +0900</pubDate>
        <link>http://realignist.me/code/2016/02/28/pikachus-bizarre-deeplearning.html</link>
        <guid isPermaLink="true">http://realignist.me/code/2016/02/28/pikachus-bizarre-deeplearning.html</guid>
        
        <category>deeplearning</category>
        
        <category>opencv</category>
        
        <category>cuda</category>
        
        <category>caffe</category>
        
        <category>gpgpu</category>
        
        <category>featured</category>
        
        
        <category>Code</category>
        
      </item>
    
      <item>
        <title>2016년의 목표 : “생존하기”</title>
        <description>&lt;p&gt;지난 해를 돌아보고 새해를 준비하는 이런 글은 연말이나 연초에 쓰는게 맞지만 사정이 있어서 1월이 절반이나 지난 지금에야 정리할 수 있게
되었다. &lt;em&gt;(우리가 그토록 이야기하고 있는 병신년은 음력이다보니까 설날부터 시작한다.)&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;병원비가 이 정도면… 여행을 한번 가는데…&lt;/h4&gt;

&lt;p&gt;연말정산때문에 의료비 내역을 조회해보니 2015년 1년간 우울증과 공황장애로 가는 병원과 약국으로 100만원 넘게 썼다. 이 돈이면 일본을 한번 갔다 올 수 있을 정도이고, 내가 듣고 싶은 앨범은 40장 정도는 살 수 있을 것이다. 작년… 스트레스를 받으니까 마음이 무너지고, 마음이 무너지니까 생활에 질서가 없어지고 몸도 같이 망가진다는걸 몸으로 직접 배웠던 것 같다.&lt;/p&gt;

&lt;p&gt;그래서 올해의 목표는 “&lt;strong&gt;생존&lt;/strong&gt;”이라고 결정했다. 건강을 되찾는건 계속 몇년째 이야기했지만, 무언가를 하기 위해선 체력이 필요하다. 그래서 올해는 그 체력을 만들어 살아남아야 할 것 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;step-1------&quot;&gt;Step 1. “큰 바다 위에 있는 통통배” 작전&lt;/h4&gt;

&lt;p&gt;나는 공황장애나 우울장애가 있다보니 한번 스트레스를 받기 시작하면 헤어나올 수가 없다. 정신과 선생님께서는 지금 내가 일을 크게 하고 있지 않는 상태이니까 “큰 바다 위에 떠있는 통통배처럼 최대한 아무것도 하지 말고 있는게 좋을 것 같다.”라는 말을 들었고 작년 년말부터 그렇게 있었던 것
같다.&lt;/p&gt;

&lt;p&gt;특별한 일이 없으면 나가지도 않고, 사람들이 많은 곳은 자연스럽게 피하고, 집에서 은둔형 외톨이처럼 있기도 하고. 그때는 증상이 심했었으니까 이렇게 집 안에서만 지내면서 책만 읽어도 정신적으로는 많이 편해질 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*BNo_kwJ3eqSjP9M72BXzjg.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;바다 위에 있는 한 돛단배&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&quot;step-2---&quot;&gt;Step 2. 생활의 질서를 주입하자.&lt;/h4&gt;

&lt;p&gt;작년 연말에서 올해 연초로 오면서 증상이 정말 눈에 띄게 좋아졌다. 나는 지금 아르바이트거리 외에는 특별히 일을 하고 있지 않다. 학교를 다니거나 회사를 다니거나 하는 것과 같이 생활에 틀이 없으니까 질서도 무너지게 된다.&lt;/p&gt;

&lt;p&gt;밤과 낮이 제대로 존재하지도 않고, 마음 내키는대로 배고프면 밥을 먹고, 졸려서 언제든 자고 싶으면 자는. 이렇게 살면 안되겠다는 생각이 진지하게 들었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*l5WmQKMT93LTJ7MRyJCJCA.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;분명 이 사진은 나에게만 해당되는게 아냐…&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;꼭 초등학생이 방학때 일과 만들듯 “언제부터 언제까진 이거해야지~”라고 정하지는 않지만, 가급적 10시까지는 일어나고 2시에는 자려고 한다. 몇일간 도전해보면서 어떻게하면 좀 괜찮을지 계속 생각하면서 수정해나갈 것 같다.&lt;/p&gt;

&lt;h4 id=&quot;step-3------&quot;&gt;Step 3. 빨피 탈출은 포션이 아니라 운동으로 하자.&lt;/h4&gt;

&lt;p&gt;생활 규칙을 맞추면서 잘 쉬어도 체력을 쌓지 않으면 남들처럼 무언가를 할 수 없다. 즉 생존하기 위한 체력이 부족한 상황이다. 체력에 대한 개념이 있는 게임에서 체력이 조금밖에 남지 않아서 빨갛게 보이는걸 빨피라고 한다. 즉 지금 나는 빨피이다. 게임 세계라면 밥을 먹거나 가만히 있거나 포션을 마시면 되지만 현실에서 게임처럼 포션을 먹으면 죽는다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*p5gAQZpC_kr0BylQIf9SCw.jpeg&quot; alt=&quot;&quot; /&gt;
&lt;span class=&quot;figcaption_hack&quot;&gt;현실의 포션은 오히려 도움이 되질 않는다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;결론은 급할 때 카페인을 찾거나 약을 먹어서 되는게 아니라 &lt;strong&gt;규칙적인 삶에서 규칙적인 운동을 해야한다&lt;/strong&gt;는 것이다. 그리고 사실 이게 제일 어려운 것 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;올해에는 제대로 생존하기 위해 살아보려고 한다. 무엇을 하더라도 체력이 없으면 할 수 없다. 건강하게 탈 없는 한 해가 됬으면 좋겠다.&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Jan 2016 09:00:00 +0900</pubDate>
        <link>http://realignist.me/life/2016/01/19/life-of-2016.html</link>
        <guid isPermaLink="true">http://realignist.me/life/2016/01/19/life-of-2016.html</guid>
        
        <category>mind</category>
        
        <category>psychology</category>
        
        <category>life</category>
        
        
        <category>Life</category>
        
      </item>
    
      <item>
        <title>[독후감] “미움받을 용기”를 읽고서</title>
        <description>&lt;p&gt;글에 앞서서 이상한모임의 &lt;a href=&quot;http://1225.weirdx.io/&quot;&gt;독후감 Advent Calendar&lt;/a&gt; 덕분에 계속 미루던 책 읽기도 하고 읽고 난 후기를 이렇게 글로도 쓸 수 있게 된 것 같아서 감사하다는 마음이 먼저 들고 이런 기회를 만들어주신 이모님과 이상한모임의 다른 분들께 감사하다는 말씀을 먼저 드리고 싶습니다. :)&lt;/p&gt;

&lt;p&gt;이 글은 &lt;strong&gt;&lt;a href=&quot;http://ridibooks.com/v2/Detail?id=2148000002&quot;&gt;월간이모 1월호&lt;/a&gt;&lt;/strong&gt;에서 볼 수 있습니다. 월간이모에서는 chiyodad님이 글을 편집해주셔서, 훨씬 편하게 읽으실 수 있을겁니다. 여러분은 그러니 여기서 읽는 것보다는 월간이모로 보시는게 낫습니다. 그리고 2월호도 지르시는겁니다.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;어떻게 책을 선택했을까?&lt;/h3&gt;
&lt;p&gt;사실 저는 공황장애와 불면증 등으로 정신과 진료를 받고 있고, 정신과나 저와 이야기하시는 주변 분들께서 문학 서적이나 책들을 읽어보는건 어떠냐는 권유를 받게 되었습니다. 반성하자면 그간 제가 어렸을 때부터 책은 많이 읽었지만… 어렸을 때 읽은 책은 과학 책이었고, 컴퓨터에 꽂혀 프로그래밍을 배우기 시작하고서는 컴퓨터 기술 서적만 읽었기 때문에 다른 분야의 책들과 문학 작품들을 접하자는걸 조금 늦게 깨달았습니다. 다만 저는 사람들에게 미움받을 용기가 없었고, 누구나 읽을 수 있는 인문 심리학쪽 책을 찾아보자라는 마음에 이 책을 고르게 되었습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;이 책은 누구에게 궁합이 안 맞을까?&lt;/h3&gt;
&lt;p&gt;이 책을 읽고 나서 저는 이 책이 정말 좋지만 이 책을 읽은 것에 대해 약간 후회하고 있습니다. 현재 제가 병원에서는 “마치 아무런 자극 없이 파도를 타는 바다 위에 떠있는 배”가 되어 아무런 자극을 주지 않고 되도록이면 사람이 많은 곳도 피하고 감정에 대한 생각을 피하는 상태를 만드는게 좋다고 이야기를 들었습니다. 다만 이 책을 읽고서 계속 자신의 상황과 이 책을 비교하며 나는 어떠한 의미를 부여했는가, 내가 지금까지의 인간 관계에서는 어떠했으며… 수많은 생각들을 하게 되었습니다. 그래서 이 책은 정말 좋은 책이지만 &lt;strong&gt;생각이 많으면서도 우울한 사람들&lt;/strong&gt;에겐 오히려 생각에만 빠져 더 우울한 생각을 하게 될 수 있다고 느꼈습니다. 그런 사람들에게는 잠시 이 책을 권장하고 싶지 않습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;어떤 내용이길래 좋다고 생각했을까?&lt;/h3&gt;

&lt;p&gt;그럼에도 불구하고 전 이 책은 (거의 대부분의 사람들에게) 좋다고 느꼈습니다. 우리는 인간이고 사회적인 동물입니다. 사회에서 살면서 수많은 사람들이 서로 관계를 갖고, 그 인간 관계 속에서 우리는 상처를 받고 혹은 상처를 주게 됩니다. 아마 이 책을 찾는 사람들도 다 인간 관계에 대해서 고민을 가지고 있는 사람들(그게 우리 모두일 수도 있습니다.)일거라고 생각합니다.&lt;/p&gt;

&lt;p&gt;이 책의 구조는 철학자와 청년의 이야기로 되어있습니다. 청년이 “세계는 단순하며, 인간은 오늘이라도 당장 행복해질 수 있다”라고 주장하는 철학자를 찾아가서 반박하면서 아들러 심리학에서 주장하는 것들을 배워나가는게 이 책의 내용입니다. 그 대화 속에서 우리는 우리가 사람들과 더불어 어떻게 살아가면 좋은지를 배울 수 있다고 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;“아들러 심리학이란 뭘까?”라는 궁금증&lt;/h3&gt;

&lt;p&gt;이 책이 아들러 심리학, 아들러의 사상을 대화로 풀어낸 것이라고 하지만 이 책을 읽고 나서 아들러 심리학에 더 알아보고 프로이트와 융은 어떠한 심리학을 펼쳤는지 더 궁금해졌습니다. 사실 전 심리학에 대해선 잘 몰랐지만 프로이트와 융은 들어본 적이 있습니다. 아마 아들러를 들어본 사람은 드물어도 프로이트와 융은 한번쯤 들어본 적이 있을 것 같다고 생각합니다.&lt;/p&gt;

&lt;p&gt;항상 우리는 원인이 있으면 결과가 있다라고 생각을 합니다. 프로이트는 트라우마 이론을 주장했다고 합니다. 과거에 입은 마음의 상처가 현재 일어나는 불행의 원인이 된다고 생각을 하는게 그 트라우마 이론이고 실제로 많은 사람들이 당연한 것처럼 생각하는걸 아들러는 부정했습니다. 아들러는 &lt;strong&gt;“경험에 의해 결정되는 것이 아니라, 경험에 부여한 의미에 따라서 자신을 결정하는 것”&lt;/strong&gt;(책의 원문입니다.)이라고 주장했습니다. 즉 불행한 마음은 과거의 경험으로 만들어지는게 아니라 그 경험에 부여한 의미로 인하여 불행해진다는 것입니다. 그 말은 의미를 바꾸면 불행한 것이 행복해질수도 있다는게 됩니다.&lt;/p&gt;

&lt;p&gt;사실 아직도 제 내적으로는 이 이론을 제 상황에 겹쳐서 여러가지 생각을 하고 있습니다. 처음엔 이것에 대해 반신반의했고 부정하기도 했고… 책의 전체를 읽은 지금은 이 이야기가 굉장히 흥미로운 이야기라고 생각합니다. 이 책을 읽고 나서 아들러라는 사람에 대해서, 또 다른 의견이었던 프로이트와 융에 대해서도 관심이 더 가기 시작했습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;부정하다가 뒤집힐 것만 같았던 책에서 공감을 한 부분&lt;/h3&gt;

&lt;p&gt;이 책을 읽으면서 저도 그렇고 수많은 사람들이 청년과 비슷할 것 같다는 생각이 듭니다. 물론 사람마다 다를 수도 있겠지만요. 하지만 인간 관계에 있어서는 꽤 공감한 것 같습니다.&lt;/p&gt;

&lt;p&gt;어떠한 사람을 싫어하게 되면 그 사람이 어떤 행동을 해도 싫고 미울 때가 있습니다. 그럴 때 우리는 아예 정말 싫은 부분만 보게 되고, 좋은 것을 봐도 좋게 보이지 않게 됩니다. 그게 경험에 의해서 결정된게 아니라 부여한 의미에 따라서 달리 보인다는 것입니다.&lt;/p&gt;

&lt;p&gt;또한 아들러는 모든 인간 관계(심지어는 부모 자식과 상사와 부하 직원까지도)에 대해서 평등함을 주장했습니다. 그것을 바탕으로 타인의 과제를 버리라고 합니다. 결국 자신의 과제가 어디까지임을 알고 타인의 과제에 침범하지 않으려고 하는 것에 대해서는 사실 이 책을 읽기 전부터 생각해왔던 부분이라 놀랍기도 했고 공감하기도 했습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;“나는 어떻게 바뀌었는가?”&lt;/h3&gt;

&lt;p&gt;사실 이 책을 읽는다고 해서 하루만에 사람이 변할 수는 없습니다. 물론 이 책이 많은 생각들을 하게 해주고 있습니다만 점점 부정적이던 사고가 긍정적으로 바뀌고 있다는 점에서 굉장히 놀랍고, “인생을 살아가는 의미가 무엇일까?”라는 질문에 대해서 아무한테도 들을 수 없는 대답을 들었습니다.&lt;/p&gt;

&lt;p&gt;아마 제가 여유가 된다면, 또 병원에서 혼나지 않는다면 많은 심리학(주로 아들러의 사상에 대한) 책을 다시 찾지 않을까 생각됩니다. 제가 심리학 전체에 대해서 계속 관심을 두게된 계기가 되었고, 약간 (아직 너무 어리지만) 살면서 느꼈던 고민이 해소된 것 같다고 생각합니다. 두서 없게 글을 못 쓴 것 같아서 죄송하고 또 여기까지 읽어주셔서 감사합니다. 정말 책 맨 뒤에 홍보 문구처럼 100권의 자기계발서보다 이 책이 훨씬 낫고, 처음에는 부정할 수도 있지만 끝까지 읽어보면 생각이 깊어질 수 있지 않을까 생각합니다.&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Dec 2015 09:00:00 +0900</pubDate>
        <link>http://realignist.me/book/2015/12/16/courage-to-be-disliked.html</link>
        <guid isPermaLink="true">http://realignist.me/book/2015/12/16/courage-to-be-disliked.html</guid>
        
        <category>book</category>
        
        <category>mind</category>
        
        <category>psychology</category>
        
        
        <category>Book</category>
        
      </item>
    
      <item>
        <title>[번역] Android 개발을 수주해서 Kotlin을 제대로 써봤더니 최고였다.</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;글에 앞서&lt;/h2&gt;

&lt;p&gt;이 글은 일본의 omochimetaru님이 Qiita에 올린 &lt;a href=&quot;http://qiita.com/omochimetaru/items/98e015b0b694dd97f323&quot;&gt;Android 개발을 수주해서 Kotlin을 제대로 써봤더니 최고였다.&lt;/a&gt;라는 글을 번역해서 만들었습니다. 번역을 흔쾌히 허락해주신 omochimetaru님께 감사하다는 말씀 드립니다. 또한 글에서 한국에서는 쓰이지 않는 표현들 등에 대해서는 의역이 섞여있습니다. 이 점 양해 부탁드립니다. 늦은 시간까지 오역을 찾고 번역의 질을 높이는데 많은 도움을 주시고 오히려 저보다 많이 고생해주신 이상한모임의 pluulove님, chiyodad님, lemonade님께도 감사하다는 말씀 드립니다. 읽어주셔서 감사합니다.&lt;/p&gt;

&lt;h2 id=&quot;kotlin---&quot;&gt;Kotlin을 실무 프로젝트에서 사용했습니다.&lt;/h2&gt;

&lt;p&gt;며칠 전, 제가 소속된 &lt;a href=&quot;http://qoncept.co.jp/&quot;&gt;Qoncept&lt;/a&gt;에서 &lt;a href=&quot;http://www.real-toso.jp/&quot;&gt;“리얼 술래잡기”x후지큐 하이랜드 거대 유원지에서부터의 도주&lt;/a&gt;를 개발했고 출시했습니다.&lt;/p&gt;

&lt;p&gt;후지큐 하이랜드에서 실제 술래잡기를 하는데, 일반 손님들이 스마트폰으로 전용 애플리케이션을 사용하며 클리어하는 것을 목표로 하는 기획이었습니다. 유원지에는 도깨비 역할의 스태프와 게임 진행에 관련된 시설이 있습니다. 그것들과 스마트폰이 iBeacon(Bluetooth LE)을 사용하여 연동하며 데미지를 입는거나, 아이템을 쓰거나, 퀴즈를 푸는 것 등을 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;Qoncept의 개발 범위는 iOS 앱(과 애플워치용 앱), 안드로이드 앱, 서버사이드였습니다.&lt;/p&gt;

&lt;p&gt;수주가 확정된 시점에서 남은 개발 기간과 개발자 인원에 비해 전체 개발 범위가 꽤 컸기 때문에 어떻게하면 기간 내에 맞출 수 있을까 검토하였습니다. 그 당시에는 iOS는 Swift를 이용해서 Objective-C보다 쾌적한 개발이 가능해졌었지만 Android에서의 Java를 이용한 개발에는 부담감을 가지고 있었습니다. 그래서 생각해낸 것이 Kotlin이었습니다. 이전부터 이따금씩 들었던지라 어쩐지 좋은 언어 같다는 인식이 있었습니다. Kotlin을 쓰려면 지금이 적기라고 생각하며 공식 사이트의 문서를 단숨에 읽어보았습니다. 이거라면 할 수 있겠다고 판단해서, &lt;strong&gt;iOS 앱은 Swift로 개발하고 동시에 Android에는 Kotlin으로 이식하여 구현하는 것&lt;/strong&gt;을 방침으로 삼았습니다.&lt;/p&gt;

&lt;p&gt;최종적으로는 스케쥴에도 정확히 맞출 수 있었고, 앱도 안정적이었습니다. 게다가 &lt;a href=&quot;https://twitter.com/real_toso&quot;&gt;손님들로부터의 평가&lt;/a&gt;도 좋았기 때문에 행복하게 마무리 되었다 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;kotlin--&quot;&gt;Kotlin 진짜 최고&lt;/h3&gt;

&lt;p&gt;서문이 길어졌지만, 앞서 이야기했던 것과 같이 Kotlin으로 제대로 개발해봤더니 Kotlin이 최고라는 것을 만끽할 수 있었습니다. (iOS 앱은 다른 분이 개발하셨고, Android 앱으로의 이식은 제가 담당했습니다.)
이런 마음이 더욱 부풀어 올라서, Kotlin 개발자가 늘어나 널리 보급되어 앞으로도 Kotlin이 진화하고 보완될 수 있으면 좋겠다는 생각으로 Kotlin을 전파하기 위해 이번 글을 쓰게 되었습니다.&lt;/p&gt;

&lt;p&gt;아래에서는 Kotlin을 주로 Android 개발에, Swift로부터의 이식, 실무에서의 사용을 중점적으로 해서 소개하고자 합니다.&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;버전&lt;/h4&gt;

&lt;p&gt;실제 프로젝트 당시에는 M11 버전으로 구현했습니다.
글을 쓴 시점에서 M14 버전이 나왔으며, 알아차린 범위 내에서 M14 버전에 맞는 내용으로 글을 쓰고 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;언어 주변 환경&lt;/h2&gt;

&lt;p&gt;언어의 사양을 보기 전에 우선, Kotlin이라는 언어의 주변 환경에 대해 먼저 써보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;후원하는 기업은 어떤 기업인가?&lt;/h3&gt;

&lt;p&gt;취미로 개발하는 것과는 달리 실무 개발의 경우 유명하지 않은 언어는 개발이 중단되거나 나중에 언어가 없어지는 위험 부담이 있습니다. 이 점에서 Kotlin은 대중적으로 인지도는 떨어지지만 오픈 소스로 만들어지고 있기 때문에, 갑자기 컴파일러 같은 것들을 받을 수 없게 되는 일은 없을 것으로 여겨집니다.&lt;/p&gt;

&lt;p&gt;또한, 개발을 주도하고 있는 업체는 Jetbrains입니다. Jetbrains는 IntelliJ IDEA라고 하는 IDE를 개발하고 판매하는 회사로 유명합니다. Java IDE를 개발하고 있는 수준이기 때문에, 컴파일러와 관련된 기술력이나 프로그래밍 언어에 대한 이해는 상당할 것이라고 생각합니다. Android의 개발 환경이 Eclipse + ADT에서 Android Studio로 전환된지 오래지만, 이 Android Studio는 IntelliJ를 Android 개발을 위하여 고친 버전입니다. 구글이 이렇게 개발 환경을 변경한 것도, Jetbrains에 대한 신뢰를 높이는데 일조하고 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;도입이 간단하다.&lt;/h3&gt;

&lt;p&gt;새로운 언어를 도입하고자 할 때는 개발 환경 구축에 문제가 생겨 시간이 오래 걸리고, 제대로 된 개발 환경이 갖춰져 있지 않을 때 오히려 언어 자체의 개발 생산성을 개발 환경이 상쇄할 수 있는 우려가 있습니다.&lt;/p&gt;

&lt;p&gt;Kotlin은 이 부분이 재미있습니다. 우선 IDE에 연동하기 위한 IntelliJ(Android Studio)용 플러그인을 Jetbrains에서 제공하고 있습니다. 같은 회사에서 IDE와 언어를 만들기 떄문에 각종 지원이 확실합니다. Swift + XCode에서는 할 수 없는 Refactor rename 등의 기능도 기본적으로 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;플러그인은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio &amp;gt; Preferences &amp;gt; Plugins &amp;gt; Install Jetbrains Plugin &amp;gt; Kotlin&lt;/code&gt;에서 설치할 수 있습니다. 새로운 버전의 플러그인이 나왔을 때는 Android Studio가 알려주기 때문에 간단하게 업데이트할 수 있습니다.&lt;/p&gt;

&lt;p&gt;프로젝트 빌드에 도입하는 것 또한 간단합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio &amp;gt; Tools &amp;gt; Kotlin &amp;gt; Configure Kotlin in Project&lt;/code&gt;를 클릭하면 다이얼로그가 나와서, OK 버튼을 누르면 자동으로 설치합니다. 그러면 애플리케이션 모듈의 gradle 파일이 아래처럼 바뀝니다.&lt;/p&gt;

&lt;h5 id=&quot;kotlin---1&quot;&gt;Kotlin 도입 전&lt;/h5&gt;

&lt;pre class=&quot; language-groovyp &quot;&gt;&lt;code&gt;apply plugin: &#39;com.android.application&#39;

android {
    compileSdkVersion 22
    buildToolsVersion &quot;22.0.1&quot;

    defaultConfig {
        applicationId &quot;jp.co.qoncept.apptest&quot;
        minSdkVersion 18
        targetSdkVersion 22
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile &#39;com.android.support:appcompat-v7:22.2.0&#39;
}&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;kotlin---2&quot;&gt;Kotlin 도입 후&lt;/h5&gt;

&lt;pre class=&quot; language-groovy &quot;&gt;&lt;code&gt;apply plugin: &#39;com.android.application&#39;
apply plugin: &#39;kotlin-android&#39;

android {
    compileSdkVersion 22
    buildToolsVersion &quot;22.0.1&quot;

    defaultConfig {
        applicationId &quot;jp.co.qoncept.apptest&quot;
        minSdkVersion 18
        targetSdkVersion 22
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
    sourceSets {
        main.java.srcDirs += &#39;src/main/kotlin&#39;
    }
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    compile &#39;com.android.support:appcompat-v7:22.2.0&#39;
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
}

buildscript {
    ext.kotlin_version = &#39;0.13.1514&#39;
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
repositories {
    mavenCentral()
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;나머지는 빌드해주면, Gradle 스크립트가 Kotlin 컴파일러의 다운로드부터 환경 설정까지 자동으로 전부 알아서 해줍니다. 새로운 버전의 Kotlin이 나왔다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ext.kotlin_version&lt;/code&gt; 부분을 고쳐주면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;java---&quot;&gt;Java와의 연계 기능이 강력하다.&lt;/h3&gt;

&lt;p&gt;개발 언어를 변경하는 경우 지금까지 써오던 언어와의 동시 사용이 어렵거나, 원활하지 않을 경우 기존 프로젝트에 추가로 도입할 수도 없으며 과거의 코드 리소스가 낭비되고, 만에 하나 문제가 발생하는 경우를 피할 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그 점에서 볼 때 Kotlin은 Java와의 연계 능력이 정말로 강력합니다. Scala나 Groovy와 마찬가지로 Java 바이트코드로 컴파일되어서, JVM 위에서 구동될 수 있습니다.&lt;/p&gt;

&lt;p&gt;언어 사양에서 우선 Java와의 연계가 중요시되고 있으며, 기존 Java 기반 프로젝트에 Kotlin 소스를 섞어서 사용할 수 있도록 되어있습니다. 또, Kotlin에서 자연스럽게 Java의 클래스나 메소드를 호출할 수 있습니다. 공식 사이트에서도 &lt;a href=&quot;http://kotlinlang.org/&quot;&gt;100% interoperable with Java&lt;/a&gt;라고 나와있습니다. Kotlin을 잘 쓰지 못하더라도, 그 부분만 기존 Java 소스 코드로 쓰는 것 또한 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;언어 소개&lt;/h2&gt;

&lt;h3 id=&quot;section-6&quot;&gt;타입 추론을 지원하는 정적 타이핑&lt;/h3&gt;

&lt;p&gt;Kotlin은 타입 추론을 지원하는 정적 타이핑 언어입니다. Swift도 그렇지만, Java하고는 다릅니다. 타입 추론은 기본이죠.&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;외형&lt;/h3&gt;

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun main(args: Array&lt;string&gt;) {
    println(&quot;Hello, world!&quot;)
}

세미콜론 없는 스타일, 코드 블록은 중괄호로 여닫는 스타일, 형태 표기는 Pascal 스타일(변수, 콜론, 자료형의 순서)을 볼 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;var sum = 0

listOf(1,2,3).filter { it &amp;gt; 0 }.forEach {
  sum += it
}

print(sum)&lt;/code&gt;&lt;/pre&gt;

클로져의 경우 중괄호`{}`만 쓰기 때문에 마지막 인자의 클로져를 함수 호출 뒤에 쓰고, 그 때 인자가 없으면 소괄호`()`를 생략할 수 있습니다.

이쪽의 구문 사양이 Swift와 동일하기 때문에, 이식 작업이 편해집니다.

### Optional (Nullable)

자료형으로 null을 참조할 수 있는 자료형과 없는 자료형이 구분됩니다. 타입을 검사하고 내용이 null인지 아닌지를 확인하면 그 시점에서 내용의 자료형으로 형변환됩니다. 일반적으로 이런 기능들을 제공할 떄 Optional이라고 하는데 Kotlin에서는 이 기능을 Nullable이라고 합니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun getLengthOfString(str: String): Int {
    return str.length()
}

fun getLengthOfStringOpt(str: String?): Int {
    if (str != null) {
        return getLengthOfString(str)
    } else {
        return 0
    }
}

fun main(args: Array&lt;string&gt;) {
    val a = getLengthOfString(&quot;hello&quot;)
    val b = getLengthOfStringOpt(&quot;world&quot;)
    val c = getLengthOfStringOpt(null)
    println(&quot;$a, $b, $c&quot;)
}

Nullable 자료형은 자료형의 오른쪽에 물음표`?`를 붙여 표기합니다. Swift의 Optional과 같아서 기쁩니다. Java의 언어 기능에 Optional은 존재하지 않습니다. 아마 NullPointerException으로 죽겠죠.

#### 약간 특이한 부분

Nullable의 Nullable을 만들 수가 없습니다. 그냥 Nullable이 되어버립니다.
Swift에서 Optional의 Optional이 나올 때 어떻게 이식할지 고민하게 됩니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun wrap(a: Int?): Int?? {
    return a
}

fun desc(a: Int??) {
    if (a == null) {
        println(&quot;None&quot;)
    } else {
        if (a == null) {
            println(&quot;Some(None)&quot;)
        } else {
            println(&quot;Some(Some($a))&quot;)
        }
    }
}

fun main(args: Array&lt;string&gt;) {
    val a: Int?? = wrap(null)
    desc(a) // Some(None)이 나와야하지만, None이 되어버린다.
}

### 플로우 기반 형변환 (Smart Casts)

if 문에서 null인지를 체크하거나, is 연산자를 통해 타입을 검사하면 Kotlin에서는 그것을 고려해서 자동으로 형변환됩니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;open class Animal {}
class Cat: Animal() {
    fun nyaa() { println(&quot;nyaa&quot;) }
}
class Dog: Animal() {
    fun wan() { println(&quot;wan&quot;) }
}

fun speak(animal: Animal) {
    if (animal is Cat) { animal.nyaa() }
    if (animal is Dog) { animal.wan() }
}
fun speak2(animal: Animal?) {
    if (animal == null) {
        println(&quot;null&quot;)
        return
    }
    speak(animal)
}

fun main(args: Array&lt;string&gt;) {
    speak2(Cat()) // nyaa라고 나옴
    speak2(Dog()) // wan이라고 나옴
    speak2(null) // null이라고 나옴
}

speak2의 앞 부분에서 null 인지를 체크하고 return 하고 있으므로 if 이후 `Animal?`이 아니라 `Animal` 자료형으로 변했으며, speak가 호출될 수 있습니다. speak의 if문의 분기에서 is를 이용한 체크를 통해 서브클래스인 `Cat`이나 `Dog`로 변해있으며 전용 메소드를 호출할 수 있습니다.

동일한 코드에 대한 Swift 버전은 아래와 같습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class Animal {}
class Cat: Animal {
    func nyaa() { print(&quot;nyaa&quot;) }
}
class Dog: Animal {
    func wan() { print(&quot;wan&quot;) }
}

func speak(animal: Animal) {
    if let animal = animal as? Cat { animal.nyaa() }
    if let animal = animal as? Dog { animal.wan() }
}
func speak2(animal: Animal?) {
    guard let animal = animal else {
        print(&quot;null&quot;)
        return
    }
    speak(animal)
}

func main() {
    speak2(Cat())
    speak2(Dog())
    speak2(nil)
}

main()&lt;/code&gt;&lt;/pre&gt;

speak2에서는 이를 위해 일부러 guard 문이라는 것을 사용하지 않으면 안됩니다. speak, speak2 둘 다 `let animal = `을 쓰는 것이 중복됩니다. if 괄호를 생략할 수 있는 것은 좋네요.

Java에서는 아마 아래와 같이 되겠죠.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;import java.util.*;
import java.lang.*;
import java.io.*;

class Animal {}
class Cat extends Animal {
    void nyaa() { Ideone.print(&quot;nyaa&quot;); }
}
class Dog extends Animal {
    void wan() { Ideone.print(&quot;wan&quot;); }
}

class Ideone {
    public static void print(String str) { System.out.println(str); }

    static void speak(Animal animal) {
        if (animal instanceof Cat){
            Cat cat = (Cat)animal;
            cat.nyaa();
        }
        if (animal instanceof Dog) {
            Dog dog = (Dog)animal;
            dog.wan();
        }
    }
    static void speak2(Animal animal) {
        if (animal == null) {
            print(&quot;null&quot;);
            return;
        }
        speak(animal);
    }

    public static void main (String[] args) throws java.lang.Exception {
        speak2(new Cat());
        speak2(new Dog());
        speak2(null);
    }
}&lt;/code&gt;&lt;/pre&gt;

null 체크에 관련해서는 그저 코드가 올바르길 기도하고 실행하는 수밖에 없습니다. 그리고 speak의 내용은 `Cat`과 `Dog`가 각각 세 번씩 나옵니다. (형변환용 메소드를 만든다면 2번 + null 체크로 줄일 수는 있겠지만요.)

### Unsafe cast

Nullable이 null일 땐 충돌이 나는 내용의 추출과 타입이 다를 경우에는 충돌하는 형변환이 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hoge(a: Int?, b: Animal?) {
    val c: Int = a!! // null이라면 Exception
    val d: Cat? = b as? Cat // Cat이 아니라면 null
    val e: Cat = b as Cat // Cat이 아니라면 Exception
}&lt;/code&gt;&lt;/pre&gt;

Swift에서는 아래와 같이 작성할 수 있겠죠.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;func hoge(a: Int?, b: Animal?) {
    let c: Int = a! // nil이라면 Exception
    let d: Cat? = b as? Cat // Cat이 아니라면 nil
    let e: Cat = b as! Cat // Cat이 아니라면 Exception
}&lt;/code&gt;&lt;/pre&gt;

Kotlin에서는 두개의 느낌표`!`로 처리합니다. Swift에서는 한개죠.
위험한 as에서는 Swift에서는 느낌표가 붙어있습니다.

### Optional의 메소드 호출

Kotlin에서는 Optional로 둘러쌓인 값의 메소드를 호출할 때, 값이 있다면 메소드를 호출할 수 있고 null일 경우에는 null값이 필요할 때, if문에서의 타입 체크를 하지 않고도 다음과 같이 작성할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hoge(user: User?) {
    val name: String? = user?.name
    println(&quot;name=$name&quot;)
}&lt;/code&gt;&lt;/pre&gt;

Elvis 연산자를 사용하면 null인 경우 기본값을 지정할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hoge(user: User?) {
    val name: String = user?.name ?: &quot;no name&quot;
    println(&quot;name=$name&quot;)
}&lt;/code&gt;&lt;/pre&gt;

Swift에서도 물음표 + 점`?.`으로 쓰이는 메소드 호출이 있습니다. 또한 elvis 연산자에 대해서는 Swift에서는 물음표 두개`??`입니다.
비슷해보이는 두 언어지만, 물음표 + 점`?.`을 연속해서 사용할 때에는 구문 트리가 달라집니다.
사용자 이름의 문자 수를 가져오는 경우를 생각해보세요.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class User {
    var name: String = &quot;tanaka&quot;
}

fun hoge(user: User?) {
    println(user?.name?.length())
}&lt;/code&gt;&lt;/pre&gt;

Kotlin에서는 `?.`가 두번 나옵니다. 이것은 다음과 같이 해석할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;( user?.name )?.length()&lt;/code&gt;&lt;/pre&gt;

`?.`을 쓰지 않는 경우에는 아래와 같이 쓸 수 있겠습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;val name: String? = if (user != null) { user.name } else { null }
val length: Int? = if (name != null) { name.length } else { null }&lt;/code&gt;&lt;/pre&gt;

마찬가지를 Swift에서는 아래와 같이 표현할 수 있습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class User {
    var name: String = &quot;tanaka&quot;
}

func hoge(user: User?) {
    print(user?.name.characters.count)
}

main()&lt;/code&gt;&lt;/pre&gt;

name 뒤에 `?.`가 Swift에서는 `.`로 나와있습니다. 이것은 아래와 같이 해석되기 때문입니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;user?.( name.characters.count )&lt;/code&gt;&lt;/pre&gt;

하지만, 이 괄호는 개념을 설명하기 위해서 임의로 만든 것이며 Swift로는 올바른 문법이 아닙니다. 고쳐서 쓴다면 아래와 같습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;if let user = user {
    return user.name.characters.count
} else {
    return nil
}&lt;/code&gt;&lt;/pre&gt;

정리하면 다음과 같습니다. Kotlin의 경우 `?.`을 다음 번만의 키워드만 처리하고 그 결과를 다음에도 사용합니다. Swift의 경우에는 `?.`을 오른쪽 모두를 묶어버리며 None일 경우 오른쪽 모두를 스킵합니다. 이 차이는 똑같은 외형의 코드가 전혀 다른 의미를 가지게 된다는 뜻이므로 이식하는데는 주의할 필요가 있습니다.

개인적으로는 Kotlin의 사양이 더 직관적이고 좋았습니다. 처음 Swift로 개발했을 때 Kotlin의 사양을 상상하고 작업하다가 에러가 나서 당황했던 적이 있었습니다.

Java의 경우에는 첫 번째 인자로 리시버를 두 번째 인자로 오퍼레이터를 갖는 콜백 함수를 만들고 `?.` 동작을 에뮬레이트하는 것이 좋겠죠. if문을 쓰면 리시버의 식을 두 번 쓰지 않으면 안되기 때문입니다.

### 메소드 호출은 아니지만, Optional에 체인 가능한 것들

위에서 쓴 `?.`을 사용하면 Optional이어도 귀찮지 않게 코드를 짤 수 있습니다만 아래와 같이 `?.`로는 쓸 수 없지만 null이 아닌 경우 처리를 계속하고 싶은 케이스가 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;val result: Boolean

if (user != null) {
    result = write(user)
} else {
    result = false
}&lt;/code&gt;&lt;/pre&gt;

이런 케이스에서는 Kotlin에서는 다음과 같이 쓰는 것이 가능합니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;val result: Boolean = user?.let { write(it) } ?: false&lt;/code&gt;&lt;/pre&gt;

let의 정의와 구현은 다음과 같이 되어있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)&lt;/code&gt;&lt;/pre&gt;

이것은 모든 타입 T에서 정의된 확장 메소드로 인자로 클로져를 하나 가지고 있습니다. 그리고 그 클로져에 메소드의 리시버가 전달되어 불러질 것이고 그 자체가 let 자체의 값이 됩니다.

위의 예시에는 `?.`가 있으므로 let이 실행되는 것은 `User?`가 null이 아닌 경우입니다. it은 클로져의 암시적인 인자이므로 it은 `User`가 되는 것입니다. 그리고 write의 반환 값은 let의 반환 값이므로 기대했던대로 동작할 것입니다.

Swift의 경우에는 Optional 자체에 정의된 `flatMap` 메소드를 쓸 수 있습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;let result: Bool = user.flatMap { write($0) } ?? false&lt;/code&gt;&lt;/pre&gt;

이 경우에는 Optional 자체의 메소드임에도 불구하고 `?.`가 아닌 `.`이 됩니다.

### 기본적인 콜백 함수

기본적인 콜백 함수가 쓸 수 있습니다. 클로져가 `{}`로 표현되기 때문에 쉽게 쓸 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun main(args: Array&lt;string&gt;) {
    val a = (0..10)
        .filter { it % 2 == 0 }
        .map { it * it }
        .fold(&quot;&quot;) { s, i -&amp;gt; 
            (if (s != &quot;&quot;) s + &quot;_&quot;  else &quot;&quot;) + i.toString()
        }

    println(a) // 0_4_16_36_64_100가 나온다.
}

Swift도 비슷한 느낌으로 작성할 수 있습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;let a = (0...10)
    .filter { $0 % 2 == 0 }
    .map { $0 * $0 }
    .reduce(&quot;&quot;) {
        let s = $0 != &quot;&quot; ? $0 + &quot;_&quot; : &quot;&quot;
        return s + String($1)
    }

print(a) // 0_4_16_36_64_100가 나온다.&lt;/code&gt;&lt;/pre&gt;

Java라면 이렇게 나오겠죠.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;String a = IntStream.rangeClosed(0, 10)
    .mapToObj(i -&amp;gt; Integer.valueOf(i))
    .filter(i -&amp;gt; i % 2 == 0)
    .map(i -&amp;gt; i * i)
    .reduce(&quot;&quot;, (s, i) -&amp;gt; 
        (!s.equals(&quot;&quot;) ? s + &quot;_&quot; : &quot;&quot;) + i
    , (s1, s2) -&amp;gt; s1 + s2);

print(a);&lt;/code&gt;&lt;/pre&gt;

Kotlin은 Swift의 클로져 리터럴과 함수를 호출할 때의 표기법이 비슷합니다. Swift 버전의 reduce의 내부는 한 줄로 쓰고 싶었습니다만 타입 추론에 타임아웃이 걸려서 컴파일하지 못했기 때문에 let으로 나눴습니다. Kotlin에서는 클로져의 암시적 인자는 인자가 1개일 때만 `it`을 쓸 수 있습니다. 복수일 때는 인자명이 필요합니다. Swift에서는 `$0`, `$1`, `$2`... 이런 식으로 쓰입니다. 또 Kotlin에서는 삼항연산자가 없지만 if문을 이용해서 쓸 수 있습니다.

### 문자열 안에서의 변수 접근

Kotlin에서는 문자열 안에서 `$`로 변수를, `${}`로 식을 호출할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hoge(i: Int, user: User) {
    println(&quot;i is $i, user name is ${user.name}&quot;)
}&lt;/code&gt;&lt;/pre&gt;

`$i` 부분이 변수가, `${user.name}` 부분이 식을 표시합니다. Swift에서는 `\()`로 쓸 수 있죠.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;func hoge(i: Int, user: User) {
    print(&quot;i is \(i), user name is \(user.name)&quot;)
}&lt;/code&gt;&lt;/pre&gt;

Java에서는 이런 기능에 대한 문법이 없으니 아래와 같이 되겠죠.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;void hoge(int i, User user) {
    print(&quot;i is &quot; + i + &quot;, user name is &quot; + user.name);
}

void hoge2(int i, User user) {
    printf(&quot;i is %d, user name is %s&quot;, i, user.name);
}&lt;/code&gt;&lt;/pre&gt;

### Java의 단일 추상 메소드(SAM) 변환

Java에서는 Java8이 나오면서 람다식과 단일 추상 메소드를 가지는 함수형 인터페이스라는 큰 기능이 추가되었습니다. 이것은 단일 메소드를 가지고 있는 인터페이스에서 람다식을 쓸 수 있게 됬다는 것을 의미합니다.

예를 들면, 아래가 Java7의 코드입니다. 안드로이드에서 자주 볼 수 있는 버튼의 클릭 핸들러를 설정하는 코드입니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;button.setOnClickListener(new View.OnClickListener {
    @Override
    void onClick(View view) {
        println(&quot;clicked&quot;);
    }
});&lt;/code&gt;&lt;/pre&gt;

이게 Java8이라면 다음과 같이 표현할 수 있게 됩니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;button.setOnClickListener(view -&amp;gt; {
    println(&quot;clicked&quot;);
});&lt;/code&gt;&lt;/pre&gt;

이는 Java8에서 람다식을 도입함에 있어 Java7 이전에 있었던 코드의 낭비하거나 수정하지 않고도 람다식을 이용해 보다 쾌적하게 쓸 수 있게 되었습니다.

이렇게 람다식으로 자동 변환될 수 있는 인터페이스는 단일 메소드여야만 합니다.
그래서 이것을 단일 추상 메소드(Single Abstract Method), 줄여서 SAM이라고 칭하며 이 변환을 SAM 변환이라고 합니다.

Kotlin에서는 Java8과 마찬가지로 이 기능을 탑재하고 있습니다. 이 기능은 Java와 연계해서 Java 라이브러리를 사용하는데 없으면 안되는 중요한 기능 중 하나입니다.

##### 역주

&#39;SAM 변환&#39;이라는 말이 낯설게 느껴질 수 있는데, 이는 한국에서 잘 쓰이지 않기 때문입니다. 위에서 설명한 단일 추상 메소드를 가지고 있는 인터페이스에 대해 람다식을 쓸 수 있는 기능은 Java8의 중요한 신기능입니다. Kotlin에서는 이 기능을 Java8 이전인 Java6, 7에서도 쓸 수 있습니다. 이는 Android가 아직 Java8을 공식적으로 지원하지 않기 때문에 Kotlin이 주목을 받는 이유 중 하나이기도 합니다. Android를 Java로 개발할 때에는 대안으로 RetroLambda라고 하는, 컴파일 시 바이트코드를 수정해서 쓸 수 있게 하는 라이브러리가 존재합니다.

위에 예시는 Kotlin에서는 아래와 같이 쓸 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;button.setOnClickListener { view -&amp;gt;
    println(&quot;clicked&quot;)
}&lt;/code&gt;&lt;/pre&gt;

쓰기 쉬워 좋네요. 위의 예에서는 인수가 클로져 한개일 뿐이라 함수 호출 괄호`()`를 생략했습니다.

### 확장 메소드

Kotlin에서는 기존 클래스에 대해 메소드를 추가해 확장하는 것이 가능합니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun Int.square(): Int = this * this
fun &lt;t&gt; List&lt;t&gt;.evens(): List&lt;t&gt; = withIndex().filter { it.index % 2 == 0 }.map { it.value }
fun List&lt;int&gt;.squareEvens(): List&lt;int&gt; = evens().map { it.square() }

fun main(args: Array&lt;string&gt;) {
    val a = 3
    println(a.square()) // 9라고 출력

    val b = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)
    println(b.evens()) // [a, c, e]라고 출력

    val c = listOf(10, 20, 30, 40, 50)
    println(c.squareEvens()) // [100, 900, 2500]라고 출력
}

제너릭 자료형의 확장 메소드에 관해서는 T 모두에 대한 것과 특정 T에 대한 정의가 가능합니다. 함수의 본문은 `=` 스타일로 써봤습니다.

Swift에서는 다음과 같이 쓸 수 있겠습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;extension IntegerType {
    func square()-&amp;gt; Self {
        return self * self
    }
}
extension Array {
    func evens()-&amp;gt; Array&lt;element&gt; {
        return enumerate().filter { $0.index % 2 == 0 }.map { $0.element }
    }
}
extension Array where Element: IntegerType {
    func squareEvens()-&amp;gt; Array&lt;element&gt; {
        return evens().map { $0.square() }
    }
}

func main() {
    let a = 3
    print(a.square()) // 9라고 출력

    let b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
    print(b.evens()) // [&quot;a&quot;, &quot;c&quot;, &quot;e&quot;]라고 출력

    let c = [10, 20, 30, 40, 50]
    print(c.squareEvens()) // [100, 900, 2500]라고 출력
}

main()

Element에 대한 제약은 프로토콜에 필요가 있으므로 `Int`로 쓸 수 없어서 그 대신 `IntegerType`으로 되어있습니다. 이유를 잘 모르겠습니다.

Kotlin도 Swift도 둘 다 프로퍼티를 추가하는 것이 가능합니다. 이식했을 때는 `withIndex`와 `enumerate`가 대응되어서 기뻤습니다.

Java에는 확장 메소드라는 개념이 없기 때문에 첫 번째 인수에 this를 가지는 정적 메소드로 구현해야되겠죠.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;public class Main {
    public static void print(String str) {
        System.out.println(str);
    }

    public static int intSquare(int x) { return x * x; }

    public static &lt;t&gt; List&lt;t&gt; listEvens(List&lt;t&gt; list) {
        return IntStream.range(0, list.size())
            .filter(i -&amp;gt; i % 2 == 0)
            .mapToObj(i -&amp;gt; list.get(i))
            .collect(Collectors.toList());
    }

    public static List&lt;integer&gt; intListSquareEvens(List&lt;integer&gt; list) {
        return listEvens(list).stream()
            .map(i -&amp;gt; intSquare(i))
            .collect(Collectors.toList());
    }

    public static void main (String[] args) throws java.lang.Exception {
        int a = 3;
        print(&quot;&quot; + intSquare(a)); // 9라고 출력

        List&lt;string&gt; b = listEvens(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;));
        print(&quot;&quot; + b); // [a, c, e]라고 출력

        List&lt;integer&gt; c = intListSquareEvens(Arrays.asList(10, 20, 30, 40, 50));
        print(&quot;&quot; + c); // [100, 900, 2500]라고 출력
    }
}

이 방식이 괴로운 것은 충돌을 피하고자 메소드 이름에 접두사가 필요하다는 점과 호출할 때 `f(g(h(x)))`라는 형식이 되므로 나중에 적용하는 함수일수록 앞에 오는 등의 문제가 있습니다. 특히 이식을 할 때에는 원래 메소드 체인의 형태로 되어있다면 기술 순서가 완전히 거꾸로 되어버리기 때문에 매우 번거로운 작업이 됩니다. 개인적으로는 이 부분이 가독성도 떨어트린다고 생각합니다.

또, 이 코드는 `withIndex`에 대응하는 방법을 몰랐기 때문에 얼버무려 쓴 코드입니다.

### 오퍼레이터 오버로드

Kotlin에서는 오퍼레이터 오버로드라는 기능이 존재합니다. 하지만 직접 메소드 이름에 연산자를 표기하는 Swift와 C++과는 달리 Kotlin에서는 미리 정해진 연산자에 해당하는 이름의 메소드를 operator 키워드와 함께 구현합니다. 스스로 연산자를 추가할 수는 없지만 인수가 하나인 메소드를 삽입할 수 있는 기능이 있으므로 키워드로 연산자를 추가하는 것은 할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;data class Vector2(val x: Double, val y: Double) {
    operator fun plus(o: Vector2): Vector2 = Vector2(x + o.x, y + o.y)
    fun dot(o: Vector2): Double = x * o.x + y * o.y
    override fun toString(): String = &quot;($x, $y)&quot;
}

operator fun Double.times(o: Vector2): Vector2 = Vector2(this * o.x, this * o.y)

fun main(args: Array&lt;string&gt;) {
    val a = Vector2(1.0, 2.0) + Vector2(3.0, 4.0)
    println(a) // (4.0, 6.0)라고 출력

    val b = 3.0 * Vector2(0.0, 1.0)
    println(b) // (0.0, 3.0)라고 출력

    val c = Vector2(2.0, 0.0) dot Vector2(2.0, 3.0)
    println(c) // 4.0라고 출력
}

덧셈은 메소드로 곱셈은 Double 자료형의 확장 메소드로 썼습니다. `dot`은 보통의 방법입니다만 중간에 저렇게 사용할 수 있습니다.
데이터 클래스와 기본 생성자의 기능도 쓰고 있습니다.

Swift로도 써봤습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class Vector2: CustomStringConvertible {
    let x: Double
    let y: Double
    init(_ x: Double, _ y: Double) {
        self.x = x
        self.y = y
    }
    var description: String {
        return &quot;(\(x), \(y))&quot;
    }
}

func +(l: Vector2, r: Vector2)-&amp;gt; Vector2 {
    return Vector2(l.x + r.x, l.y + r.y)
}
func *(l: Double, r: Vector2)-&amp;gt; Vector2 {
    return Vector2(l * r.x, l * r.y)
}

infix operator ● { 
    associativity left
    precedence 140 
}

func ●(l: Vector2, r: Vector2)-&amp;gt; Double {
    return l.x * r.x + l.y * r.y
}

func main() {
    let a = Vector2(1.0, 2.0) + Vector2(3.0, 4.0)
    print(a) // (4.0, 6.0)라고 출력

    let b = 3.0 * Vector2(0.0, 1.0)
    print(b) // (0.0, 3.0)라고 출력

    let c = Vector2(2.0, 0.0) ● Vector2(2.0, 3.0)
    print(c) // 4.0라고 출력
}

main()&lt;/code&gt;&lt;/pre&gt;

●은 유니코드 문자입니다. 이번 예시에서는 Swift의 기능을 이용해 이 마크를 연산자로 정의했습니다.

Kotlin은 연산자를 만드는 것은 불가능하기 때문에 Swift에서 정의된 독자 연산자의 이식은 메소드로 합니다.
하지만, 연산자 우선 순위까지 이식할 수 없기 때문에 소괄호`()`를 붙여 나갈 필요가 있겠죠.

Java에서는 이런 기능을 쓸 수 없기 때문에 확장 메소드와 마찬가지로 이식할 때 매우 불편합니다.

### 프로퍼티

Kotlin의 필드같은 것들은 모두 프로퍼티입니다.
상수는 val, 변수는 var로 정의하며, val에는 getter를, var에는 getter와 setter를 정의할 수 있습니다.
getter와 setter를 구현하기 위한 지원 필드가 자동으로 정의되며 field라고 하는 키워드로 액세스할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class User {
    val id: Int
    var familyName: String = &quot;야마다&quot;
    var firstName: String = &quot;타로&quot;

    val fullName: String
        get() = &quot;$familyName $firstName&quot;
    var died: Boolean = false
        get() { return field }
        set(value) {
            field = value
            if (value) {
                println(&quot;${fullName}는 죽어버렸다...&quot;)
            }
        }
    constructor(id: Int) {
        this.id = id
    }
}
fun main(args: Array&lt;string&gt;) {
    val u = User(3)
    u.familyName = &quot;사이토&quot;
    u.died = true // 사이토 타로는 죽어버렸다... 라고 표시됩니다.
}

위의 예에서 `id`는 상수이기 때문에 getter가 자동 생성되었고, `familyName`, `firstName`은 변수이기 때문에 getter와 setter가 자동으로 생성된 것을 볼 수 있습니다.
`fullName`은 getter를 직접 만들어서 다른 프로퍼티로부터 동적으로 가져올 수 있도록 했습니다. `died`는 getter와 setter를 직접 만들어서 지원 필드를 사용했습니다.

Swift에서도 필드와 같은 것은 프로퍼티입니다. getter, setter 뿐만이 아니라 `willSet`과 `didSet`같은 것들도 정의할 수 있습니다. 하지만 Kotlin처럼 지원 필드는 자동으로 정의되지 않습니다.

Kotlin에서는 `didSet`과 같은 언어 기능은 존재하지 않기 때문에 이식은 setter에서 에뮬레이트하는 방식을 이용합니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class User {
    let id: Int
    var familyName: String = &quot;yamada&quot;
    var firstName: String = &quot;taro&quot;

    var fullName: String {
        get { return &quot;\(familyName) \(firstName)&quot; }
    }
    var died: Bool = false {
        didSet {
            if died {
                print(&quot;\(fullName)는 죽어버렸다...&quot;)
            }
        }
    }
    init(_ id: Int) {
        self.id = id
    }
}

func main() {
    let u = User(3)
    u.familyName = &quot;saito&quot;
    u.died = true // saito taro는 죽어버렸다... 라고 표시됩니다.
}

main()&lt;/code&gt;&lt;/pre&gt;

Java에서는 필드와 프로퍼티는 명확하게 구분되어있으며 메소드로 직접 getter과 setter를 구현한 것을 프로퍼티라고 부릅니다.

이 부분이 이식할 때 귀찮은 일이 되어버립니다. Swift로 쓰인 다음 클래스가 있다고 생각해봅시다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class User {
    var died: Bool = false
}

func hoge(u: User) {
    u.died = true
}&lt;/code&gt;&lt;/pre&gt;

이것을 Java의 필드로 이식해보겠습니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;class User {
    boolean died = false;
}

void hoge(User u) {
    u.died = true
}&lt;/code&gt;&lt;/pre&gt;

그 뒤에 Swift 코드가 이렇게 변했다고 칩시다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class User {
    var died: Bool = false
    didSet {
        println(&quot;죽어버렸다!&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;

이런 경우 Java에서는 다음과 같이 수정해야합니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;class User {
    boolean died = false;
    boolean getDied() { return died; }
    void setDied(boolean value) { 
        died = value;
        println(&quot;죽어버렸다!&quot;);
    }
}

void hoge(User u) {
    u.setDied(true);
}&lt;/code&gt;&lt;/pre&gt;

getter와 setter를 직접 구현해야 하는 것은 둘째치고, 필드에 대입하고 있는 부분을 setter를 호출할 때 구현해야 할 필요가 있습니다.

이것은 여러 부분에 있습니다만 원래 이식하는 곳에서는 diff가 발생하지 않기 때문에 놓칠 위험이 큽니다. 간과해버렸다간 버그가 나며 심지어 컴파일했을 때 알 수도 없습니다.

만약 10번 있는 대입에 한 곳만의 지원을 잊어버린다면 이건 매우 귀찮은 버그가 될 것입니다. 그러므로 프로퍼티가 있는 언어에서 이식한다면 프로퍼티가 있는 언어로 이식하는게 바람직합니다.

### Java 프로퍼티 접근자의 프로퍼티화

Java에서 필드 `name`에 대해 `name`이라는 프로퍼티를 만들 때는 getter로 `String getName ()`과 setter로 `void setName(String name)`을 정의합니다.
그리고 호출 시, 아래와 같이 함수 호출의 형태를 취합니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;// 읽기
String name = user.getName();
// 쓰기
user.setName(newName);&lt;/code&gt;&lt;/pre&gt;

하지만 Kotlin의 경우에는 프로퍼티 `name`에 대해서 호출할 때 함수의 형태를 띄지 않습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;// 읽기
val name = user.name
// 쓰기
user.name = newName&lt;/code&gt;&lt;/pre&gt;

함수 호출의 형태는 아닙니다만 name에 대한 getter와 setter가 동작하게 됩니다.

Kotlin에서 Java 메소드를 호출할 때 이러한 `getXxxx()`와 `setXxxx(value)`를 Kotlin의 프로퍼티 `xxxx`를 취급할 때 엑세스할 수 있습니다.
예를 들어, 아래코드는 안드로이드에서 버튼을 보이지 않게 만드는 코드입니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;button.visibility = View.INVISIBLE&lt;/code&gt;&lt;/pre&gt;

Android SDK는 Java로 작성되었으므로 원래는 `setVisibility()`를 호출하는게 맞지만, Kotlin에서는 마치 `visibility`라는 프로퍼티에 접근하는 것처럼 사용할 수 있습니다.

### Delegated Property

Delegated Property는 Kotlin의 재미있는 기능입니다. 프로퍼티의 getter와 setter의 구현을 다른 객체에 넘기는 것이 가능합니다.

#### Lazy

예로 Lazy를 들어보겠습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;val fullName: String by lazy {
    familyName + &quot; &quot; + firstName
}&lt;/code&gt;&lt;/pre&gt;

`fullName`은 상수이지만, 처음 getter가 호출되었을 때 lazy에 전달하는 클로져가 실행되고 그 결과가 반환됩니다. 두번째 이후부터 getter 호출에서는 첫번째 결과가 저장됩니다. 만약 이것을 Java로 구현하고자 할 때는, getter에서 if문을 작성해야만 합니다. 이러한 일반적으로 중복되는 코드를 쓸 필요가 없습니다.

Swift에서도 `lazy`라는 키워드가 있고 동일한 기능을 제공하는 언어 기능이 있습니다. 그러나 Kotlin이 흥미로운 점은 lazy가 특별한 언어 기능이 아니라 `by`만이 언어 기능으로, lazy는 그저 [클로져를 인수로 취하는 표준 라이브러리 함수](http://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html)인 것입니다. 이 함수가 반환하는 객체가 실제 프로퍼티의 getter와 setter를 처리합니다.

#### notNull

**이 문단은 오래되었습니다. M13에서부터는 lateinit을 사용하는 편이 더 좋다고 생각됩니다.**

또 한 가지, 흥미로운 델리게이트를 소개해보곘습니다. 

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;var name: String by Delegates.notNull()&lt;/code&gt;&lt;/pre&gt;

이것은 한번 설정되지 않은 상태에서 getter가 호출될 경우 예외가 생겨 크래시가 납니다. 한번 설정된 이후에는 getter가 일반적으로 값을 읽어올 수 있습니다.
Swift에서 이와 비슷한 형태를 갖는 것은 느낌표`!` 형태입니다. 정확하게 말하자면 `Implicitly Unwrapped Optional`이라고 말합니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;var name: String!&lt;/code&gt;&lt;/pre&gt;

이것은 초기 상태가 nil로 nil의 상태로 읽었을 때는 크래시가 나지만 값이 들어있을 때는 보통과 똑같이 사용할 수 있습니다.
Kotlin과의 미묘한 차이는 Kotlin은 notNull에 null을 넣을 수 없지만 Swift의 `!`에는 nil을 넣을 수 있다는 것이겠네요.
Swift의 `!`는 어디까지나 Optional이라는 것이군요.

그러나 대부분의 경우 일부러 nil을 넣는 일을 하지 않기 때문에 이식하는데는 크게 문제가 없습니다.
보통 그런 일은 Optional에다가 하는 것이 더 바람직하니까요.

이 경우도 Swift에서는 언어 기능이지만 Kotlin에서는 표준 라이브러리가 제공하는 구현입니다.
재미있습니다.

#### KotterKnife

Android 앱을 만들 때 제일 많은 부분이 View의 바인딩인데, ButterKnife를 만든 사람이 [KotterKnife](https://github.com/JakeWharton/kotterknife)라고 하는 Kotlin 버전의 ButterKnife를 제공하고 있습니다.

##### 역주

ButterKnife를 만든 사람은 Square라는 결제 관련 POS 시스템을 만드는 회사에 있는 Jake Wharton이라는 분입니다. ButterKnife는 리소스나 뷰의 바인딩을 쉽게 도와주는 라이브러리로, 안드로이드 개발자들에게 Jake Wharton은 예전부터 다양한 라이브러리로 유명했었습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;public class PersonView(context: Context, attrs: AttributeSet?) : LinearLayout(context, attrs) {
  val firstName: TextView by bindView(R.id.first_name)
  val lastName: TextView by bindView(R.id.last_name)

  // Optional binding.
  val details: TextView? by bindOptionalView(R.id.details)

  // List binding.
  val nameViews: List&lt;textview&gt; by bindViews(R.id.first_name, R.id.last_name)

  // List binding with optional items being omitted.
  val nameViews: List&lt;textview&gt; by bindOptionalViews(R.id.first_name, R.id.middle_name, R.id.last_name)
}

`@IBOutlet`이나 `!`를 사용한 iOS 개발과, 어노테이션과 리플렉션으로 구현된 Android의 ButterKnife보다 이 방식이 깔끔하고 바람직하다고 생각됩니다.
또한 빌드에 개입하는 것으로 확장 메소드를 구현해주고, 프로퍼티 정의조차 불필요한 플러그인이 있습니다.

나는 이런 언어기능이 바람직하다고 생각합니다.

### lateinit

프로퍼티에 대한 한정자로 `lateinit`을 사용하면, 초기값이 불필요한 Optional이 아닌 변수를 정의할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class User {
    lateinit var name: String
}&lt;/code&gt;&lt;/pre&gt;

lateinit으로 지정되어있는 변수는 쓰기 전에 읽으면 크래시가 납니다. Swift의 `!`처럼 사용할 수 있습니다.

#### Delegate.notNull과의 차이

Delegate.notNull과의 차이는 잘 모르겠습니다. 문서에 따르면 lateinit은 자연스럽게 필드명을 만들어서 DI 도구와의 궁합이 좋다고 쓰여있습니다.
아마도 자동생성 바이트코드나 리플렉션에 대한 부분이 아닐까 생각합니다.

하지만 Kotlin 코드 만의 세계에서 보면 그 차이는 중요하지 않습니다.

유일하게 찾아낸 것은 lateinit는 상수에는 사용하지 못하고 변수에만 사용할 수 있습니다. notNull는 상수에도 사용할 수 있습니다.

그러나 notNull가 상수에 사용하는 것은 충돌 가능성만 있고 혜택은 전혀 없기 때문에 상수에서의 사용이 금지 된 lateinit 쪽이 안전하고 약간 우수하다고 생각합니다.

위에서 말한 이유로 notNull이 언어 기능에 의존하지 않는 매력이지만 lateinit을 쓰는 편이 더 바람직해보입니다.

### 제네릭과 Declaration Site Variance

Kotlin은 제네릭을 지원하고 있습니다. 제네릭형 매개변수의 variance에 대해서는 Declaration Site Variance라고 칭하고 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;open class Animal
class Cat: Animal()

class Box&lt;out t=&quot;&quot;&gt;(val value: T) {
    override fun toString(): String = &quot;Box($value)&quot;
}

fun main(args: Array&lt;string&gt;) {
    val a: Box&lt;animal&gt;
    val b: Box&lt;cat&gt; = Box(Cat())
    a = b
    println(a) // Box(Cat@xxxxxxxx)로 표시
}

Variance가 작동하고 있으므로 Box의 값을 Box의 변수에 대입할 수 있습니다.

Declaration Site라고 하는 것은 선언 시에 지정하는 것으로 Box의 변수형 파라미터 T를 쓰는 그 자리에서 `out T`라고 기술함으로써 Box가 T에 대해 covariance라고 선언하고 있습니다.
이 out을 지우면 컴파일 에러가 발생합니다. Swift도 Declaration Site지만, Java는 Use Site입니다.

Java로 위의 예를 쓰면 다음과 같습니다.

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;class Animal {}
class Cat extends Animal {}

class Box&lt;t&gt; {
    final T value;
    Box(T value) {
        this.value = value;
    }
    public String toString() { return &quot;Box(&quot; + value.toString() + &quot;)&quot;; }
}

public class Main {
    public static void print(String str) {
        System.out.println(str);
    }
    
    public static void main (String[] args) throws java.lang.Exception {
        final Box&amp;lt; ? extends Animal&amp;gt; a;
        final Box&lt;cat&gt; b = new Box&lt;cat&gt;(new Cat());
        a = b;
        print(a.toString()); // Box(Cat@xxxxxxxx)라고 출력된다.
    }
}

Box 자체의 정의에 대한 Variance에 대해 적지 않고 `a`라는 로컬 변수를 정의할 때의 형태를 꺽쇠 기호`&amp;lt;&amp;gt;`로 설명하고 있습니다. 그 외 함수 인수의 정의에서 꺽쇠 기호가 나옵니다.

Declaration Site와 Use Site의 좋고 나쁨에 대해서는 여기까지만 이야기하겠습니다. 저는 Declaration Site 쪽을 선호하기 때문에 Kotlin을 선호합니다. 그 외 Swift나 C#, Go 또한 Declaration Site입니다.

Swift도 동일하기 때문에 Swift로부터 이식하기 쉽습니다. 그러나 Swift에서 Java로의 이식은 꽤나 힘듭니다. 선언은 한 곳에서 함에도 불구하고 사용 부분(함수 인수나 지역 변수)은 많이 있어서 이론적으로는 그것을 `? extends T`나 `? super T`로 쓰지 않으면 올바르게 이식되지 않습니다.

Variance를 버리고 컴파일 에러가 나는 곳만을 고치는 일이 생길 수도 있습니다.

### 클로져와 전역 탈출

Kotlin의 클로져는 생각지도 못한 기능을 가지고 있습니다. 다음 코드는 다른 언어에 익숙한 사람에게는 의미불명으로 보입니다.
또한 `forEach`는 클로져를 하나의 인수로 취하여 리시버의 요소 하나하나에 대하여 클로져를 호출합니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hasZeros(ints: List&lt;int&gt;): Boolean {
  ints.forEach {
    if (it == 0) { return true }
  }
  return false
}

사실 이 코드는 `forEach`에 쓰여진 `return true`가 그 클로져 자신이 아닌 `fun hasZeros()`를 탈출하는 것입니다. 원래 Kotlin의 클로져 안에는 return을 쓸 수 없습니다. 클로져의 실행 결과는 클로져 코드 마지막의 식의 값입니다.

예외적으로 인라인된 콜백 함수에서는 `return`을 쓸 수 있고 그 경우에는 return을 호출한 곳에서부터 가장 가까운 함수를 탈출하게 됩니다.

forEach의 구현은 다음과 같습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;public inline fun &lt;t&gt; Iterable&lt;t&gt;.forEach(operation: (T) -&amp;gt; Unit): Unit {
    for (element in this) operation(element)
}

이 `fun` 앞에 있는 `inline`이 포인트입니다. 이것이 붙어있으면 함수가 인라인이라는 것을 뜻하는데, 이 함수를 호출하는 곳에 이 함수의 내용이 쓰여지는 것과 같습니다. 즉 위의 예시는 아래와 같이 해석된다고 보면 됩니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun hasZeros(ints: List&lt;int&gt;): Boolean {
    for (i in ints) {
        if (i == 0) { return true }
    }

    return false
}

이걸로 왜 전역 탈출이 가능하게 되었는지 알 수 있었습니다. 또한 `inline`의 지정은 무턱대고 있는 것이 아닙니다. 인라인할 수 없는 함수에 붙어있을 경우에는 컴파일 에러가 납니다.

그래서 이 전역 탈출이라는 기능은 위험한 냄새가 납니다. 올바르게 사용할 때만 구현해서 이용할 수 있으며 그렇지 않을 경우에는 컴파일 에러가 나기 때문에 안전합니다.

이게 가능하기 때문에 `forEach`도 그렇습니다만 콜백 함수를 정의하여 제어 구문을 자작할 수 있는 효과가 있습니다.

예를 들면 `run`이라고 하는 표준 함수가 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;public inline fun &lt;r&gt; run(f: () -&amp;gt; R): R = f()

인수로 주어진 클로져만을 실행하기 위한 함수이지만, 이것은 로컬 스코프를 만드는데 사용할 수 있습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;fun setup() {
    run {
        val x = 3
        if (!createPoint(x)) { return }
    }
    run {
        val x = &quot;taro&quot;
        if (!createUser(x)) { return }
    }
    println(&quot;ok!&quot;)
}&lt;/code&gt;&lt;/pre&gt;

위의 예에서는 2개의 x는 각각 다른 클로져의 지역 변수이므로 충돌하지 않습니다.
그리고 `createPoint`가 실패했을 때 `setup` 자체를 중단하고 있습니다.

Swift에서 똑같이 콜백 함수를 사용하고자 하면 그 안에 return을 쓸 수 없게 되기 때문에 `for in`이나 `if true {}`를 사용하지 않을 수 없습니다.

반대로 말하면 이런 것들을 사용하면 구문과 같은 것들을 만들 수 있다는 뜻이 됩니다.
run에서는 사실 또 정의가 있고 그것을 사용하면 이런 코드를 만들 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class User {
    var name: String = &quot;&quot;
    var age: Int = 0
}

fun hoge(user: User) {
    user.run {
        name = makeUserName() ?: return
        age = 3
    }
}&lt;/code&gt;&lt;/pre&gt;

`run`의 안에서 액세스 되어있는 `name`이나 `age`는 `user`의 프로퍼티입니다.
이 클로져의 안은 User의 메소드를 실행할 때와 같은 this 스코프입니다. 그리고 당연한 이야기지만 그 안에서도 전역 탈출을 쓸 수 있습니다.

이것의 구현은 아래와 같습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()&lt;/code&gt;&lt;/pre&gt;

모든 타입 T에 대한 확장 메소드 run으로 정의되어 있으며 인수의 클로져의 자료형은 T의 메소드, 즉 리시버로 T 자료형의 인스턴스를 받도록 되어있습니다.
본체의 `f()`는 확장 메소드의 정의 중이기 때문에 `this.f()`의 축약형입니다.

클로져의 형태가 run의 인수에 따라서 T 자료형의 메소드의 형태로 해결하고 있으므로 콜백 메소드 안에서 name과 age가 `this.` 없이 접근할 수 있는 것입니다.

이 클로져의 메소드 형태에 대한 해결책이 정말 강력합니다. 더 복잡한 응용 예는 다음과 같습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun result(args: Array&lt;string&gt;) =
  html {
    head {
      title {+&quot;XML encoding with Kotlin&quot;}
    }
    body {
      h1 {+&quot;XML encoding with Kotlin&quot;}
      p  {+&quot;this format can be used as an alternative markup to XML&quot;}

      // an element with attributes and text content
      a(href = &quot;http://kotlinlang.org&quot;) {+&quot;Kotlin&quot;}

      // mixed content
      p {
        +&quot;This is some&quot;
        b {+&quot;mixed&quot;}
        +&quot;text. For more see the&quot;
        a(href = &quot;http://kotlinlang.org&quot;) {+&quot;Kotlin&quot;}
        +&quot;project&quot;
      }
      p {+&quot;some text&quot;}

      // content generated by
      p {
        for (arg in args)
          +arg
      }
    }
  }

이걸 보면 HTML을 간단한 문법으로 쓰고 있는 것 같아도 이건 엄연히 Kotlin 코드입니다. 게다가 body 태그는 html 태그에 쓰기 같은 것들이 정적 타이핑 검사되고 있습니다.

[자세한 내용은 문서를 읽어보십시오.](http://kotlinlang.org/docs/reference/type-safe-builders.html)

그런데 전역이 아닌 클로져를 중단하고 싶은 로컬한 return을 쓰고 싶을 때가 있습니다. 그런 경우에는 또 다른 클로져 표기법을 쓸 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;listOf(1,2,3,4).forEach(fun(i) {
    if (i % 2 == 0) return
    print(i)    
})
// 13이 출력됩니다.&lt;/code&gt;&lt;/pre&gt;

`fun` 표기가 있으면 인라인과는 전혀 관계 없이 클로져에서 항상 return을 사용할 수 있습니다. 그리고 로컬한 return이 됩니다. 아까 말했듯이 return을 호출한 곳에서부터 가장 가까운 함수를 탈출한다는 규칙에도 맞습니다.

### 기본 생성자

Kotlin에서는 생성자를 다중 정의할 수 있습니다. 그리고 특별한 기본 생성자는 생성자를 하나만 만들 수 있습니다.
이 생성자가 있는 경우에는 다른 생성자는 결국 기본 생성자를 호출할 수밖에 없습니다.

그리고 기본 생성자는 인수 정의와 동시에 속성 정의를 할 수 있는데, 이 기능이 꽤 유용합니다. 키워드를 한 번 쓰는 것만으로 되니까요.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class Person(val name: String, val age: Int, val height: Double) {
    init {
        // 기본 생성자의 본문입니다.
        print(&quot;1&quot;)
    }

    constructor(name: String): this(name, 20, 170.0) {
        // 2차 생성자의 본문입니다.
        print(&quot;2&quot;)
    }

    constructor(): this(&quot;saito&quot;) {
        // 2차 생성자의 또 다른 하나입니다. 다른 2차 생성자를 호출하고 있습니다.
        print(&quot;3&quot;)
    }
}

fun main(args: Array&lt;string&gt;) {
    Person(&quot;yamada&quot;, 19, 160.0) // 1이 출력됩니다.
    println()
    Person(&quot;tanaka&quot;) // 12가 출력됩니다.
    println()
    Person() // 123이 출력됩니다.
    println()
}

기본 생성자의 인수로 있는 상수가 프로퍼티 정의를 지정합니다.

기본 생성자를 정의하지 않는 것 또한 가능합니다.

Swift의 경우에는 지정 이니셜라이저(Designated Initializer)와 편의 이니셜라이저(Convience Initializer)가 있습니다.
Kotlin과 같이, 편의 이니셜라이저는 지정 이니셜라이저를 호출할 필요가 있습니다.
Kotlin하고는 다르게 지정 이니셜라이저를 다중 정의할 수도 있습니다.

생성자에서 프로퍼티 정의 구문이 없기 때문에 프로퍼티, 생성자의 인수, 생성자의 본문에서 왼쪽 값, 오른쪽 값으로 총 4번 동일한 키워드를 쓸 수밖에 없습니다.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;class Person {
    let name: String
    let age: Int
    let height: Double

    init(_ name: String, _ age: Int, _ height: Double) {
        // 기본 생성자 1
        self.name = name
        self.age = age
        self.height = height
    }
    init(_ name: String, _ age: Int, _ height: Int) {
        // 기본 생성자 2
        self.name = name
        self.age = age
        self.height = Double(height)
    }
    convenience init(_ name: String) {
        // 2차 생성자 1
        self.init(name, 20, 170.0)
    }
    convenience init() {
        // 2차 생성자 2
        self.init(&quot;saito&quot;)
    }
}&lt;/code&gt;&lt;/pre&gt;

이식의 관점에서 보면 Swift에서 지정 이니셜라이저가 다수 있어도 프로퍼티를 모두 채울 기본 생성자를 만들고 나머지 지정 이니셜라이저와 편의 이니셜라이저를 보조로 쓰면 크게 문제되지 않는다고 생각됩니다.

Java의 경우 Swift와 거의 비슷한 규칙이지만 convenience같은 키워드는 존재하지 않네요.

### 특별한 자료형

Kotlin만이 가지고 있는 특별한 자료형에 대해 소개해보고자 합니다.

#### Any

Any는 모든 자료형를 취할 수 있는 자료형입니다. 하지만 Optional 자료형은 취할 수 없습니다.
제네릭형의 매개변수를 정의할 때 null을 제거할 때 쓰입니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class NonNullBox&lt;t: any=&quot;&quot;&gt;
class NullableBox&lt;t&gt;

`NonNullBox`에는 Optional 자료형이 들어갈 수 없지만 `NullableBox`는 들어갈 수 있습니다.

#### Unit

Unit은 값이 하나 밖에 없고, 다른 형식으로 독립한 자료형입니다.
C의 void와 Swift의 Void 등에 대응하며, 함수 반환 값의 자료형을 생략했을 때는 Unit이 반환됩니다.
Unit 자료형의 값은 Unit입니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun a(): Unit {
    return Unit
}
fun b(): Unit {
    return
}
fun c() { }&lt;/code&gt;&lt;/pre&gt;

여기서 `a`, `b`, `c`는 모두 같은 의미입니다.

역으로 Kotlin엔 void라는 개념이 존재하지 않습니다.

#### Nothing

Nothing은 값이 존재하지 않고 다른 모든 타입에 할당할 수 있는 자료형입니다. Any는 모든 자료형를 대입할 수 있지만 그것과 반대로 되어있습니다.
값이 존재하지 않기 때문에 함수의 반환 값으로 지정하면 들어가면 절대로 탈출하지 않는 함수가 됩니다. 값이 존재하지 않기 때문에 반환 값을 return 할 수 없기 때문입니다.

다음과 같은 코드를 컴파일 할 수 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;fun crash(): Nothing {
    throw Exception()
}

fun mainLoop(proc: ()-&amp;gt; Unit): Nothing {
    while (true) {
        proc()
    }
}&lt;/code&gt;&lt;/pre&gt;

이외에도 Nothing의 값이 존재하지 않는 것을 이용하여 `null`에만 매칭되는 변수의 형태를 만들 수 있습니다. 예를 들면 다음과 같습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class Json {
    constructor(aNull: Nothing?) {}
    constructor(aString: String) {}
}&lt;/code&gt;&lt;/pre&gt;

이렇게 하면 `Json(null)`은 첫 번째 생성자, `Json(&quot;aaa&quot;)`는 두번째 생성자라는 식으로 오버로드를 구분할 수 있습니다. Kotlin에서는 null 자체에는 자료형이 없기 때문에 이렇게 Nothing을 사용하고 있습니다.

그런데 값이 존재하지 않는데 할당 할 수 있다는 것은 무슨 뜻인가하면, 제네릭의 Variance에서 이것이 효과가 있습니다. 아래를 예로 들어보곘습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;class Result&amp;lt;out T: Any, out E: Any&amp;gt; 
    private constructor(
        val value: T?, 
        val error: E?) 
{
    companion object {
        fun &amp;lt;T: Any, E: Any&amp;gt; Ok(value: T): Result&amp;lt;T, E&amp;gt; = Result(value, null)
        fun &amp;lt;T: Any, E: Any&amp;gt; Error(error: E): Result&amp;lt;T, E&amp;gt; = Result(null, error)
    }
}

fun proc1(): Result&amp;lt;Int, Nothing&amp;gt; {
    return Result.Ok(3)
}

fun main(args: Array&lt;string&gt;) {
    val ret: Result&amp;lt;Int, Exception&amp;gt; = proc1()
}

Result는 값과 에러의 두 가지 자료형를 covariance로 가지는 제너릭형입니다. 여기서 `proc1`은 절대로 문제가 생길 일이 없는 메소드이므로 오류값에 대해 Nothing으로 지정하고 있습니다.
그리고 그 결과를 `Result&amp;lt;Int, Exception&amp;gt;`에 대입하고 있습니다. 즉, 일반 오류가 있을 수 있는 경우의 처리에 대해 에러가 없었던 경우의 자료형을 형변환 없이 안전하게 할당 할 수 있습니다.

이것은 `Nothing is Exception`이기 떄문입니다만 is의 오른쪽에는 어떤 자료형도 넣을 수도 있습니다. Exception 대신 에러 메세지로 String으로 에러를 핸들링하고 있는 경우에도 `Result&amp;lt;Int, String&amp;gt;`에 `Result&amp;lt;Int, Nothing&amp;gt;`을 넣을 수 있다는 것입니다. 값이 존재하지 않기 때문에 무엇이든 될 수 있다는 것은 흥미롭습니다.

### 데이터 클래스와 튜플

Kotlin에는 데이터 클래스라는 기능이 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;data class Vector3(val x: Double, val y: Double, val z: Double)

fun main(args: Array&lt;string&gt;) {
    val a = Vector3(1.0, 2.0, 3.0)
    println(a) // Vector3(x=1.0, y=2.0, z=3.0) 라고 출력됩니다.
    val (x, y, z) = a
    val b = a.copy(x=0.0, z=4.0)
    println(b) // Vector3(x=0.0, y=2.0, z=4.0) 라고 출력됩니다.
}

데이터 클래스를 이용하면 몇개의 메소드가 자동적으로 생성됩니다.

`equals`와 `hashCode`가 정의됩니다. 이것을 통해 직접 비교를 할 수 있으며 Map의 키로서도 쓸 수 있습니다.

`toString`이 정의됩니다. 프로퍼티의 값이 표시되기 때문에 디버깅이 편합니다.

`componentN`이 정의됩니다. 위 코드에서 Vector3의 경우에는 `component1()`, `component2()`, `component3()`이 정의되겠군요. 이것은 각각의 프로퍼티에 대한 getter입니다. 그리고 이것이 정의된 클래스는 이러한 프로퍼티를 변수에 각각 할당할 수 있습니다. `val (x, y, z) = a` 이 대목에서 볼 수 있는 부분입니다.

`copy`가 정의됩니다. 이것은 프로퍼티와 동명의 인수를 취하는 메소드에서 기본 인수로서 자신의 프로퍼티 값이 설정되어 있습니다. 그리고 인수로 지정된 속성을 지정한 새로운 인스턴스를 반환합니다. 따라서 특정 프로퍼티만을 바꾼 복사본을 만드는 방법입니다.

불변 프로그래밍(Immutable Programming)을 하려고 하면 특정 프로퍼티만 바꾼 복사본을 만드는게 복잡합니다. `withName(newName) //name 만 변경한 복사본을 반환`와 같이 하나만 변경하는 것을 모든 프로퍼티에 대해 준비하더라도 다수의 프로퍼티를 변경할 때는 그만큼의 메소드 체인을 써야합니다. 한편, 모든 프로퍼티를 가지는 생성자는 있습니다만, 모두는 변화하지 않는 경우는 같은 값을 다시 지정하는 것이 귀찮습니다. `copy`는 이 귀찮은 일로부터 프로그래머를 해방시켜주어 불변의 원칙을 더욱 쉽게 사용할 수 있게 해줍니다.

Kotlin에서는 튜플 기능은 존재하지 않습니다. 그러나 데이터 클래스를 이용하면 같은 기능을 이용할 수 있습니다. 위에서 예를 나타낸 것과 같이 클래스 정의라고 해봤자 최소한의 타이핑으로 할 수 있으므로 그다지 귀찮은 일은 아닙니다.

### 별명 임포트

Kotlin에서는 별명 임포트라는 기능이 있습니다. 다른 두 개의 패키지에 동일한 클래스의 이름이 있을 때 각각 별명을 붙여 가져올 수 있는 기능으로 그 긴 풀 패키지 네임을 쓸 필요가 없습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;import com.omochimetaru.Bitmap as MyBitmap
import android.graphics.Bitmap as ABitmap

fun hoge(a: MyBitmap) {
}

fun fuga(a: ABitmap) {
}&lt;/code&gt;&lt;/pre&gt;

Swift에서도 같은 기능을 쓸 수 있습니다. Java라면 이게 괴로웠겠죠?

&lt;pre class=&quot; language-java &quot;&gt;&lt;code&gt;import com.omochimetaru.Bitmap;
import android.graphics.Bitmap;

void hoge(com.omochimetaru.Bitmap a) {
}

void fuga(android.graphics.Bitmap a) {
}&lt;/code&gt;&lt;/pre&gt;

### Enum, 값을 포함한 Enum, Sealed Class(Tagged Enum)

Kotlin에서도 당연히 Enum이 있습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;enum class Direction {
    NORTH, SOUTH, WEST, EAST
}

enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}&lt;/code&gt;&lt;/pre&gt;

두번째 예와 같이 값을 포함한 Enum도 만들 수 있습니다. 그러나 Swift에서 할 수 있는 같은 enum마다 다른 property를 갖게 하는 Tagged Enum이라는 기능은 enum으로는 만들 수 없습니다.

Swift의 예를 한번 보시죠.

&lt;pre class=&quot; language-swift &quot;&gt;&lt;code&gt;enum Either&amp;lt;T, U&amp;gt; {
    case Left(T)
    case Right(U)
}&lt;/code&gt;&lt;/pre&gt;

Left와 Right에서 프로퍼티의 자료형이 다릅니다. 기타 Optional에서는 Some에는 프로퍼티가 있지만 None에는 없는 것과 같은 패턴도 있습니다.

Kotlin에는 `sealed class`라는걸 이용해서 같은 것을 만들 수가 있습니다. sealed class라는 것은 상속을 금지한 클래스입니다. 그러나 그 클래스의 내부에서는 상속할 수 있습니다. 따라서 사전에 준비한 서브클래스만을 가질 수 있는 클래스가 됩니다.

그렇다면 when문(C나 Java의 switch문)에서 자료형 판정을 체크할 수 있어서 분기에서 문제가 생기지 않는 것을 컴파일러에 의해 보장받습니다.

&lt;pre class=&quot; language-kotlin &quot;&gt;&lt;code&gt;sealed class Expr {
    class Const(val number: Double) : Expr()
    class Sum(e1: Expr, e2: Expr) : Expr()
    object NotANumber : Expr()
}

fun eval(expr: Expr): Double = when(expr) {
    is Const -&amp;gt; expr.number
    is Sum -&amp;gt; eval(expr.e1) + eval(expr.e2)
    NotANumber -&amp;gt; Double.NaN
    // the `else` clause is not required because we&#39;ve covered all the cases
}&lt;/code&gt;&lt;/pre&gt;

위의 예와 같이 Smart Cast가 있으므로 when문에서는 같은 변수 이름이 이미 형변환된 상태입니다.

### Type Alias가 없다.

Kotlin에서는 Type Alias와 같은 기능이 없습니다. Swift에서는 까다로운 클로져형 등에 이름을 붙일 수 있지만, 이런 코드를 Kotlin으로 이식하면 전부 빨간 밑줄이 그어집니다.

## 끝으로

이 내용 중 쓸 수 없는 경우도 있겠지만 여기까지 읽은 사람이라면 꽤나 Kotlin이 쓰고 싶은게 아닐까요!
&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/t:&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/r&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/int&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/t&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/int&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/cat&gt;&lt;/cat&gt;&lt;/t&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/cat&gt;&lt;/animal&gt;&lt;/string&gt;&lt;/out&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/textview&gt;&lt;/textview&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/integer&gt;&lt;/string&gt;&lt;/integer&gt;&lt;/integer&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/element&gt;&lt;/element&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/int&gt;&lt;/int&gt;&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 17 Oct 2015 09:00:00 +0900</pubDate>
        <link>http://realignist.me/code/2015/10/17/translated-kotlin-was-awesome.html</link>
        <guid isPermaLink="true">http://realignist.me/code/2015/10/17/translated-kotlin-was-awesome.html</guid>
        
        <category>translate</category>
        
        <category>android</category>
        
        <category>kotlin</category>
        
        <category>swift</category>
        
        
        <category>Code</category>
        
      </item>
    
  </channel>
</rss>
